============================================================================== 
STRUCTURED LENDING PROTOCOL - FULL PROJECT SHARE 
============================================================================== 
GitHub: poolsyncdefi-ui/structured-lending-protocol-clean 
Repo URL: https://github.com/poolsyncdefi-ui/structured-lending-protocol-clean 
Date: 06/01/2026 Time: 18:22:41,41 
 
[GIT INFORMATION] 
------------------------------------------------------------------------------ 
Branch: main 
Commit: 50cefe3 
 
[CONTRACTS DIRECTORY - *.sol files] 
============================================================================== 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.20; 
3: contract PoolSyncTest { 
4:     string public name = "PoolSync"; 
5:     uint256 public version = 1; 
6:      
7:     function getName() public view returns (string memory) { 
8:         return name; 
9:     } 
10:      
11:     function getVersion() public view returns (uint256) { 
12:         return version; 
13:     } 
14: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: contract TestContract { 
4:     function createOffer() public pure returns (uint256) { 
5:         return 1; 
6:     } 
7:      
8:     function callCreateOffer() public pure returns (uint256) { 
9:         return createOffer(); 
10:     } 
11: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/Ownable.sol"; 
4: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
5: import "@openzeppelin/contracts/utils/Pausable.sol"; 
6: /** 
7:  * @title BondingCurve - Courbe de liaison pour prix dynamique des jetons 
8:  * @notice Implémente une courbe de liaison pour ajuster le prix des jetons de pool 
9:  */ 
10: contract BondingCurve is Ownable { 
11:          
12:     struct CurveParameters { 
13:         uint256 basePrice;           // Prix de base 
14:         uint256 slope;               // Pente de la courbe 
15:         uint256 exponentialFactor;   // Facteur exponentiel 
16:         uint256 maxPriceMultiplier;  // Multiplicateur max 
17:         uint256 liquiditySensitivity; // Sensibilité à la liquidité 
18:     } 
19:      
20:     // Paramètres par défaut 
21:     CurveParameters public params; 
22:      
23:     // Données par pool 
24:     struct PoolCurveData { 
25:         uint256 initialPrice; 
26:         uint256 totalSupply; 
27:         uint256 currentPrice; 
28:         uint256 lastUpdate; 
29:         uint256 volume24h; 
30:     } 
31:      
32:     mapping(uint256 => PoolCurveData) public poolCurves; 
33:      
34:     // Événements 
35:     event PriceUpdated(uint256 indexed poolId, uint256 oldPrice, uint256 newPrice); 
36:     event CurveParametersUpdated(uint256 timestamp); 
37:      
38:     constructor() Ownable(msg.sender) { 
39:         // Paramètres par défaut 
40:         params = CurveParameters({ 
41:             basePrice: 1 * 10**18,       // 1.0 stablecoin 
42:             slope: 100,                  // 0.01% par token 
43:             exponentialFactor: 2,        // Courbe quadratique 
44:             maxPriceMultiplier: 200,     // 2x max 
45:             liquiditySensitivity: 50     // 0.5% de sensibilité 
46:         }); 
47:     } 
48:      
49:     /** 
50:      * @notice Calcule le prix d'achat pour des tokens 
51:      */ 
52:     function calculateBuyPrice( 
53:         uint256 poolId, 
54:         uint256 tokenAmount, 
55:         uint256 currentSupply 
56:     ) external view returns (uint256 totalCost, uint256 averagePrice) { 
57:         PoolCurveData storage curve = poolCurves[poolId]; 
58:          
59:         if (curve.totalSupply == 0) { 
60:             // Premier achat 
61:             totalCost = tokenAmount * params.basePrice; 
62:             averagePrice = params.basePrice; 
63:         } else { 
64:             // Calcul basé sur la courbe 
65:             totalCost = _calculateIntegral( 
66:                 curve.totalSupply, 
67:                 curve.totalSupply + tokenAmount, 
68:                 currentSupply 
69:             ); 
70:             averagePrice = totalCost / tokenAmount; 
71:         } 
72:          
73:         return (totalCost, averagePrice); 
74:     } 
75:      
76:     /** 
77:      * @notice Calcule le prix de vente pour des tokens 
78:      */ 
79:     function calculateSellPrice( 
80:         uint256 poolId, 
81:         uint256 tokenAmount, 
82:         uint256 currentSupply 
83:     ) external view returns (uint256 totalReturn, uint256 averagePrice) { 
84:         require(tokenAmount <= poolCurves[poolId].totalSupply, "Insufficient supply"); 
85:          
86:         totalReturn = _calculateIntegral( 
87:             poolCurves[poolId].totalSupply - tokenAmount, 
88:             poolCurves[poolId].totalSupply, 
89:             currentSupply 
90:         ); 
91:          
92:         averagePrice = totalReturn / tokenAmount; 
93:         return (totalReturn, averagePrice); 
94:     } 
95:      
96:     /** 
97:      * @notice Met à jour le prix après un achat/vente 
98:      */ 
99:     function updatePriceAfterTrade( 
100:         uint256 poolId, 
101:         uint256 tokenAmount, 
102:         bool isBuy, 
103:         uint256 currentSupply 
104:     ) external returns (uint256 newPrice) { 
105:         PoolCurveData storage curve = poolCurves[poolId]; 
106:          
107:         uint256 oldPrice = curve.currentPrice; 
108:          
109:         if (isBuy) { 
110:             curve.totalSupply += tokenAmount; 
111:         } else { 
112:             curve.totalSupply -= tokenAmount; 
113:         } 
114:          
115:         // Mise à jour du prix courant 
116:         newPrice = _calculateSpotPrice(curve.totalSupply, currentSupply); 
117:         curve.currentPrice = newPrice; 
118:         curve.lastUpdate = block.timestamp; 
119:          
120:         // Mise à jour du volume 24h 
121:         curve.volume24h += tokenAmount * newPrice; 
122:          
123:         emit PriceUpdated(poolId, oldPrice, newPrice); 
124:          
125:         return newPrice; 
126:     } 
127:      
128:     /** 
129:      * @notice Initialise la courbe pour un nouveau pool 
130:      */ 
131:     function initializePoolCurve(uint256 poolId, uint256 initialSupply) external onlyOwner { 
132:         require(poolCurves[poolId].totalSupply == 0, "Already initialized"); 
133:          
134:         poolCurves[poolId] = PoolCurveData({ 
135:             initialPrice: params.basePrice, 
136:             totalSupply: initialSupply, 
137:             currentPrice: params.basePrice, 
138:             lastUpdate: block.timestamp, 
139:             volume24h: 0 
140:         }); 
141:     } 
142:      
143:     /** 
144:      * @notice Réinitialise le volume 24h (à appeler périodiquement) 
145:      */ 
146:     function reset24hVolume(uint256 poolId) external onlyOwner { 
147:         poolCurves[poolId].volume24h = 0; 
148:     } 
149:      
150:     // ============ FONCTIONS INTERNES ============ 
151:      
152:     function _calculateSpotPrice(uint256 supply, uint256 currentSupply) internal view returns (uint256) { 
153:         if (supply == 0) return params.basePrice; 
154:          
155:         // Formule: price = basePrice * (1 + slope * supplyexponentialFactor) 
156:         uint256 supplyFactor = supply ** params.exponentialFactor; 
157:         uint256 priceIncrease = params.basePrice * params.slope * supplyFactor / (10**18); 
158:          
159:         // Ajustement par liquidité 
160:         uint256 liquidityAdjustment = 1; 
161:         if (currentSupply > 0) { 
162:             uint256 utilization = supply * 100 / currentSupply; 
163:             if (utilization > 80) { 
164:                 liquidityAdjustment = 120; // +20% si utilisation élevée 
165:             } else if (utilization < 20) { 
166:                 liquidityAdjustment = 80;  // -20% si utilisation faible 
167:             } 
168:         } 
169:          
170:         uint256 price = params.basePrice + priceIncrease; 
171:         price = price * liquidityAdjustment / 100; 
172:          
173:         // Limite maximale 
174:         uint256 maxPrice = params.basePrice * params.maxPriceMultiplier / 100; 
175:         if (price > maxPrice) price = maxPrice; 
176:          
177:         return price; 
178:     } 
179:      
180:     function _calculateIntegral( 
181:         uint256 fromSupply, 
182:         uint256 toSupply, 
183:         uint256 currentSupply 
184:     ) internal view returns (uint256) { 
185:         // Intégrale approximative de la fonction de prix 
186:         uint256 total = 0; 
187:         uint256 step = (toSupply - fromSupply) / 100; // 100 steps pour précision 
188:          
189:         if (step == 0) step = 1; 
190:          
191:         for (uint256 s = fromSupply; s < toSupply; s += step) { 
192:             uint256 price = _calculateSpotPrice(s, currentSupply); 
193:             total += price * step; 
194:         } 
195:          
196:         return total; 
197:     } 
198:      
199:     // ============ FONCTIONS ADMIN ============ 
200:      
201:     function updateCurveParameters( 
202:         uint256 basePrice, 
203:         uint256 slope, 
204:         uint256 exponentialFactor, 
205:         uint256 maxPriceMultiplier, 
206:         uint256 liquiditySensitivity 
207:     ) external onlyOwner { 
208:         require(basePrice > 0, "Base price must be positive"); 
209:         require(slope <= 1000, "Slope too high"); // Max 10% 
210:         require(exponentialFactor <= 3, "Exponential factor too high"); 
211:         require(maxPriceMultiplier <= 500, "Max multiplier too high"); // Max 5x 
212:          
213:         params = CurveParameters({ 
214:             basePrice: basePrice, 
215:             slope: slope, 
216:             exponentialFactor: exponentialFactor, 
217:             maxPriceMultiplier: maxPriceMultiplier, 
218:             liquiditySensitivity: liquiditySensitivity 
219:         }); 
220:          
221:         emit CurveParametersUpdated(block.timestamp); 
222:     } 
223:      
224:     function getPoolCurveData(uint256 poolId) external view returns (PoolCurveData memory) { 
225:         return poolCurves[poolId]; 
226:     } 
227: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; 
4: import "@openzeppelin/contracts/access/Ownable.sol"; 
5: import "@openzeppelin/contracts/utils/Strings.sol"; 
6: /** 
7:  * @title DynamicTranche - Gestion dynamique des tranches de risque 
8:  * @notice Crée et gère des tranches avec différents niveaux de risque/rendement 
9:  */ 
10: contract DynamicTranche is ERC20, Ownable { 
11:          
12:     enum TrancheType { 
13:         SENIOR,     // Risque faible, rendement faible 
14:         MEZZANINE,  // Risque moyen, rendement moyen 
15:         JUNIOR      // Risque élevé, rendement élevé 
16:     } 
17:      
18:     struct Tranche { 
19:         TrancheType trancheType; 
20:         string name; 
21:         uint256 targetAllocation;   // Allocation cible en % 
22:         uint256 currentAllocation;  // Allocation actuelle 
23:         uint256 minRiskScore;       // Score risque minimum 
24:         uint256 maxRiskScore;       // Score risque maximum 
25:         uint256 yieldMultiplier;    // Multiplicateur de rendement 
26:         uint256 lossAbsorption;     // % d'absorption des pertes 
27:         address trancheToken;       // Token de la tranche 
28:         bool isActive; 
29:     } 
30:      
31:     // Tranches disponibles 
32:     mapping(uint256 => Tranche) public tranches; 
33:     uint256 public trancheCount; 
34:      
35:     // Pool associé 
36:     uint256 public poolId; 
37:     address public loanPool; 
38:      
39:     // Événements 
40:     event TrancheCreated(uint256 indexed trancheId, TrancheType trancheType, string name); 
41:     event InvestmentAllocated(uint256 indexed trancheId, uint256 amount); 
42:     event ReturnsDistributed(uint256 indexed trancheId, uint256 amount); 
43:     event LossesAbsorbed(uint256 indexed trancheId, uint256 amount); 
44:      
45: 	constructor( 
46: 		uint256 _poolId, 
47: 		address _loanPool, 
48: 		string memory name, 
49: 		string memory symbol 
50: 	)  
51: 		ERC20(name, symbol)  
52: 		Ownable(msg.sender)  
53: 	{ 
54: 		poolId = _poolId; 
55: 		loanPool = _loanPool; 
56: 		_createDefaultTranches(); 
57: 	} 
58:      
59:     /** 
60:      * @notice Crée les tranches par défaut 
61:      */ 
62:     function _createDefaultTranches() internal { 
63:         // Tranche Senior (60%) 
64:         _createTranche( 
65:             TrancheType.SENIOR, 
66:             "Senior Tranche", 
67:             6000,   // 60% 
68:             1,      // Risque 1-3 
69:             3, 
70:             80,     // 0.8x rendement 
71:             10      // 10% absorption pertes 
72:         ); 
73:          
74:         // Tranche Mezzanine (30%) 
75:         _createTranche( 
76:             TrancheType.MEZZANINE, 
77:             "Mezzanine Tranche", 
78:             3000,   // 30% 
79:             4,      // Risque 4-6 
80:             6, 
81:             120,    // 1.2x rendement 
82:             30      // 30% absorption pertes 
83:         ); 
84:          
85:         // Tranche Junior (10%) 
86:         _createTranche( 
87:             TrancheType.JUNIOR, 
88:             "Junior Tranche", 
89:             1000,   // 10% 
90:             7,      // Risque 7-10 
91:             10, 
92:             200,    // 2.0x rendement 
93:             60      // 60% absorption pertes 
94:         ); 
95:     } 
96:      
97:     /** 
98:      * @notice Crée une nouvelle tranche 
99:      */ 
100:     function _createTranche( 
101:         TrancheType trancheType, 
102:         string memory name, 
103:         uint256 targetAllocation, 
104:         uint256 minRiskScore, 
105:         uint256 maxRiskScore, 
106:         uint256 yieldMultiplier, 
107:         uint256 lossAbsorption 
108:     ) internal { 
109:         uint256 trancheId = trancheCount++; 
110:          
111:         // Création du token de tranche 
112:         string memory tokenSymbol = string(abi.encodePacked("TRANCHE", Strings.toString(trancheId))); 
113:         address trancheToken = address(new TrancheToken(name, tokenSymbol)); 
114:          
115:         tranches[trancheId] = Tranche({ 
116:             trancheType: trancheType, 
117:             name: name, 
118:             targetAllocation: targetAllocation, 
119:             currentAllocation: 0, 
120:             minRiskScore: minRiskScore, 
121:             maxRiskScore: maxRiskScore, 
122:             yieldMultiplier: yieldMultiplier, 
123:             lossAbsorption: lossAbsorption, 
124:             trancheToken: trancheToken, 
125:             isActive: true 
126:         }); 
127:          
128:         emit TrancheCreated(trancheId, trancheType, name); 
129:     } 
130:      
131:     /** 
132:      * @notice Alloue un investissement aux tranches 
133:      */ 
134:     function allocateInvestment(uint256 amount, uint256 riskScore) external onlyOwner returns (uint256[] memory) { 
135:         require(amount > 0, "Amount must be positive"); 
136:          
137:         uint256[] memory allocations = new uint256[](trancheCount); 
138:         uint256 remaining = amount; 
139:          
140:         // Allocation basée sur les allocations cibles et le risque 
141:         for (uint256 i = 0; i < trancheCount; i++) { 
142:             if (tranches[i].isActive) continue; 
143:              
144:             // Vérifier si la tranche accepte ce niveau de risque 
145:             if (riskScore >= tranches[i].minRiskScore && riskScore <= tranches[i].maxRiskScore) { 
146:                 uint256 allocation = amount * tranches[i].targetAllocation / 10000; 
147:                  
148:                 // Ajustement dynamique basé sur l'allocation actuelle 
149:                 if (tranches[i].currentAllocation > tranches[i].targetAllocation * 110 / 100) { 
150:                     // Sur-allocation, réduire 
151:                     allocation = allocation * 80 / 100; 
152:                 } 
153:                  
154:                 allocations[i] = allocation; 
155:                 tranches[i].currentAllocation += allocation; 
156:                 remaining -= allocation; 
157:                  
158:                 emit InvestmentAllocated(i, allocation); 
159:             } 
160:         } 
161:          
162:         // Redistribuer le reste 
163:         if (remaining > 0) { 
164:             for (uint256 i = 0; i < trancheCount && remaining > 0; i++) { 
165:                 if (allocations[i] > 0) { 
166:                     uint256 extra = remaining * allocations[i] / amount; 
167:                     allocations[i] += extra; 
168:                     tranches[i].currentAllocation += extra; 
169:                     remaining -= extra; 
170:                 } 
171:             } 
172:         } 
173:          
174:         return allocations; 
175:     } 
176:      
177:     /** 
178:      * @notice Distribue les rendements aux tranches 
179:      */ 
180:     function distributeReturns(uint256 totalReturns) external onlyOwner { 
181:         require(totalReturns > 0, "No returns to distribute"); 
182:          
183:         for (uint256 i = 0; i < trancheCount; i++) { 
184:             if (tranches[i].isActive || tranches[i].currentAllocation == 0) continue; 
185:              
186:             // Calcul de la part de la tranche 
187:             uint256 trancheShare = totalReturns * tranches[i].currentAllocation / 10000; 
188:              
189:             // Application du multiplicateur de rendement 
190:             uint256 adjustedReturns = trancheShare * tranches[i].yieldMultiplier / 100; 
191:              
192:             // Distribution aux détenteurs de tokens 
193:             IERC20(tranches[i].trancheToken).transfer(msg.sender, adjustedReturns); 
194:              
195:             emit ReturnsDistributed(i, adjustedReturns); 
196:         } 
197:     } 
198:      
199:     /** 
200:      * @notice Absorbe les pertes selon l'ordre des tranches 
201:      */ 
202:     function absorbLosses(uint256 totalLosses) external onlyOwner returns (uint256 absorbed) { 
203:         require(totalLosses > 0, "No losses to absorb"); 
204:          
205:         uint256 remainingLosses = totalLosses; 
206:          
207:         // Absorption dans l'ordre inverse (Junior d'abord) 
208:         for (uint256 i = trancheCount; i > 0; i--) { 
209:             uint256 trancheId = i - 1; 
210:             Tranche storage tranche = tranches[trancheId]; 
211:              
212:             if (tranche.isActive || tranche.currentAllocation == 0) continue; 
213:              
214:             // Calcul de la capacité d'absorption 
215:             uint256 absorptionCapacity = tranche.currentAllocation * tranche.lossAbsorption / 100; 
216:             uint256 toAbsorb = remainingLosses < absorptionCapacity ? remainingLosses : absorptionCapacity; 
217:              
218:             if (toAbsorb > 0) { 
219:                 tranche.currentAllocation -= toAbsorb; 
220:                 remainingLosses -= toAbsorb; 
221:                 absorbed += toAbsorb; 
222:                  
223:                 // Burn des tokens proportionnellement 
224:                 uint256 burnAmount = toAbsorb * IERC20(tranche.trancheToken).totalSupply() / tranche.currentAllocation; 
225:                 IERC20(tranche.trancheToken).transferFrom(msg.sender, address(this), burnAmount); 
226:                  
227:                 emit LossesAbsorbed(trancheId, toAbsorb); 
228:             } 
229:              
230:             if (remainingLosses == 0) break; 
231:         } 
232:          
233:         return absorbed; 
234:     } 
235:      
236:     /** 
237:      * @notice Récupère les détails de toutes les tranches 
238:      */ 
239:     function getAllTranches() external view returns (Tranche[] memory) { 
240:         Tranche[] memory result = new Tranche[](trancheCount); 
241:          
242:         for (uint256 i = 0; i < trancheCount; i++) { 
243:             result[i] = tranches[i]; 
244:         } 
245:          
246:         return result; 
247:     } 
248:      
249:     /** 
250:      * @notice Vérifie si un score de risque est éligible pour une tranche 
251:      */ 
252:     function isRiskEligible(uint256 trancheId, uint256 riskScore) external view returns (bool) { 
253:         Tranche storage tranche = tranches[trancheId]; 
254:         return riskScore >= tranche.minRiskScore && riskScore <= tranche.maxRiskScore; 
255:     } 
256: } 
257: // Token pour tranche individuelle 
258: contract TrancheToken is ERC20 { 
259:     constructor(string memory name, string memory symbol) ERC20(name, symbol) { 
260:         // Mint initial de 1 million de tokens 
261:         _mint(msg.sender, 1000000 * 10**18); 
262:     } 
263: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: // Imports nécessaires 
4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
5: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
6: import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; 
7: import "@openzeppelin/contracts/access/Ownable.sol"; 
8: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
9: import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; 
10: // Interfaces du protocole 
11: import "../interfaces/IRiskEngine.sol"; 
12: import "../interfaces/ICriteriaFilter.sol"; 
13: import "../interfaces/ISpecialOfferManager.sol"; 
14: import "../interfaces/IInsuranceModule.sol"; 
15: /** 
16:  * @title LoanPool - Contrat principal du protocole de prêt participatif 
17:  * @notice Gère le cycle de vie complet d'un pool de prêt avec fonctionnalités avancées 
18:  * @dev Implémente les mécanismes de taux dynamique, filtrage et intégration assurance 
19:  */ 
20: contract LoanPool is ERC20, Ownable, ReentrancyGuard { 
21:     using SafeERC20 for IERC20; 
22:     using EnumerableSet for EnumerableSet.AddressSet; 
23:     // ============ STRUCTURES ET ÉNUMÉRATIONS ============ 
24:     /** 
25:      * @notice État du pool de prêt 
26:      */ 
27:     enum PoolStatus { 
28:         CREATION,      // En configuration par l'emprunteur 
29:         ACTIVE,        // Ouvert aux investissements 
30:         FUNDED,        // Montant cible atteint, fonds transférés 
31:         ONGOING,       // Prêt en cours de remboursement 
32:         COMPLETED,     // Remboursement intégral effectué 
33:         DEFAULTED,     // Défaut de paiement 
34:         LIQUIDATED,    // Pool liquidé après défaut 
35:         CANCELLED      // Annulé avant financement 
36:     } 
37:     /** 
38:      * @notice Structure principale d'un pool de prêt 
39:      */ 
40:     struct PoolData { 
41:         // Identifiants 
42:         uint256 poolId; 
43:         address borrower; 
44:         string projectName; 
45:         string projectDescription; 
46:         string projectIpfsHash; // Documents légaux sur IPFS 
47:          
48:         // Paramètres financiers 
49:         uint256 targetAmount; 
50:         uint256 collectedAmount; 
51:         uint256 baseInterestRate;     // en points de base (ex: 500 = 5%) 
52:         uint256 dynamicInterestRate;  // taux actuel après ajustements 
53:         uint256 repaymentAmount;      // montant total à rembourser 
54:         uint256 amountRepaid;         // montant déjà remboursé 
55:         uint256 duration;             // durée en jours 
56:         uint256 fundingDeadline;      // date limite de financement 
57:         uint256 startDate;            // date de début du prêt 
58:         uint256 completionDate;       // date de fin du prêt 
59:          
60:         // Critères du projet 
61:         string region; 
62:         bool isEcological; 
63:         string activityDomain; 
64:         uint256 riskScore;            // 1-10 (calculé par RiskEngine) 
65:          
66:         // Gestion des jetons 
67:         uint256 tokenPrice;           // prix par jeton (en stablecoin) 
68:         uint256 totalTokens;          // nombre total de jetons 
69:         uint256 soldTokens;           // jetons déjà vendus 
70:          
71:         // Assurance 
72:         uint256 insuranceCoverage;    // montant couvert par assurance 
73:         uint256 insurancePoolId;      // ID du pool d'assurance 
74:         address insuranceModule;      // adresse du module d'assurance 
75:          
76:         // Offres spéciales 
77:         bool hasSpecialOffer; 
78:         uint256 specialOfferId; 
79:         uint256 specialOfferEndTime; 
80:         uint256 specialOfferBonus;    // bonus de taux en points de base 
81:          
82:         // Statut 
83:         PoolStatus status; 
84:         uint256 createdAt; 
85:         uint256 lastRateUpdate; 
86:     } 
87:     /** 
88:      * @notice Structure pour les investisseurs 
89:      */ 
90:     struct Investor { 
91:         address investorAddress; 
92:         uint256 tokenAmount; 
93:         uint256 investmentAmount; 
94:         uint256 claimedReturns; 
95:         uint256 investmentTime; 
96:     } 
97:     // ============ ÉVÉNEMENTS ============ 
98:     event PoolCreated( 
99:         uint256 indexed poolId, 
100:         address indexed borrower, 
101:         uint256 targetAmount, 
102:         uint256 baseInterestRate 
103:     ); 
104:      
105:     event InvestmentMade( 
106:         uint256 indexed poolId, 
107:         address indexed investor, 
108:         uint256 amount, 
109:         uint256 tokensReceived, 
110:         uint256 dynamicRate 
111:     ); 
112:      
113:     event PoolFunded( 
114:         uint256 indexed poolId, 
115:         uint256 totalCollected, 
116:         uint256 fundedDate 
117:     ); 
118:      
119:     event RepaymentMade( 
120:         uint256 indexed poolId, 
121:         uint256 amount, 
122:         uint256 remainingBalance 
123:     ); 
124:      
125:     event PoolCompleted( 
126:         uint256 indexed poolId, 
127:         uint256 totalReturnsDistributed 
128:     ); 
129:      
130:     event DefaultTriggered( 
131:         uint256 indexed poolId, 
132:         uint256 defaultAmount, 
133:         address triggeredBy 
134:     ); 
135:      
136:     event DynamicRateUpdated( 
137:         uint256 indexed poolId, 
138:         uint256 oldRate, 
139:         uint256 newRate 
140:     ); 
141:     // ============ ÉTAT DU CONTRAT ============ 
142:     // Stablecoin utilisé (USDC, DAI, etc.) 
143:     IERC20 public immutable stablecoin; 
144:      
145:     // Modules externes 
146:     IRiskEngine public riskEngine; 
147:     ICriteriaFilter public criteriaFilter; 
148:     ISpecialOfferManager public specialOfferManager; 
149:      
150:     // Données des pools 
151:     mapping(uint256 => PoolData) public pools; 
152:     mapping(uint256 => Investor[]) public poolInvestors; 
153:     mapping(uint256 => mapping(address => uint256)) public investorIndex; 
154:      
155:     // Compteurs 
156:     uint256 public nextPoolId; 
157:     uint256 public totalPoolsCreated; 
158:     uint256 public totalVolume; 
159:      
160:     // Paramètres du protocole 
161:     uint256 public protocolFee = 50; // 0.5% en points de base 
162:     address public feeCollector; 
163:     uint256 public minInvestment = 100 * 10**18; // 100 stablecoins 
164:     uint256 public maxInvestment = 100000 * 10**18; // 100,000 stablecoins 
165:      
166:     // Sécurité 
167:     bool public emergencyPause; 
168:     mapping(address => bool) public authorizedCreators; 
169:     // ============ MODIFICATEURS ============ 
170:     modifier onlyBorrower(uint256 poolId) { 
171:         require(pools[poolId].borrower == msg.sender, "Not the borrower"); 
172:         _; 
173:     } 
174:     modifier onlyActive(uint256 poolId) { 
175:         require(pools[poolId].status == PoolStatus.ACTIVE, "Pool not active"); 
176:         _; 
177:     } 
178:     modifier onlyFunded(uint256 poolId) { 
179:         require(pools[poolId].status == PoolStatus.FUNDED, "Pool not funded"); 
180:         _; 
181:     } 
182:     modifier onlyOngoing(uint256 poolId) { 
183:         require(pools[poolId].status == PoolStatus.ONGOING, "Pool not ongoing"); 
184:         _; 
185:     } 
186:     modifier notPaused() { 
187:         require(emergencyPause, "Protocol paused"); 
188:         _; 
189:     } 
190:     // ============ CONSTRUCTEUR ============ 
191:     /** 
192:      * @notice Initialise le contrat LoanPool 
193:      * @param _stablecoin Adresse du token stable utilisé (USDC, DAI) 
194:      * @param _riskEngine Adresse du RiskEngine 
195:      * @param _feeCollector Adresse qui reçoit les frais du protocole 
196:      */ 
197:     constructor( 
198: 		address _stablecoin, 
199: 		address _riskEngine, 
200: 		address _feeCollector 
201: 	)  
202: 		ERC20("PoolSync Loan Token", "PSLT")  
203: 		Ownable(msg.sender) 
204: 	{ 
205: 		require(_stablecoin = address(0), "Invalid stablecoin address"); 
206: 		require(_riskEngine = address(0), "Invalid risk engine address"); 
207: 		require(_feeCollector = address(0), "Invalid fee collector"); 
208:      
209: 		stablecoin = IERC20(_stablecoin); 
210: 		riskEngine = IRiskEngine(_riskEngine); 
211: 		feeCollector = _feeCollector; 
212:      
213: 		// Le déployeur est autorisé à créer des pools initialement 
214: 		authorizedCreators[msg.sender] = true; 
215: 	} 
216:     // ============ FONCTIONS PUBLIQUES - CYCLE DE VIE ============ 
217:     /** 
218:      * @notice Crée un nouveau pool de prêt 
219:      * @dev Seuls les créateurs autorisés peuvent créer des pools 
220:      */ 
221:     function createPool( 
222:         string memory _projectName, 
223:         string memory _projectDescription, 
224:         uint256 _targetAmount, 
225:         uint256 _duration, 
226:         string memory _region, 
227:         bool _isEcological, 
228:         string memory _activityDomain, 
229:         string memory _ipfsHash 
230:     ) external notPaused returns (uint256) { 
231:         require(authorizedCreators[msg.sender], "Not authorized to create pools"); 
232:         require(_targetAmount >= 1000 * 10**18, "Target amount too low"); 
233:         require(_targetAmount <= 1000000 * 10**18, "Target amount too high"); 
234:         require(_duration >= 30 days && _duration <= 365 days, "Invalid duration"); 
235:          
236:         uint256 poolId = nextPoolId++; 
237:          
238:         // Calcul du taux de base par le RiskEngine 
239:         uint256 baseRate = riskEngine.calculateBaseRate( 
240:             msg.sender, 
241:             _targetAmount, 
242:             _duration, 
243:             _isEcological, 
244:             _activityDomain 
245:         ); 
246:          
247:         // Calcul du score de risque 
248:         uint256 riskScore = riskEngine.calculateRiskScore( 
249:             msg.sender, 
250:             _targetAmount, 
251:             _duration, 
252:             _region, 
253:             _isEcological, 
254:             _activityDomain 
255:         ); 
256:          
257:         // Initialisation des données du pool 
258:         pools[poolId] = PoolData({ 
259:             poolId: poolId, 
260:             borrower: msg.sender, 
261:             projectName: _projectName, 
262:             projectDescription: _projectDescription, 
263:             projectIpfsHash: _ipfsHash, 
264:             targetAmount: _targetAmount, 
265:             collectedAmount: 0, 
266:             baseInterestRate: baseRate, 
267:             dynamicInterestRate: baseRate, 
268:             repaymentAmount: _targetAmount + (_targetAmount * baseRate / 10000), 
269:             amountRepaid: 0, 
270:             duration: _duration, 
271:             fundingDeadline: block.timestamp + 30 days, // 30 jours pour lever les fonds 
272:             startDate: 0, 
273:             completionDate: 0, 
274:             region: _region, 
275:             isEcological: _isEcological, 
276:             activityDomain: _activityDomain, 
277:             riskScore: riskScore, 
278:             tokenPrice: _targetAmount / 10000, // 10,000 tokens par défaut 
279:             totalTokens: 10000, 
280:             soldTokens: 0, 
281:             insuranceCoverage: 0, 
282:             insurancePoolId: 0, 
283:             insuranceModule: address(0), 
284:             hasSpecialOffer: false, 
285:             specialOfferId: 0, 
286:             specialOfferEndTime: 0, 
287:             specialOfferBonus: 0, 
288:             status: PoolStatus.CREATION, 
289:             createdAt: block.timestamp, 
290:             lastRateUpdate: block.timestamp 
291:         }); 
292:          
293:         totalPoolsCreated++; 
294:          
295:         emit PoolCreated(poolId, msg.sender, _targetAmount, baseRate); 
296:          
297:         return poolId; 
298:     } 
299:     /** 
300:      * @notice Active un pool pour le financement 
301:      * @dev Doit être appelé par l'emprunteur après validation 
302:      */ 
303:     function activatePool(uint256 poolId) external onlyBorrower(poolId) { 
304:         PoolData storage pool = pools[poolId]; 
305:         require(pool.status == PoolStatus.CREATION, "Pool not in creation"); 
306:         require(block.timestamp <= pool.createdAt + 7 days, "Activation period expired"); 
307:          
308:         // Vérification finale par le RiskEngine 
309:         require(riskEngine.validatePool(poolId), "Pool validation failed"); 
310:          
311:         pool.status = PoolStatus.ACTIVE; 
312:         pool.lastRateUpdate = block.timestamp; 
313:          
314:         // Vérification des offres spéciales actives 
315:         _checkSpecialOffers(poolId); 
316:     } 
317:     /** 
318:      * @notice Investit dans un pool actif 
319:      * @dev Le taux d'intérêt est mis à jour dynamiquement avant l'investissement 
320:      */ 
321:     function invest(uint256 poolId, uint256 amount) external nonReentrant notPaused onlyActive(poolId) { 
322:         PoolData storage pool = pools[poolId]; 
323:          
324:         require(amount >= minInvestment, "Investment below minimum"); 
325:         require(amount <= maxInvestment, "Investment above maximum"); 
326:         require(block.timestamp <= pool.fundingDeadline, "Funding period ended"); 
327:         require(pool.collectedAmount + amount <= pool.targetAmount, "Exceeds target amount"); 
328:          
329:         // Mise à jour du taux dynamique 
330:         _updateDynamicRate(poolId); 
331:          
332:         // Calcul des tokens à allouer 
333:         uint256 tokensToMint = (amount * 10**18) / pool.tokenPrice; 
334:         require(tokensToMint > 0, "Token amount too small"); 
335:          
336:         // Transfert des fonds 
337:         stablecoin.safeTransferFrom(msg.sender, address(this), amount); 
338:          
339:         // Mise à jour des compteurs 
340:         pool.collectedAmount += amount; 
341:         pool.soldTokens += tokensToMint; 
342:          
343:         // Enregistrement de l'investisseur 
344:         uint256 investorIndexId = poolInvestors[poolId].length; 
345:         poolInvestors[poolId].push(Investor({ 
346:             investorAddress: msg.sender, 
347:             tokenAmount: tokensToMint, 
348:             investmentAmount: amount, 
349:             claimedReturns: 0, 
350:             investmentTime: block.timestamp 
351:         })); 
352:         investorIndex[poolId][msg.sender] = investorIndexId; 
353:          
354:         // Mint des tokens de pool 
355:         _mint(msg.sender, tokensToMint); 
356:          
357:         // Application des frais de protocole 
358:         uint256 fee = amount * protocolFee / 10000; 
359:         if (fee > 0) { 
360:             stablecoin.safeTransfer(feeCollector, fee); 
361:         } 
362:          
363:         emit InvestmentMade(poolId, msg.sender, amount, tokensToMint, pool.dynamicInterestRate); 
364:          
365:         // Vérification si le pool est entièrement financé 
366:         if (pool.collectedAmount >= pool.targetAmount) { 
367:             _finalizeFunding(poolId); 
368:         } 
369:     } 
370:     /** 
371:      * @notice Finalise le financement et transfère les fonds à l'emprunteur 
372:      * @dev Appelé automatiquement lorsque le montant cible est atteint 
373:      */ 
374:     function _finalizeFunding(uint256 poolId) internal { 
375:         PoolData storage pool = pools[poolId]; 
376:          
377:         pool.status = PoolStatus.FUNDED; 
378:         pool.startDate = block.timestamp; 
379:          
380:         // Calcul du montant net après frais 
381:         uint256 totalFees = pool.collectedAmount * protocolFee / 10000; 
382:         uint256 netAmount = pool.collectedAmount - totalFees; 
383:          
384:         // Transfert à l'emprunteur 
385:         stablecoin.safeTransfer(pool.borrower, netAmount); 
386:          
387:         // Démarrage de la période de remboursement 
388:         pool.status = PoolStatus.ONGOING; 
389:          
390:         totalVolume += pool.collectedAmount; 
391:          
392:         emit PoolFunded(poolId, pool.collectedAmount, block.timestamp); 
393:     } 
394:     /** 
395:      * @notice Permet à l'emprunteur d'effectuer un remboursement 
396:      */ 
397:     function repay(uint256 poolId, uint256 amount) external nonReentrant onlyBorrower(poolId) onlyOngoing(poolId) { 
398:         PoolData storage pool = pools[poolId]; 
399:          
400:         require(amount > 0, "Repayment amount must be positive"); 
401:         require(pool.amountRepaid + amount <= pool.repaymentAmount, "Overpayment"); 
402:          
403:         // Transfert des fonds de remboursement 
404:         stablecoin.safeTransferFrom(msg.sender, address(this), amount); 
405:          
406:         pool.amountRepaid += amount; 
407:          
408:         // Distribution des intérêts aux investisseurs 
409:         _distributeReturns(poolId, amount); 
410:          
411:         emit RepaymentMade(poolId, amount, pool.repaymentAmount - pool.amountRepaid); 
412:          
413:         // Vérification si le prêt est entièrement remboursé 
414:         if (pool.amountRepaid >= pool.repaymentAmount) { 
415:             _completePool(poolId); 
416:         } 
417:     } 
418:     /** 
419:      * @notice Distribution des rendements aux investisseurs 
420:      */ 
421:     function _distributeReturns(uint256 poolId, uint256 repaymentAmount) internal { 
422:         PoolData storage pool = pools[poolId]; 
423:         Investor[] storage investors = poolInvestors[poolId]; 
424:          
425:         // Calcul de la part des intérêts dans ce remboursement 
426:         uint256 principalPortion = repaymentAmount * pool.targetAmount / pool.repaymentAmount; 
427:         uint256 interestPortion = repaymentAmount - principalPortion; 
428:          
429:         if (interestPortion == 0) return; 
430:          
431:         // Distribution proportionnelle aux tokens détenus 
432:         for (uint256 i = 0; i < investors.length; i++) { 
433:             Investor storage investor = investors[i]; 
434:              
435:             // Calcul de la part de l'investisseur dans les intérêts 
436:             uint256 investorShare = interestPortion * investor.tokenAmount / pool.soldTokens; 
437:              
438:             if (investorShare > 0) { 
439:                 investor.claimedReturns += investorShare; 
440:                  
441:                 // Transfert des intérêts à l'investisseur 
442:                 stablecoin.safeTransfer(investor.investorAddress, investorShare); 
443:             } 
444:         } 
445:     } 
446:     /** 
447:      * @notice Marque le pool comme complété 
448:      */ 
449:     function _completePool(uint256 poolId) internal { 
450:         PoolData storage pool = pools[poolId]; 
451:          
452:         pool.status = PoolStatus.COMPLETED; 
453:         pool.completionDate = block.timestamp; 
454:          
455:         // Brûlage des tokens restants 
456:         _burn(address(this), balanceOf(address(this))); 
457:          
458:         emit PoolCompleted(poolId, pool.amountRepaid - pool.targetAmount); 
459:     } 
460:     /** 
461:      * @notice Déclenche un défaut de paiement 
462:      * @dev Peut être appelé après expiration de la période de grâce 
463:      */ 
464:     function triggerDefault(uint256 poolId) external onlyOngoing(poolId) { 
465:         PoolData storage pool = pools[poolId]; 
466:          
467:         require(block.timestamp > pool.startDate + pool.duration + 30 days, "Grace period not expired"); 
468:         require(pool.amountRepaid < pool.repaymentAmount, "Loan already repaid"); 
469:          
470:         pool.status = PoolStatus.DEFAULTED; 
471:          
472:         // Déclenchement de la procédure d'assurance si existante 
473:         if (pool.insuranceModule = address(0)) { 
474:             IInsuranceModule(pool.insuranceModule).fileClaim(poolId, pool.repaymentAmount - pool.amountRepaid); 
475:         } 
476:          
477:         emit DefaultTriggered(poolId, pool.repaymentAmount - pool.amountRepaid, msg.sender); 
478:     } 
479:     // ============ FONCTIONS DE TAUX DYNAMIQUE ============ 
480:     /** 
481:      * @notice Met à jour le taux d'intérêt dynamique du pool 
482:      */ 
483:     function _updateDynamicRate(uint256 poolId) internal { 
484:         PoolData storage pool = pools[poolId]; 
485:          
486:         // Vérification de la fréquence de mise à jour (max 1 fois par heure) 
487:         if (block.timestamp < pool.lastRateUpdate + 1 hours) { 
488:             return; 
489:         } 
490:          
491:         uint256 oldRate = pool.dynamicInterestRate; 
492:         uint256 newRate = _calculateDynamicRate(poolId); 
493:          
494:         if (newRate = oldRate) { 
495:             pool.dynamicInterestRate = newRate; 
496:             pool.lastRateUpdate = block.timestamp; 
497:              
498:             emit DynamicRateUpdated(poolId, oldRate, newRate); 
499:         } 
500:     } 
501:     /** 
502:      * @notice Calcule le taux d'intérêt dynamique 
503:      */ 
504:     function _calculateDynamicRate(uint256 poolId) internal view returns (uint256) { 
505:         PoolData storage pool = pools[poolId]; 
506:          
507:         uint256 rate = pool.baseInterestRate; 
508:          
509:         // 1. Facteur d'attrait (taux de remplissage) 
510:         uint256 fillRate = (pool.soldTokens * 10000) / pool.totalTokens; // en points de base 
511:          
512:         if (fillRate > 8000) { // > 80% 
513:             // Très populaire - réduction de taux 
514:             rate = rate * 80 / 100; // -20% 
515:         } else if (fillRate < 3000) { // < 30% 
516:             // Peu populaire - augmentation de taux 
517:             rate = rate * 130 / 100; // +30% 
518:         } 
519:          
520:         // 2. Facteur temporel 
521:         uint256 timeElapsed = block.timestamp - pool.createdAt; 
522:         uint256 fundingPeriod = pool.fundingDeadline - pool.createdAt; 
523:          
524:         if (timeElapsed > fundingPeriod / 2) { 
525:             // Après la moitié de la période de financement 
526:             rate = rate * 110 / 100; // +10% 
527:         } 
528:          
529:         // 3. Facteur offre spéciale 
530:         if (pool.hasSpecialOffer && block.timestamp <= pool.specialOfferEndTime) { 
531:             rate = rate + pool.specialOfferBonus; 
532:         } 
533:          
534:         // 4. Ajustement par le RiskEngine 
535:         rate = riskEngine.adjustRateForMarketConditions(poolId, rate); 
536:          
537:         // 5. Limites de sécurité 
538:         uint256 minRate = pool.baseInterestRate * 50 / 100; // -50% minimum 
539:         uint256 maxRate = pool.baseInterestRate * 200 / 100; // +100% maximum 
540:          
541:         if (rate < minRate) rate = minRate; 
542:         if (rate > maxRate) rate = maxRate; 
543:          
544:         return rate; 
545:     } 
546:     /** 
547:      * @notice Récupère le taux dynamique actuel (vue) 
548:      */ 
549:     function getDynamicRate(uint256 poolId) external view returns (uint256) { 
550:         require(pools[poolId].status = PoolStatus.CREATION, "Pool not active"); 
551:         return _calculateDynamicRate(poolId); 
552:     } 
553:     // ============ FONCTIONS D'OFFRES SPÉCIALES ============ 
554:     /** 
555:      * @notice Vérifie et applique les offres spéciales disponibles 
556:      */ 
557:     function _checkSpecialOffers(uint256 poolId) internal { 
558:         if (address(specialOfferManager) = address(0)) { 
559:             (bool hasOffer, uint256 offerId, uint256 bonus, uint256 endTime) =  
560:                 specialOfferManager.getActiveOfferForPool(poolId); 
561:              
562:             if (hasOffer) { 
563:                 PoolData storage pool = pools[poolId]; 
564:                 pool.hasSpecialOffer = true; 
565:                 pool.specialOfferId = offerId; 
566:                 pool.specialOfferBonus = bonus; 
567:                 pool.specialOfferEndTime = endTime; 
568:                  
569:                 // Mise à jour immédiate du taux 
570:                 _updateDynamicRate(poolId); 
571:             } 
572:         } 
573:     } 
574:     /** 
575:      * @notice Applique une offre spéciale manuellement 
576:      */ 
577:     function applySpecialOffer(uint256 poolId, uint256 offerId) external onlyActive(poolId) { 
578:         require(address(specialOfferManager) = address(0), "Special offer manager not set"); 
579:         require(msg.sender == address(specialOfferManager) || msg.sender == owner(), "Not authorized"); 
580:          
581:         PoolData storage pool = pools[poolId]; 
582:          
583:         pool.hasSpecialOffer = true; 
584:         pool.specialOfferId = offerId; 
585:         (pool.specialOfferBonus, pool.specialOfferEndTime) = specialOfferManager.getOfferDetails(offerId); 
586:          
587:         _updateDynamicRate(poolId); 
588:     } 
589:     // ============ FONCTIONS D'ASSURANCE ============ 
590:     /** 
591:      * @notice Souscrit une assurance pour le pool 
592:      */ 
593:     function subscribeInsurance( 
594:         uint256 poolId, 
595:         address insuranceModule, 
596:         uint256 coverageAmount, 
597:         uint256 insurancePoolId 
598:     ) external onlyBorrower(poolId) onlyActive(poolId) { 
599:         require(insuranceModule = address(0), "Invalid insurance module"); 
600:         require(coverageAmount <= pools[poolId].targetAmount, "Coverage exceeds loan amount"); 
601:          
602:         PoolData storage pool = pools[poolId]; 
603:         pool.insuranceModule = insuranceModule; 
604:         pool.insuranceCoverage = coverageAmount; 
605:         pool.insurancePoolId = insurancePoolId; 
606:          
607:         // Appel au module d'assurance pour souscrire 
608:         IInsuranceModule(insuranceModule).subscribeCoverage( 
609:             poolId, 
610:             coverageAmount, 
611:             insurancePoolId 
612:         ); 
613:     } 
614:     // ============ FONCTIONS ADMINISTRATIVES ============ 
615:     /** 
616:      * @notice Configure les modules externes 
617:      */ 
618:     function setExternalModules( 
619:         address _riskEngine, 
620:         address _criteriaFilter, 
621:         address _specialOfferManager 
622:     ) external onlyOwner { 
623:         if (_riskEngine = address(0)) { 
624:             riskEngine = IRiskEngine(_riskEngine); 
625:         } 
626:         if (_criteriaFilter = address(0)) { 
627:             criteriaFilter = ICriteriaFilter(_criteriaFilter); 
628:         } 
629:         if (_specialOfferManager = address(0)) { 
630:             specialOfferManager = ISpecialOfferManager(_specialOfferManager); 
631:         } 
632:     } 
633:     /** 
634:      * @notice Active/désactive le mode pause d'urgence 
635:      */ 
636:     function setEmergencyPause(bool paused) external onlyOwner { 
637:         emergencyPause = paused; 
638:     } 
639:     /** 
640:      * @notice Autorise un nouveau créateur de pools 
641:      */ 
642:     function authorizeCreator(address creator, bool authorized) external onlyOwner { 
643:         authorizedCreators[creator] = authorized; 
644:     } 
645:     /** 
646:      * @notice Met à jour les paramètres du protocole 
647:      */ 
648:     function updateProtocolParameters( 
649:         uint256 _protocolFee, 
650:         uint256 _minInvestment, 
651:         uint256 _maxInvestment, 
652:         address _feeCollector 
653:     ) external onlyOwner { 
654:         require(_protocolFee <= 200, "Protocol fee too high"); // Max 2% 
655:         require(_minInvestment > 0, "Min investment must be positive"); 
656:         require(_minInvestment < _maxInvestment, "Min must be less than max"); 
657:         require(_feeCollector = address(0), "Invalid fee collector"); 
658:          
659:         protocolFee = _protocolFee; 
660:         minInvestment = _minInvestment; 
661:         maxInvestment = _maxInvestment; 
662:         feeCollector = _feeCollector; 
663:     } 
664:     // ============ FONCTIONS DE REQUÊTE ============ 
665:     /** 
666:      * @notice Récupère les détails complets d'un pool 
667:      */ 
668:     function getPoolDetails(uint256 poolId) external view returns (PoolData memory) { 
669:         return pools[poolId]; 
670:     } 
671:     /** 
672:      * @notice Récupère la liste des investisseurs d'un pool 
673:      */ 
674:     function getPoolInvestors(uint256 poolId) external view returns (Investor[] memory) { 
675:         return poolInvestors[poolId]; 
676:     } 
677:     /** 
678:      * @notice Récupère les pools correspondant aux critères 
679:      */ 
680:     function getFilteredPools( 
681:         string[] memory regions, 
682:         bool ecologicalOnly, 
683:         string[] memory domains, 
684:         uint256 minRate, 
685:         uint256 maxRisk 
686:     ) external view returns (uint256[] memory) { 
687:         require(address(criteriaFilter) = address(0), "Criteria filter not set"); 
688:          
689:         return criteriaFilter.filterPools( 
690:             regions, 
691:             ecologicalOnly, 
692:             domains, 
693:             minRate, 
694:             maxRisk 
695:         ); 
696:     } 
697:     /** 
698:      * @notice Calcule les rendements potentiels pour un investissement 
699:      */ 
700:     function calculatePotentialReturns( 
701:         uint256 poolId, 
702:         uint256 investmentAmount 
703:     ) external view returns (uint256 estimatedReturns, uint256 tokensToReceive) { 
704:         PoolData storage pool = pools[poolId]; 
705:         require(pool.status == PoolStatus.ACTIVE, "Pool not active"); 
706:          
707:         tokensToReceive = (investmentAmount * 10**18) / pool.tokenPrice; 
708:         uint256 poolShare = (tokensToReceive * 10000) / pool.totalTokens; 
709:          
710:         // Estimation basée sur le taux dynamique actuel 
711:         uint256 totalInterest = pool.targetAmount * pool.dynamicInterestRate / 10000; 
712:         estimatedReturns = totalInterest * poolShare / 10000; 
713:          
714:         return (estimatedReturns, tokensToReceive); 
715:     } 
716:     // ============ FONCTIONS DE SECOURS ============ 
717:     /** 
718:      * @notice Permet aux investisseurs de récupérer leurs fonds si le pool est annulé 
719:      */ 
720:     function withdrawIfCancelled(uint256 poolId) external nonReentrant { 
721:         PoolData storage pool = pools[poolId]; 
722:         require(pool.status == PoolStatus.CANCELLED, "Pool not cancelled"); 
723:          
724:         uint256 index = investorIndex[poolId][msg.sender]; 
725:         require(index < poolInvestors[poolId].length, "Not an investor"); 
726:          
727:         Investor storage investor = poolInvestors[poolId][index]; 
728:         require(investor.investmentAmount > 0, "Already withdrawn"); 
729:          
730:         // Transfert du capital investi 
731:         uint256 refundAmount = investor.investmentAmount; 
732:         investor.investmentAmount = 0; 
733:          
734:         // Brûlage des tokens 
735:         _burn(msg.sender, investor.tokenAmount); 
736:          
737:         stablecoin.safeTransfer(msg.sender, refundAmount); 
738:     } 
739: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/Ownable.sol"; 
4: import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol"; 
5: /** 
6:  * @title RiskEngine - Moteur de calcul des risques et taux dynamiques 
7:  * @notice Calcule les scores de risque et ajuste les taux en temps réel 
8:  */ 
9: contract RiskEngine is Ownable { 
10:      
11:     struct RiskParameters { 
12:         uint256 baseRateMultiplier;      // Multiplicateur de taux de base 
13:         uint256 ecologicalBonus;          // Bonus pour projets écologiques 
14:         uint256 regionRiskModifier;       // Modificateur par région 
15:         uint256 sectorRiskModifier;       // Modificateur par secteur 
16:         uint256 amountRiskModifier;       // Modificateur par montant 
17:         uint256 durationRiskModifier;     // Modificateur par durée 
18:     } 
19:      
20:     struct MarketConditions { 
21:         uint256 overallDemand;           // Demande globale (0-100) 
22:         uint256 sectorDemand;            // Demande par secteur (0-100) 
23:         uint256 defaultRate;             // Taux de défaut historique 
24:         uint256 lastUpdate; 
25:     } 
26:      
27:     // Données de risque par emprunteur 
28:     struct BorrowerProfile { 
29:         uint256 creditScore;             // Score de crédit (1-1000) 
30:         uint256 totalBorrowed;           // Montant total emprunté 
31:         uint256 activeLoans;             // Prêts actifs 
32:         uint256 defaultCount;            // Nombre de défauts 
33:         uint256 reputationScore;         // Score de réputation (1-100) 
34:     } 
35:      
36:     // Mappings 
37:     mapping(address => BorrowerProfile) public borrowerProfiles; 
38:     mapping(string => uint256) public regionRiskScores;      // Ex: "Europe" = 300 
39:     mapping(string => uint256) public sectorRiskScores;      // Ex: "Renewable" = 250 
40:     mapping(string => MarketConditions) public sectorConditions; 
41:      
42:     // Oracles Chainlink 
43:     AggregatorV3Interface internal creditScoreOracle; 
44:     AggregatorV3Interface internal marketDataOracle; 
45:      
46:     // Paramètres configurables 
47:     RiskParameters public riskParams; 
48:     uint256 public constant BASIS_POINTS = 10000; 
49:     uint256 public minBaseRate = 300;    // 3% minimum 
50:     uint256 public maxBaseRate = 1500;   // 15% maximum 
51:      
52:     // Événements 
53:     event RiskScoreCalculated(address indexed borrower, uint256 score); 
54:     event BaseRateCalculated(uint256 poolId, uint256 rate); 
55:     event MarketConditionsUpdated(uint256 timestamp); 
56:      
57: 	constructor(address _creditOracle, address _marketOracle) Ownable(msg.sender) { 
58: 		creditScoreOracle = AggregatorV3Interface(_creditOracle); 
59: 		marketDataOracle = AggregatorV3Interface(_marketOracle); 
60:      
61: 		// Initialisation des paramètres par défaut 
62: 		riskParams = RiskParameters({ 
63: 			baseRateMultiplier: 10000,   // 1.0x 
64: 			ecologicalBonus: 200,        // -2% pour projets écologiques 
65: 			regionRiskModifier: 5000,    // 50% de poids 
66: 			sectorRiskModifier: 3000,    // 30% de poids 
67: 			amountRiskModifier: 1000,    // 10% de poids 
68: 			durationRiskModifier: 1000   // 10% de poids 
69: 		}); 
70:      
71: 		// Initialisation des scores de région 
72: 		regionRiskScores["Europe"] = 300; 
73: 		regionRiskScores["North America"] = 350; 
74: 		regionRiskScores["Asia"] = 450; 
75: 		regionRiskScores["Africa"] = 600; 
76: 		regionRiskScores["South America"] = 550; 
77:      
78: 		// Initialisation des scores de secteur 
79: 		sectorRiskScores["Renewable Energy"] = 250; 
80: 		sectorRiskScores["Technology"] = 350; 
81: 		sectorRiskScores["Agriculture"] = 400; 
82: 		sectorRiskScores["Real Estate"] = 450; 
83: 		sectorRiskScores["Manufacturing"] = 500; 
84: 	} 
85:      
86:     /** 
87:      * @notice Calcule le taux de base pour un prêt 
88:      */ 
89:     function calculateBaseRate( 
90:         address borrower, 
91:         uint256 amount, 
92:         uint256 duration, 
93:         bool isEcological, 
94:         string calldata activityDomain 
95:     ) external returns (uint256) { 
96:         // 1. Score de crédit de l'emprunteur 
97:         uint256 creditScore = _getCreditScore(borrower); 
98:          
99:         // 2. Score de risque du projet 
100:         uint256 projectRisk = _calculateProjectRisk( 
101:             amount, 
102:             duration, 
103:             isEcological, 
104:             activityDomain 
105:         ); 
106:          
107:         // 3. Taux de base = Base + Risque projet - Score crédit 
108:         uint256 baseRate = 500; // 5% de base 
109:          
110:         // Ajustement par risque projet 
111:         baseRate = baseRate * projectRisk / BASIS_POINTS; 
112:          
113:         // Ajustement par score de crédit 
114:         if (creditScore > 700) { 
115:             baseRate = baseRate * 80 / 100; // -20% pour bon crédit 
116:         } else if (creditScore < 400) { 
117:             baseRate = baseRate * 130 / 100; // +30% pour mauvais crédit 
118:         } 
119:          
120:         // Bonus écologique 
121:         if (isEcological) { 
122:             baseRate = baseRate - riskParams.ecologicalBonus; 
123:             if (baseRate < minBaseRate) baseRate = minBaseRate; 
124:         } 
125:          
126:         // Ajustement aux conditions de marché 
127:         baseRate = _adjustForMarketConditions(baseRate, activityDomain); 
128:          
129:         // Limites 
130:         if (baseRate < minBaseRate) baseRate = minBaseRate; 
131:         if (baseRate > maxBaseRate) baseRate = maxBaseRate; 
132:          
133:         return baseRate; 
134:     } 
135:      
136:     /** 
137:      * @notice Calcule le score de risque (1-10) 
138:      */ 
139:     function calculateRiskScore( 
140:         address borrower, 
141:         uint256 amount, 
142:         uint256 duration, 
143:         string calldata region, 
144:         bool isEcological, 
145:         string calldata activityDomain 
146:     ) external returns (uint256) { 
147:         uint256 score = 5; // Score moyen de départ 
148:          
149:         // Facteur région (30%) 
150:         uint256 regionScore = regionRiskScores[region]; 
151:         if (regionScore == 0) regionScore = 500; // Défaut 
152:         score = score * 70 / 100 + (regionScore / 100) * 30 / 100; 
153:          
154:         // Facteur secteur (25%) 
155:         uint256 sectorScore = sectorRiskScores[activityDomain]; 
156:         if (sectorScore == 0) sectorScore = 500; 
157:         score = score * 75 / 100 + (sectorScore / 100) * 25 / 100; 
158:          
159:         // Facteur montant (20%) 
160:         if (amount > 500000 * 10**18) { 
161:             score = score + 2; // Gros montant = risque +2 
162:         } else if (amount < 10000 * 10**18) { 
163:             score = score - 1; // Petit montant = risque -1 
164:         } 
165:          
166:         // Facteur durée (15%) 
167:         if (duration > 180 days) { 
168:             score = score + 1; // Longue durée = risque +1 
169:         } 
170:          
171:         // Bonus écologique (-10%) 
172:         if (isEcological) { 
173:             score = score - 1; 
174:         } 
175:          
176:         // Score de crédit emprunteur (10%) 
177:         uint256 creditScore = _getCreditScore(borrower); 
178:         if (creditScore < 400) { 
179:             score = score + 2; 
180:         } else if (creditScore > 700) { 
181:             score = score - 1; 
182:         } 
183:          
184:         // Limites 1-10 
185:         if (score < 1) score = 1; 
186:         if (score > 10) score = 10; 
187:          
188:         emit RiskScoreCalculated(borrower, score); 
189:         return score; 
190:     } 
191:      
192:     /** 
193:      * @notice Valide un pool de prêt 
194:      */ 
195:     function validatePool(uint256 poolId) external view returns (bool) { 
196:         // Pour l'instant, validation simple 
197:         // À étendre avec des règles métier complexes 
198:         return true; 
199:     } 
200:      
201:     /** 
202:      * @notice Ajuste le taux selon les conditions de marché 
203:      */ 
204:     function adjustRateForMarketConditions( 
205:         uint256 poolId, 
206:         uint256 currentRate 
207:     ) external view returns (uint256) { 
208:         // Récupération des conditions de marché 
209:         MarketConditions memory conditions = sectorConditions["global"]; 
210:          
211:         // Ajustement selon la demande 
212:         if (conditions.overallDemand > 80) { 
213:             // Forte demande = réduction de taux 
214:             return currentRate * 90 / 100; // -10% 
215:         } else if (conditions.overallDemand < 30) { 
216:             // Faible demande = augmentation de taux 
217:             return currentRate * 115 / 100; // +15% 
218:         } 
219:          
220:         return currentRate; 
221:     } 
222:      
223:     // ============ FONCTIONS INTERNES ============ 
224:      
225:     function _calculateProjectRisk( 
226:         uint256 amount, 
227:         uint256 duration, 
228:         bool isEcological, 
229:         string memory activityDomain 
230:     ) internal view returns (uint256) { 
231:         uint256 risk = BASIS_POINTS; // 1.0x de base 
232:          
233:         // Risque montant (échelle logarithmique) 
234:         if (amount > 1000000 * 10**18) risk = risk * 120 / 100; 
235:         else if (amount > 100000 * 10**18) risk = risk * 110 / 100; 
236:          
237:         // Risque durée 
238:         if (duration > 365 days) risk = risk * 115 / 100; 
239:         else if (duration > 180 days) risk = risk * 105 / 100; 
240:          
241:         // Risque secteur 
242:         uint256 sectorRisk = sectorRiskScores[activityDomain]; 
243:         if (sectorRisk > 0) { 
244:             risk = risk * sectorRisk / BASIS_POINTS; 
245:         } 
246:          
247:         // Réduction risque écologique 
248:         if (isEcological) { 
249:             risk = risk * 90 / 100; // -10% 
250:         } 
251:          
252:         return risk; 
253:     } 
254:      
255:     function _getCreditScore(address borrower) internal returns (uint256) { 
256:         // D'abord, vérifier si on a un profil local 
257:         if (borrowerProfiles[borrower].creditScore > 0) { 
258:             return borrowerProfiles[borrower].creditScore; 
259:         } 
260:          
261:         // Sinon, requête à l'oracle Chainlink 
262:         try creditScoreOracle.latestRoundData() returns ( 
263:             uint80 /* roundId */, 
264:             int256 score, 
265:             uint256 /* startedAt */, 
266:             uint256 /* updatedAt */, 
267:             uint80 /* answeredInRound */ 
268:         ) { 
269:             uint256 oracleScore = uint256(score); 
270:             if (oracleScore > 0 && oracleScore <= 1000) { 
271:                 borrowerProfiles[borrower].creditScore = oracleScore; 
272:                 return oracleScore; 
273:             } 
274:         } catch { 
275:             // Fallback: score par défaut 
276:         } 
277:          
278:         return 500; // Score moyen par défaut 
279:     } 
280:      
281:     function _adjustForMarketConditions(uint256 rate, string memory sector) internal view returns (uint256) { 
282:         MarketConditions memory conditions = sectorConditions[sector]; 
283:         if (conditions.overallDemand == 0) { 
284:             conditions = sectorConditions["global"]; 
285:         } 
286:          
287:         if (conditions.overallDemand > 80) { 
288:             return rate * 90 / 100; // -10% si forte demande 
289:         } else if (conditions.overallDemand < 30) { 
290:             return rate * 115 / 100; // +15% si faible demande 
291:         } 
292:          
293:         return rate; 
294:     } 
295:      
296:     // ============ FONCTIONS ADMIN ============ 
297:      
298:     function updateRiskParameters( 
299:         uint256 baseRateMultiplier, 
300:         uint256 ecologicalBonus, 
301:         uint256 regionRiskModifier, 
302:         uint256 sectorRiskModifier, 
303:         uint256 amountRiskModifier, 
304:         uint256 durationRiskModifier 
305:     ) external onlyOwner { 
306:         riskParams = RiskParameters({ 
307:             baseRateMultiplier: baseRateMultiplier, 
308:             ecologicalBonus: ecologicalBonus, 
309:             regionRiskModifier: regionRiskModifier, 
310:             sectorRiskModifier: sectorRiskModifier, 
311:             amountRiskModifier: amountRiskModifier, 
312:             durationRiskModifier: durationRiskModifier 
313:         }); 
314:     } 
315:      
316:     function updateRegionRisk(string calldata region, uint256 score) external onlyOwner { 
317:         require(score > 0 && score <= 1000, "Invalid score"); 
318:         regionRiskScores[region] = score; 
319:     } 
320:      
321:     function updateSectorRisk(string calldata sector, uint256 score) external onlyOwner { 
322:         require(score > 0 && score <= 1000, "Invalid score"); 
323:         sectorRiskScores[sector] = score; 
324:     } 
325:      
326:     function updateMarketConditions( 
327:         string calldata sector, 
328:         uint256 overallDemand, 
329:         uint256 sectorDemand, 
330:         uint256 defaultRate 
331:     ) external onlyOwner { 
332:         sectorConditions[sector] = MarketConditions({ 
333:             overallDemand: overallDemand, 
334:             sectorDemand: sectorDemand, 
335:             defaultRate: defaultRate, 
336:             lastUpdate: block.timestamp 
337:         }); 
338:          
339:         emit MarketConditionsUpdated(block.timestamp); 
340:     } 
341:      
342:     function setCreditOracle(address oracle) external onlyOwner { 
343:         creditScoreOracle = AggregatorV3Interface(oracle); 
344:     } 
345:      
346:     function setMarketOracle(address oracle) external onlyOwner { 
347:         marketDataOracle = AggregatorV3Interface(oracle); 
348:     } 
349: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
4: import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol"; 
5: import "@openzeppelin/contracts/access/AccessControl.sol"; 
6: import "@openzeppelin/contracts/governance/Governor.sol"; 
7: import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol"; 
8: import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol"; 
9: import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol"; 
10: import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol"; 
11: import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol"; 
12: import "./ReputationToken.sol"; 
13: contract GovernanceDAO is  
14:     Governor,  
15:     GovernorSettings, 
16:     GovernorCountingSimple, 
17:     GovernorVotes, 
18:     GovernorVotesQuorumFraction, 
19:     GovernorTimelockControl, 
20:     AccessControl 
21: { 
22:     // Structure de proposition enrichie 
23:     struct EnhancedProposal { 
24:         uint256 proposalId; 
25:         address proposer; 
26:         string title; 
27:         string description; 
28:         ProposalCategory category; 
29:         uint256 createdTime; 
30:         uint256 votingEndTime; 
31:         ProposalStatus status; 
32:         bytes[] calldatas; 
33:         address[] targets; 
34:         uint256 forVotes; 
35:         uint256 againstVotes; 
36:         uint256 abstainVotes; 
37:         uint256 executionTime; 
38:         string ipfsMetadata; 
39:     } 
40:      
41:     // Catégories de propositions 
42:     enum ProposalCategory { 
43:         PARAMETER_CHANGE,     // Changement de paramètres 
44:         TREASURY_MANAGEMENT,  // Gestion de trésorerie 
45:         CONTRACT_UPGRADE,     // Mise à jour de contrat 
46:         EMERGENCY_ACTION,     // Action d'urgence 
47:         COMMUNITY_GRANT,      // Subvention communautaire 
48:         RISK_MANAGEMENT,      // Gestion des risques 
49:         INSURANCE_POLICY,     // Politique d'assurance 
50:         FEE_STRUCTURE         // Structure de frais 
51:     } 
52:      
53:     // Statuts étendus 
54:     enum ProposalStatus { 
55:         PENDING, 
56:         ACTIVE, 
57:         CANCELED, 
58:         DEFEATED, 
59:         SUCCEEDED, 
60:         QUEUED, 
61:         EXECUTED, 
62:         EXPIRED 
63:     } 
64:      
65:     // Structures de délégation 
66:     struct Delegation { 
67:         address delegatee; 
68:         uint256 amount; 
69:         uint256 timestamp; 
70:     } 
71:      
72:     // Variables d'état 
73:     mapping(uint256 => EnhancedProposal) public enhancedProposals; 
74:     mapping(address => Delegation[]) public delegationHistory; 
75:     mapping(address => uint256) public reputationScores; 
76:      
77:     uint256 public proposalCount; 
78:     uint256 public minimumReputation = 100; 
79:     uint256 public proposalDeposit = 100 * 1e18; // 100 tokens 
80:      
81:     // Token de réputation 
82:     ReputationToken public reputationToken; 
83:      
84:     // Événements 
85:     event ProposalCreated( 
86:         uint256 indexed proposalId, 
87:         address indexed proposer, 
88:         string title, 
89:         ProposalCategory category, 
90:         uint256 timestamp 
91:     ); 
92:      
93:     event VoteCast( 
94:         uint256 indexed proposalId, 
95:         address indexed voter, 
96:         uint256 votes, 
97:         uint256 reputationWeight, 
98:         string support, 
99:         uint256 timestamp 
100:     ); 
101:      
102:     event ProposalExecuted( 
103:         uint256 indexed proposalId, 
104:         address indexed executor, 
105:         uint256 timestamp 
106:     ); 
107:      
108:     event ReputationAwarded( 
109:         address indexed user, 
110:         uint256 amount, 
111:         string reason, 
112:         uint256 timestamp 
113:     ); 
114:      
115:     constructor( 
116:         ERC20Votes _token, 
117:         TimelockController _timelock, 
118:         address _reputationToken 
119:     ) 
120:         Governor("StructuredLendingGovernor") 
121:         GovernorSettings(1, 50400, 0) // 1 block voting delay, 1 week voting period, 0 proposal threshold 
122:         GovernorVotes(_token) 
123:         GovernorVotesQuorumFraction(4) // 4% quorum 
124:         GovernorTimelockControl(_timelock) 
125:     { 
126:         reputationToken = ReputationToken(_reputationToken); 
127:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
128:     } 
129:      
130:     // Création de proposition améliorée 
131:     function proposeEnhanced( 
132:         address[] memory targets, 
133:         uint256[] memory values, 
134:         bytes[] memory calldatas, 
135:         string memory description, 
136:         string memory title, 
137:         ProposalCategory category, 
138:         string memory ipfsMetadata	 
139:     ) public returns (uint256) { 
140:         require( 
141:             reputationToken.balanceOf(msg.sender) >= minimumReputation, 
142:             "Insufficient reputation" 
143:         ); 
144:          
145:         // Dépôt de garantie 
146:         IERC20 governanceToken = IERC20(address(token())); 
147:         require( 
148:             governanceToken.transferFrom(msg.sender, address(this), proposalDeposit), 
149:             "Deposit failed" 
150:         ); 
151:          
152:         // Création de la proposition 
153:         uint256 proposalId = propose(targets, values, calldatas, description); 
154:          
155:         // Enregistrement des métadonnées enrichies 
156:         enhancedProposals[proposalId] = EnhancedProposal({ 
157:             proposalId: proposalId, 
158:             proposer: msg.sender, 
159:             title: title, 
160:             description: description, 
161:             category: category, 
162:             createdTime: block.timestamp, 
163:             votingEndTime: block.timestamp + votingPeriod(), 
164:             status: ProposalStatus.ACTIVE, 
165:             calldatas: calldatas, 
166:             targets: targets, 
167:             forVotes: 0, 
168:             againstVotes: 0, 
169:             abstainVotes: 0, 
170:             executionTime: 0, 
171:             ipfsMetadata: ipfsMetadata 
172:         }); 
173:          
174:         proposalCount++; 
175:          
176:         // Attribution de réputation pour la création de proposition 
177:         reputationToken.mint(msg.sender, 10); // 10 points de réputation 
178:          
179:         emit ProposalCreated(proposalId, msg.sender, title, category, block.timestamp); 
180:         emit ReputationAwarded(msg.sender, 10, "Proposal creation", block.timestamp); 
181:          
182:         return proposalId; 
183:     } 
184:      
185:     // Vote avec poids de réputation 
186:     function castVoteWithReasonAndReputation( 
187:         uint256 proposalId, 
188:         uint8 support, 
189:         string memory reason 
190:     ) public returns (uint256) { 
191:         // Vérifier que la proposition est active 
192:         require(state(proposalId) == ProposalState.Active, "Voting not active"); 
193:          
194:         // Calcul du poids du vote (tokens + réputation) 
195:         uint256 tokenWeight = getVotes(msg.sender, proposalId); 
196:         uint256 reputationWeight = reputationToken.balanceOf(msg.sender); 
197:         uint256 totalWeight = tokenWeight + (reputationWeight / 10); // Réputation compte pour 1/10 
198:          
199:         // Enregistrement du vote 
200:         _castVote(proposalId, msg.sender, support, reason); 
201:          
202:         // Mise à jour des compteurs dans enhancedProposals 
203:         EnhancedProposal storage proposal = enhancedProposals[proposalId]; 
204:         if (support == 0) { 
205:             proposal.againstVotes += totalWeight; 
206:         } else if (support == 1) { 
207:             proposal.forVotes += totalWeight; 
208:         } else if (support == 2) { 
209:             proposal.abstainVotes += totalWeight; 
210:         } 
211:          
212:         // Attribution de réputation pour la participation 
213:         reputationToken.mint(msg.sender, 1); 
214:          
215:         emit VoteCast( 
216:             proposalId, 
217:             msg.sender, 
218:             totalWeight, 
219:             reputationWeight, 
220:             support == 1 ? "FOR" : support == 0 ? "AGAINST" : "ABSTAIN", 
221:             block.timestamp 
222:         ); 
223:          
224:         emit ReputationAwarded(msg.sender, 1, "Voting participation", block.timestamp); 
225:          
226:         return totalWeight; 
227:     } 
228:      
229:     // Exécution de proposition 
230:     function executeEnhanced( 
231:         address[] memory targets, 
232:         uint256[] memory values, 
233:         bytes[] memory calldatas, 
234:         bytes32 descriptionHash 
235:     ) public payable returns (uint256) { 
236:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash); 
237:          
238:         // Vérifier que la proposition a réussie 
239:         require(state(proposalId) == ProposalState.Succeeded, "Proposal not succeeded"); 
240:          
241:         // Exécution 
242:         _execute(proposalId, targets, values, calldatas, descriptionHash); 
243:          
244:         // Mise à jour du statut 
245:         EnhancedProposal storage proposal = enhancedProposals[proposalId]; 
246:         proposal.status = ProposalStatus.EXECUTED; 
247:         proposal.executionTime = block.timestamp; 
248:          
249:         // Remboursement du dépôt au proposant 
250:         IERC20 governanceToken = IERC20(address(token())); 
251:         governanceToken.transfer(proposal.proposer, proposalDeposit); 
252:          
253:         // Attribution de réputation supplémentaire pour l'exécution réussie 
254:         reputationToken.mint(proposal.proposer, 50); 
255:          
256:         emit ProposalExecuted(proposalId, msg.sender, block.timestamp); 
257:         emit ReputationAwarded(proposal.proposer, 50, "Successful proposal execution", block.timestamp); 
258:          
259:         return proposalId; 
260:     } 
261:      
262:     // Délégation de votes avec historique 
263:     function delegateWithRecord(address delegatee) public { 
264:         uint256 currentVotes = getVotes(msg.sender, block.number); 
265:          
266:         // Délégation standard 
267:         reputationToken.delegate(delegatee); 
268:          
269:         // Enregistrement historique 
270:         delegationHistory[msg.sender].push(Delegation({ 
271:             delegatee: delegatee, 
272:             amount: currentVotes, 
273:             timestamp: block.timestamp 
274:         })); 
275:          
276:         // Attribution de réputation pour la délégation 
277:         reputationToken.mint(msg.sender, 2); 
278:         emit ReputationAwarded(msg.sender, 2, "Vote delegation", block.timestamp); 
279:     } 
280:      
281:     // Création de proposition rapide pour les paramètres 
282:     function proposeParameterChange( 
283:         address targetContract, 
284:         string memory functionSignature, 
285:         bytes memory newValue, 
286:         string memory title, 
287:         string memory description 
288:     ) external returns (uint256) { 
289:         bytes[] memory calldatas = new bytes[](1); 
290:         calldatas[0] = abi.encodePacked( 
291:             bytes4(keccak256(bytes(functionSignature))), 
292:             newValue 
293:         ); 
294:          
295:         address[] memory targets = new address[](1); 
296:         targets[0] = targetContract; 
297:          
298:         uint256[] memory values = new uint256[](1); 
299:         values[0] = 0; 
300:          
301:         return proposeEnhanced( 
302:             targets, 
303:             values, 
304:             calldatas, 
305:             description, 
306:             title, 
307:             ProposalCategory.PARAMETER_CHANGE, 
308:             "" 
309:         ); 
310:     } 
311:      
312:     // Proposition de subvention communautaire 
313:     function proposeCommunityGrant( 
314:         address recipient, 
315:         uint256 amount, 
316:         string memory title, 
317:         string memory description, 
318:         string memory justification 
319:     ) external returns (uint256) { 
320:         bytes[] memory calldatas = new bytes[](1); 
321:         calldatas[0] = abi.encodeWithSignature( 
322:             "transfer(address,uint256)", 
323:             recipient, 
324:             amount 
325:         ); 
326:          
327:         address[] memory targets = new address[](1); 
328:         targets[0] = address(token()); // Trésorerie en tokens de gouvernance 
329:          
330:         uint256[] memory values = new uint256[](1); 
331:         values[0] = 0; 
332:          
333:         string memory ipfsMetadata = string(abi.encodePacked( 
334:             "{\"recipient\":\"", 
335:             _addressToString(recipient), 
336:             "\",\"amount\":", 
337:             _toString(amount), 
338:             ",\"justification\":\"", 
339:             justification, 
340:             "\"}" 
341:         )); 
342:          
343:         return proposeEnhanced( 
344:             targets, 
345:             values, 
346:             calldatas, 
347:             description, 
348:             title, 
349:             ProposalCategory.COMMUNITY_GRANT, 
350:             ipfsMetadata 
351:         ); 
352:     } 
353:      
354:     // Proposition d'action d'urgence 
355:     function proposeEmergencyAction( 
356:         address targetContract, 
357:         bytes memory emergencyCalldata, 
358:         string memory title, 
359:         string memory emergencyDescription 
360:     ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) { 
361:         bytes[] memory calldatas = new bytes[](1); 
362:         calldatas[0] = emergencyCalldata; 
363:          
364:         address[] memory targets = new address[](1); 
365:         targets[0] = targetContract; 
366:          
367:         uint256[] memory values = new uint256[](1); 
368:         values[0] = 0; 
369:          
370:         return proposeEnhanced( 
371:             targets, 
372:             values, 
373:             emergencyDescription, 
374:             title, 
375:             ProposalCategory.EMERGENCY_ACTION, 
376:             "{\"emergency\":true}" 
377:         ); 
378:     } 
379:      
380:     // Getters pour les propositions enrichies 
381:     function getEnhancedProposal(uint256 proposalId) external view returns ( 
382:         address proposer, 
383:         string memory title, 
384:         ProposalCategory category, 
385:         ProposalStatus status, 
386:         uint256 forVotes, 
387:         uint256 againstVotes, 
388:         uint256 abstainVotes, 
389:         uint256 createdTime, 
390:         uint256 votingEndTime 
391:     ) { 
392:         EnhancedProposal memory proposal = enhancedProposals[proposalId]; 
393:         return ( 
394:             proposal.proposer, 
395:             proposal.title, 
396:             proposal.category, 
397:             proposal.status, 
398:             proposal.forVotes, 
399:             proposal.againstVotes, 
400:             proposal.abstainVotes, 
401:             proposal.createdTime, 
402:             proposal.votingEndTime 
403:         ); 
404:     } 
405:      
406:     function getProposalsByCategory(ProposalCategory category) external view returns (uint256[] memory) { 
407:         uint256[] memory result = new uint256[](proposalCount); 
408:         uint256 count = 0; 
409:          
410:         for (uint256 i = 0; i < proposalCount; i++) { 
411:             if (enhancedProposals[i].category == category) { 
412:                 result[count] = i; 
413:                 count++; 
414:             } 
415:         } 
416:          
417:         // Redimensionner le tableau 
418:         uint256[] memory finalResult = new uint256[](count); 
419:         for (uint256 j = 0; j < count; j++) { 
420:             finalResult[j] = result[j]; 
421:         } 
422:          
423:         return finalResult; 
424:     } 
425:      
426:     function getVotingPowerWithReputation(address account) external view returns (uint256) { 
427:         uint256 tokenPower = getVotes(account, block.number); 
428:         uint256 reputationPower = reputationToken.balanceOf(account) / 10; 
429:         return tokenPower + reputationPower; 
430:     } 
431:      
432:     // Configuration des paramètres 
433:     function setMinimumReputation(uint256 newMinimum) external onlyRole(DEFAULT_ADMIN_ROLE) { 
434:         minimumReputation = newMinimum; 
435:     } 
436:      
437:     function setProposalDeposit(uint256 newDeposit) external onlyRole(DEFAULT_ADMIN_ROLE) { 
438:         proposalDeposit = newDeposit; 
439:     } 
440:      
441:     // Fonctions utilitaires 
442:     function _toString(uint256 value) internal pure returns (string memory) { 
443:         if (value == 0) return "0"; 
444:          
445:         uint256 temp = value; 
446:         uint256 digits; 
447:         while (temp = 0) { 
448:             digits++; 
449:             temp /= 10; 
450:         } 
451:          
452:         bytes memory buffer = new bytes(digits); 
453:         while (value = 0) { 
454:             digits -= 1; 
455:             buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); 
456:             value /= 10; 
457:         } 
458:          
459:         return string(buffer); 
460:     } 
461:      
462:     function _addressToString(address addr) internal pure returns (string memory) { 
463:         bytes32 value = bytes32(uint256(uint160(addr))); 
464:         bytes memory alphabet = "0123456789abcdef"; 
465:         bytes memory str = new bytes(42); 
466:         str[0] = '0'; 
467:         str[1] = 'x'; 
468:          
469:         for (uint256 i = 0; i < 20; i++) { 
470:             str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)]; 
471:             str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)]; 
472:         } 
473:          
474:         return string(str); 
475:     } 
476:      
477:     // Overrides nécessaires 
478:     function votingDelay() public view override(GovernorSettings) returns (uint256) { 
479:         return super.votingDelay(); 
480:     } 
481:      
482:     function votingPeriod() public view override(GovernorSettings) returns (uint256) { 
483:         return super.votingPeriod(); 
484:     } 
485:      
486:     function quorum(uint256 blockNumber)  
487:         public  
488:         view  
489:         override(GovernorVotesQuorumFraction)  
490:         returns (uint256)  
491:     { 
492:         return super.quorum(blockNumber); 
493:     } 
494:      
495:     function state(uint256 proposalId)  
496:         public  
497:         view  
498:         override(GovernorTimelockControl)  
499:         returns (ProposalState)  
500:     { 
501:         return super.state(proposalId); 
502:     } 
503:      
504:     function proposalThreshold()  
505:         public  
506:         view  
507:         override(GovernorSettings)  
508:         returns (uint256)  
509:     { 
510:         return super.proposalThreshold(); 
511:     } 
512:      
513:     function _execute( 
514:         uint256 proposalId, 
515:         address[] memory targets, 
516:         uint256[] memory values, 
517:         bytes[] memory calldatas, 
518:         bytes32 descriptionHash 
519:     ) internal override(GovernorTimelockControl) { 
520:         super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); 
521:     } 
522:      
523:     function _cancel( 
524:         address[] memory targets, 
525:         uint256[] memory values, 
526:         bytes[] memory calldatas, 
527:         bytes32 descriptionHash 
528:     ) internal override(GovernorTimelockControl) returns (uint256) { 
529:         return super._cancel(targets, values, calldatas, descriptionHash); 
530:     } 
531:      
532:     function _executor() internal view override(GovernorTimelockControl) returns (address) { 
533:         return super._executor(); 
534:     } 
535:      
536:     function supportsInterface(bytes4 interfaceId) 
537:         public 
538:         view 
539:         override(AccessControl) 
540:         returns (bool) 
541:     { 
542:         return super.supportsInterface(interfaceId); 
543:     } 
544: 	function _executeOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)  
545: 		internal override(GovernorTimelockControl) { 
546: 		super._executeOperations(proposalId, targets, values, calldatas, descriptionHash); 
547: 	} 
548: 	function _queueOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)  
549: 		internal override(GovernorTimelockControl) returns (uint48) { 
550: 		return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash); 
551: 	} 
552: 	function proposalNeedsQueuing(uint256 proposalId) public view override returns (bool) { 
553: 		return super.proposalNeedsQueuing(proposalId); 
554: 	} 
555: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol"; 
4: import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; 
5: import "@openzeppelin/contracts/access/AccessControl.sol"; 
6: contract ReputationToken is ERC20Votes, AccessControl { 
7:     // Structure de réputation 
8:     struct ReputationScore { 
9:         uint256 totalScore; 
10:         uint256 lastUpdate; 
11:         uint256[] categoryScores; 
12:         uint256 decayRate; 
13:     } 
14:      
15:     // Catégories de réputation 
16:     enum ReputationCategory { 
17:         LOAN_REPAYMENT, 
18:         GOVERNANCE_PARTICIPATION, 
19:         INSURANCE_PERFORMANCE, 
20:         COMMUNITY_CONTRIBUTION, 
21:         SYSTEM_SECURITY 
22:     } 
23:      
24:     // Événements de réputation 
25:     struct ReputationEvent { 
26:         address user; 
27:         ReputationCategory category; 
28:         uint256 points; 
29:         string reason; 
30:         uint256 timestamp; 
31:     } 
32:      
33:     // Variables d'état 
34:     mapping(address => ReputationScore) public reputationScores; 
35:     mapping(address => ReputationEvent[]) public reputationHistory; 
36:     mapping(address => uint256) public lastActivity; 
37:      
38:     uint256 public baseDecayRate = 100; // 1% par mois 
39:     uint256 public maxReputationPerUser = 10000 * 1e18; 
40:     uint256 public minReputationForBenefits = 100 * 1e18; 
41:      
42:     // Contrats autorisés à accorder de la réputation 
43:     mapping(address => bool) public reputationGranters; 
44:      
45:     // Événements 
46:     event ReputationMinted( 
47:         address indexed user, 
48:         ReputationCategory category, 
49:         uint256 amount, 
50:         string reason, 
51:         uint256 timestamp 
52:     ); 
53:      
54:     event ReputationBurned( 
55:         address indexed user, 
56:         uint256 amount, 
57:         string reason, 
58:         uint256 timestamp 
59:     ); 
60:      
61:     event ReputationTransferred( 
62:         address indexed from, 
63:         address indexed to, 
64:         uint256 amount, 
65:         uint256 timestamp 
66:     ); 
67:      
68:     // Rôles 
69:     bytes32 public constant REPUTATION_MINTER = keccak256("REPUTATION_MINTER"); 
70:     bytes32 public constant REPUTATION_BURNER = keccak256("REPUTATION_BURNER"); 
71:      
72:     constructor() 
73: 		ERC20("StructuredLendingReputation", "SLR") 
74: 		ERC20Permit("StructuredLendingReputation") 
75: 		ERC20Votes() 
76: 	{ 
77: 		_grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
78:         _grantRole(REPUTATION_MINTER, msg.sender); 
79:         _grantRole(REPUTATION_BURNER, msg.sender); 
80:     } 
81:      
82:     // Attribution de réputation 
83:     function mintReputation( 
84:         address to, 
85:         uint256 amount, 
86:         ReputationCategory category, 
87:         string memory reason 
88:     ) external onlyRole(REPUTATION_MINTER) { 
89:         require(to = address(0), "Invalid address"); 
90:         require(amount > 0, "Amount must be > 0"); 
91:          
92:         // Vérifier la limite par utilisateur 
93:         uint256 newTotal = balanceOf(to) + amount; 
94:         require(newTotal <= maxReputationPerUser, "Exceeds max reputation"); 
95:          
96:         // Mint des tokens 
97:         _mint(to, amount); 
98:          
99:         // Mise à jour du score de réputation 
100:         _updateReputationScore(to, category, amount); 
101:          
102:         // Enregistrement dans l'historique 
103:         reputationHistory[to].push(ReputationEvent({ 
104:             user: to, 
105:             category: category, 
106:             points: amount, 
107:             reason: reason, 
108:             timestamp: block.timestamp 
109:         })); 
110:          
111:         // Mise à jour de la dernière activité 
112:         lastActivity[to] = block.timestamp; 
113:          
114:         emit ReputationMinted(to, category, amount, reason, block.timestamp); 
115:     } 
116:      
117:     // Retrait de réputation (pour pénalités) 
118:     function burnReputation( 
119:         address from, 
120:         uint256 amount, 
121:         string memory reason 
122:     ) external onlyRole(REPUTATION_BURNER) { 
123:         require(balanceOf(from) >= amount, "Insufficient reputation"); 
124:          
125:         // Burn des tokens 
126:         _burn(from, amount); 
127:          
128:         // Mise à jour du score (diminution générale) 
129:         ReputationScore storage score = reputationScores[from]; 
130:         score.totalScore = score.totalScore > amount ? score.totalScore - amount : 0; 
131:         score.lastUpdate = block.timestamp; 
132:          
133:         emit ReputationBurned(from, amount, reason, block.timestamp); 
134:     } 
135:      
136:     // Transfert de réputation avec restrictions 
137:     function transferReputation( 
138:         address to, 
139:         uint256 amount 
140:     ) external returns (bool) { 
141:         require(to = address(0), "Invalid recipient"); 
142:         require(amount > 0, "Amount must be > 0"); 
143:         require(balanceOf(msg.sender) >= amount, "Insufficient reputation"); 
144:          
145:         // Vérifier que le destinataire ne dépasse pas la limite 
146:         uint256 recipientBalance = balanceOf(to); 
147:         require(recipientBalance + amount <= maxReputationPerUser, "Recipient exceeds max"); 
148:          
149:         // Vérifier que l'expéditeur garde un minimum 
150:         uint256 senderNewBalance = balanceOf(msg.sender) - amount; 
151:         require(senderNewBalance >= minReputationForBenefits, "Below minimum for benefits"); 
152:          
153:         // Transfert standard 
154:         bool success = transfer(to, amount); 
155:          
156:         if (success) { 
157:             // Mise à jour des scores 
158:             _updateTransferReputation(msg.sender, to, amount); 
159:              
160:             emit ReputationTransferred(msg.sender, to, amount, block.timestamp); 
161:         } 
162:          
163:         return success; 
164:     } 
165:      
166:     // Application de la dégradation (décay) de la réputation 
167:     function applyDecay(address user) external { 
168:         ReputationScore storage score = reputationScores[user]; 
169:          
170:         uint256 timeSinceUpdate = block.timestamp - score.lastUpdate; 
171:         if (timeSinceUpdate < 30 days) { 
172:             return; // Pas encore de dégradation 
173:         } 
174:          
175:         // Calcul de la dégradation 
176:         uint256 monthsPassed = timeSinceUpdate / 30 days; 
177:         uint256 decayAmount = (score.totalScore * baseDecayRate * monthsPassed) / 10000; 
178:          
179:         if (decayAmount > 0) { 
180:             // Ajuster le score 
181:             score.totalScore = score.totalScore > decayAmount ?  
182:                 score.totalScore - decayAmount : 0; 
183:              
184:             // Ajuster le solde du token 
185:             uint256 tokenBalance = balanceOf(user); 
186:             if (tokenBalance > decayAmount) { 
187:                 _burn(user, decayAmount); 
188:             } else if (tokenBalance > 0) { 
189:                 _burn(user, tokenBalance); 
190:             } 
191:              
192:             // Enregistrement de l'événement 
193:             reputationHistory[user].push(ReputationEvent({ 
194:                 user: user, 
195:                 category: ReputationCategory.SYSTEM_SECURITY, 
196:                 points: decayAmount, 
197:                 reason: "Monthly reputation decay", 
198:                 timestamp: block.timestamp 
199:             })); 
200:         } 
201:          
202:         score.lastUpdate = block.timestamp; 
203:     } 
204:      
205:     // Calcul du score de réputation pondéré 
206:     function calculateWeightedScore(address user) public view returns (uint256) { 
207:         ReputationScore memory score = reputationScores[user]; 
208:          
209:         if (score.totalScore == 0) { 
210:             return 0; 
211:         } 
212:          
213:         // Appliquer la dégradation dans le calcul 
214:         uint256 timeSinceUpdate = block.timestamp - score.lastUpdate; 
215:         uint256 monthsPassed = timeSinceUpdate / 30 days; 
216:          
217:         if (monthsPassed > 0) { 
218:             uint256 decayAmount = (score.totalScore * baseDecayRate * monthsPassed) / 10000; 
219:             if (decayAmount < score.totalScore) { 
220:                 return score.totalScore - decayAmount; 
221:             } 
222:         } 
223:          
224:         return score.totalScore; 
225:     } 
226:      
227:     // Vérification des avantages basés sur la réputation 
228:     function hasGovernanceVotingRights(address user) public view returns (bool) { 
229:         return calculateWeightedScore(user) >= minReputationForBenefits; 
230:     } 
231:      
232:     function hasPremiumFeaturesAccess(address user) public view returns (bool) { 
233:         return calculateWeightedScore(user) >= minReputationForBenefits * 2; 
234:     } 
235:      
236:     function hasEarlyAccessFeatures(address user) public view returns (bool) { 
237:         return calculateWeightedScore(user) >= minReputationForBenefits * 5; 
238:     } 
239:      
240:     // Récupération de l'historique de réputation 
241:     function getReputationHistory(address user, uint256 limit)  
242:         public  
243:         view  
244:         returns (ReputationEvent[] memory)  
245:     { 
246:         ReputationEvent[] storage history = reputationHistory[user]; 
247:          
248:         if (limit == 0 || limit > history.length) { 
249:             limit = history.length; 
250:         } 
251:          
252:         ReputationEvent[] memory result = new ReputationEvent[](limit); 
253:          
254:         for (uint256 i = 0; i < limit; i++) { 
255:             result[i] = history[history.length - 1 - i]; // Inverser pour avoir les plus récents en premier 
256:         } 
257:          
258:         return result; 
259:     } 
260:      
261:     // Statistiques de réputation 
262:     function getReputationStats(address user) public view returns ( 
263:         uint256 totalScore, 
264:         uint256 weightedScore, 
265:         uint256 lastUpdate, 
266:         uint256 categoryCount, 
267:         bool hasVotingRights, 
268:         bool hasPremiumAccess, 
269:         bool hasEarlyAccess 
270:     ) { 
271:         ReputationScore memory score = reputationScores[user]; 
272:          
273:         return ( 
274:             score.totalScore, 
275:             calculateWeightedScore(user), 
276:             score.lastUpdate, 
277:             score.categoryScores.length, 
278:             hasGovernanceVotingRights(user), 
279:             hasPremiumFeaturesAccess(user), 
280:             hasEarlyAccessFeatures(user) 
281:         ); 
282:     } 
283:      
284:     // Fonctions internes 
285:     function _updateReputationScore( 
286:         address user, 
287:         ReputationCategory category, 
288:         uint256 amount 
289:     ) private { 
290:         ReputationScore storage score = reputationScores[user]; 
291:          
292:         // Initialiser si nécessaire 
293:         if (score.categoryScores.length == 0) { 
294:             score.categoryScores = new uint256[](5); // 5 catégories 
295:             score.decayRate = baseDecayRate; 
296:         } 
297:          
298:         // Mettre à jour le score total 
299:         score.totalScore += amount; 
300:          
301:         // Mettre à jour la catégorie spécifique 
302:         if (uint256(category) < score.categoryScores.length) { 
303:             score.categoryScores[uint256(category)] += amount; 
304:         } 
305:          
306:         score.lastUpdate = block.timestamp; 
307:          
308:         // Ajuster le taux de dégradation basé sur l'activité 
309:         if (amount > 100 * 1e18) { // Grande attribution 
310:             score.decayRate = score.decayRate * 90 / 100; // Réduire la dégradation de 10% 
311:         } 
312:     } 
313:      
314:     function _updateTransferReputation( 
315:         address from, 
316:         address to, 
317:         uint256 amount 
318:     ) private { 
319:         // L'expéditeur perd proportionnellement de chaque catégorie 
320:         ReputationScore storage fromScore = reputationScores[from]; 
321:         ReputationScore storage toScore = reputationScores[to]; 
322:          
323:         if (fromScore.totalScore > 0) { 
324:             // Calculer la proportion à transférer de chaque catégorie 
325:             uint256 transferRatio = (amount * 1e18) / fromScore.totalScore; 
326:              
327:             for (uint256 i = 0; i < fromScore.categoryScores.length; i++) { 
328:                 uint256 categoryTransfer = (fromScore.categoryScores[i] * transferRatio) / 1e18; 
329:                  
330:                 fromScore.categoryScores[i] -= categoryTransfer; 
331:                  
332:                 // Initialiser la catégorie du destinataire si nécessaire 
333:                 if (toScore.categoryScores.length == 0) { 
334:                     toScore.categoryScores = new uint256[](5); 
335:                 } 
336:                 toScore.categoryScores[i] += categoryTransfer; 
337:             } 
338:              
339:             fromScore.totalScore -= amount; 
340:             toScore.totalScore += amount; 
341:              
342:             fromScore.lastUpdate = block.timestamp; 
343:             toScore.lastUpdate = block.timestamp; 
344:         } else { 
345:             // Si l'expéditeur n'a pas de score détaillé, simplement ajouter au destinataire 
346:             toScore.totalScore += amount; 
347:             toScore.lastUpdate = block.timestamp; 
348:         } 
349:     } 
350:      
351:     // Configuration 
352:     function setBaseDecayRate(uint256 newRate) external onlyRole(DEFAULT_ADMIN_ROLE) { 
353:         require(newRate <= 1000, "Rate too high"); // Max 10% 
354:         baseDecayRate = newRate; 
355:     } 
356:      
357:     function setMaxReputationPerUser(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) { 
358:         maxReputationPerUser = newMax; 
359:     } 
360:      
361:     function setMinReputationForBenefits(uint256 newMin) external onlyRole(DEFAULT_ADMIN_ROLE) { 
362:         minReputationForBenefits = newMin; 
363:     } 
364:      
365:     // Autoriser un contrat à accorder de la réputation 
366:     function addReputationGranter(address granter) external onlyRole(DEFAULT_ADMIN_ROLE) { 
367:         reputationGranters[granter] = true; 
368:         _grantRole(REPUTATION_MINTER, granter); 
369:     } 
370:      
371:     // Override des fonctions de transfert standard pour ajouter des restrictions 
372:     function transfer(address to, uint256 amount) public override returns (bool) { 
373:         require(balanceOf(msg.sender) - amount >= minReputationForBenefits,  
374:             "Transfer would go below minimum"); 
375:          
376:         return super.transfer(to, amount); 
377:     } 
378:      
379:     function transferFrom( 
380:         address from, 
381:         address to, 
382:         uint256 amount 
383:     ) public override returns (bool) { 
384:         require(balanceOf(from) - amount >= minReputationForBenefits, 
385:             "Transfer would leave sender below minimum"); 
386:          
387:         return super.transferFrom(from, to, amount); 
388:     } 
389:      
390:     // Getters 
391:     function getCategoryScore(address user, ReputationCategory category)  
392:         external  
393:         view  
394:         returns (uint256)  
395:     { 
396:         ReputationScore memory score = reputationScores[user]; 
397:          
398:         if (uint256(category) < score.categoryScores.length) { 
399:             return score.categoryScores[uint256(category)]; 
400:         } 
401:          
402:         return 0; 
403:     } 
404:      
405:     function getReputationLevel(address user) external view returns (string memory) { 
406:         uint256 score = calculateWeightedScore(user); 
407:          
408:         if (score >= 5000 * 1e18) return "Legendary"; 
409:         if (score >= 2000 * 1e18) return "Expert"; 
410:         if (score >= 1000 * 1e18) return "Advanced"; 
411:         if (score >= 500 * 1e18) return "Intermediate"; 
412:         if (score >= 100 * 1e18) return "Beginner"; 
413:          
414:         return "Newcomer"; 
415:     } 
416: 	 
417: 	function mint(address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) { 
418: 		_mint(to, amount); 
419: 	} 
420: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
4: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
5: import "@openzeppelin/contracts/utils/Pausable.sol"; 
6: import "@openzeppelin/contracts/access/AccessControl.sol"; 
7: contract FeeDistributor is ReentrancyGuard, AccessControl { 
8:     // Structure de distribution 
9:     struct DistributionPool { 
10:         address recipient; 
11:         uint256 sharePercentage; 
12:         string description; 
13:         bool isActive; 
14:     } 
15:      
16:     // Structure de frais accumulés 
17:     struct AccruedFees { 
18:         address token; 
19:         uint256 amount; 
20:         uint256 lastDistribution; 
21:     } 
22:      
23:     // Structure de récompense de performance 
24:     struct PerformanceReward { 
25:         address recipient; 
26:         uint256 rewardAmount; 
27:         uint256 timestamp; 
28:         string performanceMetric; 
29:     } 
30:      
31:     // Variables d'état 
32:     DistributionPool[] public distributionPools; 
33:     mapping(address => AccruedFees) public accruedFees; 
34:     mapping(address => PerformanceReward[]) public performanceRewards; 
35:      
36:     uint256 public totalDistributed; 
37:     uint256 public distributionInterval = 7 days; 
38:     uint256 public lastDistributionTime; 
39:      
40:     address public feeToken; 
41:      
42:     // Événements 
43:     event FeesAccrued( 
44:         address indexed token, 
45:         uint256 amount, 
46:         address indexed source, 
47:         uint256 timestamp 
48:     ); 
49:      
50:     event DistributionExecuted( 
51:         uint256 distributionId, 
52:         uint256 totalAmount, 
53:         uint256 timestamp 
54:     ); 
55:      
56:     event PoolAdded( 
57:         uint256 poolId, 
58:         address recipient, 
59:         uint256 sharePercentage, 
60:         string description 
61:     ); 
62:      
63:     event PerformanceRewardDistributed( 
64:         address indexed recipient, 
65:         uint256 amount, 
66:         string metric, 
67:         uint256 timestamp 
68:     ); 
69:      
70:     // Rôles 
71:     bytes32 public constant FEE_COLLECTOR = keccak256("FEE_COLLECTOR"); 
72:     bytes32 public constant DISTRIBUTOR = keccak256("DISTRIBUTOR"); 
73:      
74:     constructor(address _feeToken) { 
75:         feeToken = _feeToken; 
76:          
77:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
78:         _grantRole(FEE_COLLECTOR, msg.sender); 
79:         _grantRole(DISTRIBUTOR, msg.sender); 
80:          
81:         // Initialisation des pools par défaut 
82:         _initializeDefaultPools(); 
83:          
84:         lastDistributionTime = block.timestamp; 
85:     } 
86:      
87:     // Initialisation des pools par défaut 
88:     function _initializeDefaultPools() private { 
89:         // Pool 1: Trésorerie du protocole 
90:         distributionPools.push(DistributionPool({ 
91:             recipient: msg.sender, 
92:             sharePercentage: 4000, // 40% 
93:             description: "Protocol Treasury", 
94:             isActive: true 
95:         })); 
96:          
97:         // Pool 2: Récompenses des stakers 
98:         distributionPools.push(DistributionPool({ 
99:             recipient: address(0), // À définir 
100:             sharePercentage: 3000, // 30% 
101:             description: "Staker Rewards", 
102:             isActive: true 
103:         })); 
104:          
105:         // Pool 3: Fonds de développement 
106:         distributionPools.push(DistributionPool({ 
107:             recipient: address(0), // À définir 
108:             sharePercentage: 1500, // 15% 
109:             description: "Development Fund", 
110:             isActive: true 
111:         })); 
112:          
113:         // Pool 4: Fonds d'assurance 
114:         distributionPools.push(DistributionPool({ 
115:             recipient: address(0), // À définir 
116:             sharePercentage: 1000, // 10% 
117:             description: "Insurance Fund", 
118:             isActive: true 
119:         })); 
120:          
121:         // Pool 5: Réserve d'urgence 
122:         distributionPools.push(DistributionPool({ 
123:             recipient: address(0), // À définir 
124:             sharePercentage: 500, // 5% 
125:             description: "Emergency Reserve", 
126:             isActive: true 
127:         })); 
128:     } 
129:      
130:     // Accumulation de frais 
131:     function accrueFees(uint256 amount, address source) external onlyRole(FEE_COLLECTOR) { 
132:         require(amount > 0, "Amount must be > 0"); 
133:          
134:         // Transfert des tokens 
135:         IERC20 token = IERC20(feeToken); 
136:         require( 
137:             token.transferFrom(msg.sender, address(this), amount), 
138:             "Transfer failed" 
139:         ); 
140:          
141:         // Mise à jour des frais accumulés 
142:         AccruedFees storage fees = accruedFees[feeToken]; 
143:         fees.token = feeToken; 
144:         fees.amount += amount; 
145:          
146:         emit FeesAccrued(feeToken, amount, source, block.timestamp); 
147:     } 
148:      
149:     // Distribution des frais 
150:     function distributeFees() external nonReentrant onlyRole(DISTRIBUTOR) { 
151:         require( 
152:             block.timestamp >= lastDistributionTime + distributionInterval, 
153:             "Too soon for distribution" 
154:         ); 
155:          
156:         AccruedFees storage fees = accruedFees[feeToken]; 
157:         require(fees.amount > 0, "No fees to distribute"); 
158:          
159:         uint256 distributionId = uint256(keccak256(abi.encodePacked( 
160:             block.timestamp, 
161:             fees.amount 
162:         ))); 
163:          
164:         uint256 remainingAmount = fees.amount; 
165:          
166:         // Distribution aux pools actifs 
167:         for (uint256 i = 0; i < distributionPools.length; i++) { 
168:             if (distributionPools[i].isActive && distributionPools[i].recipient = address(0)) { 
169:                 uint256 poolShare = (fees.amount * distributionPools[i].sharePercentage) / 10000; 
170:                  
171:                 if (poolShare > 0 && poolShare <= remainingAmount) { 
172:                     IERC20 token = IERC20(feeToken); 
173:                     token.transfer(distributionPools[i].recipient, poolShare); 
174:                      
175:                     remainingAmount -= poolShare; 
176:                 } 
177:             } 
178:         } 
179:          
180:         // Mise à jour des totaux 
181:         totalDistributed += fees.amount; 
182:         fees.amount = 0; 
183:         fees.lastDistribution = block.timestamp; 
184:         lastDistributionTime = block.timestamp; 
185:          
186:         emit DistributionExecuted(distributionId, totalDistributed, block.timestamp); 
187:     } 
188:      
189:     // Distribution de récompenses de performance 
190:     function distributePerformanceReward( 
191:         address recipient, 
192:         uint256 amount, 
193:         string memory performanceMetric 
194:     ) external onlyRole(DISTRIBUTOR) nonReentrant { 
195:         require(recipient = address(0), "Invalid recipient"); 
196:         require(amount > 0, "Amount must be > 0"); 
197:          
198:         IERC20 token = IERC20(feeToken); 
199:         require( 
200:             token.balanceOf(address(this)) >= amount, 
201:             "Insufficient balance" 
202:         ); 
203:          
204:         token.transfer(recipient, amount); 
205:          
206:         // Enregistrement de la récompense 
207:         performanceRewards[recipient].push(PerformanceReward({ 
208:             recipient: recipient, 
209:             rewardAmount: amount, 
210:             timestamp: block.timestamp, 
211:             performanceMetric: performanceMetric 
212:         })); 
213:          
214:         emit PerformanceRewardDistributed( 
215:             recipient, 
216:             amount, 
217:             performanceMetric, 
218:             block.timestamp 
219:         ); 
220:     } 
221:      
222:     // Ajout d'un nouveau pool de distribution 
223:     function addDistributionPool( 
224:         address recipient, 
225:         uint256 sharePercentage, 
226:         string memory description 
227:     ) external onlyRole(DEFAULT_ADMIN_ROLE) { 
228:         require(recipient = address(0), "Invalid recipient"); 
229:         require(sharePercentage > 0 && sharePercentage <= 10000, "Invalid share"); 
230:          
231:         // Vérifier que le total des parts ne dépasse pas 100% 
232:         uint256 totalShares = sharePercentage; 
233:         for (uint256 i = 0; i < distributionPools.length; i++) { 
234:             if (distributionPools[i].isActive) { 
235:                 totalShares += distributionPools[i].sharePercentage; 
236:             } 
237:         } 
238:          
239:         require(totalShares <= 10000, "Total shares exceed 100%"); 
240:          
241:         uint256 poolId = distributionPools.length; 
242:          
243:         distributionPools.push(DistributionPool({ 
244:             recipient: recipient, 
245:             sharePercentage: sharePercentage, 
246:             description: description, 
247:             isActive: true 
248:         })); 
249:          
250:         emit PoolAdded(poolId, recipient, sharePercentage, description); 
251:     } 
252:      
253:     // Mise à jour d'un pool existant 
254:     function updateDistributionPool( 
255:         uint256 poolId, 
256:         address newRecipient, 
257:         uint256 newSharePercentage, 
258:         bool isActive 
259:     ) external onlyRole(DEFAULT_ADMIN_ROLE) { 
260:         require(poolId < distributionPools.length, "Invalid pool ID"); 
261:          
262:         DistributionPool storage pool = distributionPools[poolId]; 
263:          
264:         if (newRecipient = address(0)) { 
265:             pool.recipient = newRecipient; 
266:         } 
267:          
268:         if (newSharePercentage > 0) { 
269:             // Vérifier que le nouveau total ne dépasse pas 100% 
270:             uint256 totalShares = newSharePercentage; 
271:             for (uint256 i = 0; i < distributionPools.length; i++) { 
272:                 if (i = poolId && distributionPools[i].isActive) { 
273:                     totalShares += distributionPools[i].sharePercentage; 
274:                 } 
275:             } 
276:              
277:             require(totalShares <= 10000, "Total shares exceed 100%"); 
278:             pool.sharePercentage = newSharePercentage; 
279:         } 
280:          
281:         pool.isActive = isActive; 
282:     } 
283:      
284:     // Distribution manuelle (en cas d'urgence) 
285:     function emergencyDistribution( 
286:         address recipient, 
287:         uint256 amount 
288:     ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant { 
289:         require(recipient = address(0), "Invalid recipient"); 
290:         require(amount > 0, "Amount must be > 0"); 
291:          
292:         IERC20 token = IERC20(feeToken); 
293:         require( 
294:             token.balanceOf(address(this)) >= amount, 
295:             "Insufficient balance" 
296:         ); 
297:          
298:         token.transfer(recipient, amount); 
299:          
300:         // Ajuster les frais accumulés 
301:         AccruedFees storage fees = accruedFees[feeToken]; 
302:         if (fees.amount >= amount) { 
303:             fees.amount -= amount; 
304:         } else { 
305:             fees.amount = 0; 
306:         } 
307:     } 
308:      
309:     // Calcul des prochaines distributions 
310:     function calculateNextDistribution() external view returns ( 
311:         uint256 nextDistributionTime, 
312:         uint256 estimatedAmount, 
313:         DistributionPool[] memory activePools 
314:     ) { 
315:         nextDistributionTime = lastDistributionTime + distributionInterval; 
316:          
317:         AccruedFees memory fees = accruedFees[feeToken]; 
318:         estimatedAmount = fees.amount; 
319:          
320:         // Compter les pools actifs 
321:         uint256 activeCount = 0; 
322:         for (uint256 i = 0; i < distributionPools.length; i++) { 
323:             if (distributionPools[i].isActive && distributionPools[i].recipient = address(0)) { 
324:                 activeCount++; 
325:             } 
326:         } 
327:          
328:         // Collecter les pools actifs 
329:         activePools = new DistributionPool[](activeCount); 
330:         uint256 index = 0; 
331:          
332:         for (uint256 i = 0; i < distributionPools.length; i++) { 
333:             if (distributionPools[i].isActive && distributionPools[i].recipient = address(0)) { 
334:                 activePools[index] = distributionPools[i]; 
335:                 index++; 
336:             } 
337:         } 
338:          
339:         return (nextDistributionTime, estimatedAmount, activePools); 
340:     } 
341:      
342:     // Récupération des statistiques de distribution 
343:     function getDistributionStats() external view returns ( 
344:         uint256 totalAccrued, 
345:         uint256 totalDistributedAmount, 
346:         uint256 pendingDistribution, 
347:         uint256 poolCount, 
348:         uint256 activePoolCount 
349:     ) { 
350:         AccruedFees memory fees = accruedFees[feeToken]; 
351:          
352:         uint256 activeCount = 0; 
353:         for (uint256 i = 0; i < distributionPools.length; i++) { 
354:             if (distributionPools[i].isActive) { 
355:                 activeCount++; 
356:             } 
357:         } 
358:          
359:         return ( 
360:             fees.amount, 
361:             totalDistributed, 
362:             fees.amount, 
363:             distributionPools.length, 
364:             activeCount 
365:         ); 
366:     } 
367:      
368:     // Récupération des récompenses de performance d'un utilisateur 
369:     function getUserPerformanceRewards(address user)  
370:         external  
371:         view  
372:         returns (PerformanceReward[] memory)  
373:     { 
374:         return performanceRewards[user]; 
375:     } 
376:      
377:     // Configuration 
378:     function setDistributionInterval(uint256 newInterval) external onlyRole(DEFAULT_ADMIN_ROLE) { 
379:         require(newInterval >= 1 days, "Interval too short"); 
380:         require(newInterval <= 30 days, "Interval too long"); 
381:          
382:         distributionInterval = newInterval; 
383:     } 
384:      
385:     function setFeeToken(address newFeeToken) external onlyRole(DEFAULT_ADMIN_ROLE) { 
386:         require(newFeeToken = address(0), "Invalid token"); 
387:         feeToken = newFeeToken; 
388:     } 
389:      
390:     // Récupération des pools de distribution 
391:     function getAllPools() external view returns (DistributionPool[] memory) { 
392:         return distributionPools; 
393:     } 
394:      
395:     // Fonction pour calculer la part d'un pool 
396:     function calculatePoolShare(uint256 poolId, uint256 totalAmount)  
397:         external  
398:         view  
399:         returns (uint256)  
400:     { 
401:         require(poolId < distributionPools.length, "Invalid pool ID"); 
402:          
403:         DistributionPool memory pool = distributionPools[poolId]; 
404:         if (pool.isActive) { 
405:             return 0; 
406:         } 
407:          
408:         return (totalAmount * pool.sharePercentage) / 10000; 
409:     } 
410: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/AccessControl.sol"; 
4: contract NotificationManager is AccessControl { 
5:     // Types de notifications 
6:     enum NotificationType { 
7:         LOAN_CREATED, 
8:         LOAN_REPAYMENT_DUE, 
9:         LOAN_DEFAULT, 
10:         INSURANCE_CLAIM, 
11:         GOVERNANCE_PROPOSAL, 
12:         MARKET_LISTING, 
13:         PRICE_ALERT, 
14:         SYSTEM_UPDATE, 
15:         SECURITY_ALERT 
16:     } 
17:      
18:     // Priorités 
19:     enum Priority { 
20:         LOW, 
21:         MEDIUM, 
22:         HIGH, 
23:         CRITICAL 
24:     } 
25:      
26:     // Structure de notification 
27:     struct Notification { 
28:         uint256 notificationId; 
29:         address recipient; 
30:         NotificationType notificationType; 
31:         Priority priority; 
32:         string title; 
33:         string message; 
34:         bytes data; 
35:         uint256 timestamp; 
36:         bool isRead; 
37:         bool isArchived; 
38:     } 
39:      
40:     // Préférences utilisateur 
41:     struct UserPreferences { 
42:         bool emailNotifications; 
43:         bool pushNotifications; 
44:         bool smsNotifications; 
45:         uint256[] subscribedTypes; 
46:         uint256 quietHoursStart; 
47:         uint256 quietHoursEnd; 
48:     } 
49:      
50:     // Variables d'état 
51:     mapping(address => Notification[]) public userNotifications; 
52:     mapping(address => UserPreferences) public userPreferences; 
53:     mapping(uint256 => address) public notificationSenders; 
54:      
55:     uint256 public notificationCount; 
56:     uint256 public maxNotificationsPerUser = 1000; 
57:      
58:     // Contrats autorisés à envoyer des notifications 
59:     mapping(address => bool) public authorizedSenders; 
60:      
61:     // Événements 
62:     event NotificationSent( 
63:         uint256 indexed notificationId, 
64:         address indexed recipient, 
65:         NotificationType notificationType, 
66:         Priority priority, 
67:         uint256 timestamp 
68:     ); 
69:      
70:     event NotificationRead( 
71:         uint256 indexed notificationId, 
72:         address indexed recipient, 
73:         uint256 readTime 
74:     ); 
75:      
76:     event PreferencesUpdated( 
77:         address indexed user, 
78:         bool emailNotifications, 
79:         bool pushNotifications, 
80:         uint256 timestamp 
81:     ); 
82:      
83:     // Rôles 
84:     bytes32 public constant NOTIFICATION_SENDER = keccak256("NOTIFICATION_SENDER"); 
85:      
86:     constructor() { 
87:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
88:         _grantRole(NOTIFICATION_SENDER, msg.sender); 
89:     } 
90:      
91:     // Envoi de notification par un contrat autorisé 
92:     function sendNotification( 
93:         address recipient, 
94:         NotificationType notificationType, 
95:         Priority priority, 
96:         string memory title, 
97:         string memory message, 
98:         bytes memory data 
99:     ) public onlyRole(NOTIFICATION_SENDER) returns (uint256) { 
100:         require(recipient = address(0), "Invalid recipient"); 
101:          
102:         // Vérifier les préférences utilisateur 
103:         UserPreferences memory prefs = userPreferences[recipient]; 
104:         if (_shouldSendNotification(recipient, notificationType, prefs)) { 
105:             return 0; 
106:         } 
107:          
108:         // Créer la notification 
109:         uint256 notificationId = ++notificationCount; 
110:          
111:         Notification memory newNotification = Notification({ 
112:             notificationId: notificationId, 
113:             recipient: recipient, 
114:             notificationType: notificationType, 
115:             priority: priority, 
116:             title: title, 
117:             message: message, 
118:             data: data, 
119:             timestamp: block.timestamp, 
120:             isRead: false, 
121:             isArchived: false 
122:         }); 
123:          
124:         // Ajouter à la liste de l'utilisateur 
125:         userNotifications[recipient].push(newNotification); 
126:          
127:         // Gérer la limite de notifications 
128:         _manageNotificationLimit(recipient); 
129:          
130:         // Enregistrer l'expéditeur 
131:         notificationSenders[notificationId] = msg.sender; 
132:          
133:         emit NotificationSent( 
134:             notificationId, 
135:             recipient, 
136:             notificationType, 
137:             priority, 
138:             block.timestamp 
139:         ); 
140:          
141:         return notificationId; 
142:     } 
143:      
144:     // Envoi de notification groupée 
145:     function sendBulkNotification( 
146:         address[] memory recipients, 
147:         NotificationType notificationType, 
148:         Priority priority, 
149:         string memory title, 
150:         string memory message 
151:     ) external onlyRole(NOTIFICATION_SENDER) returns (uint256[] memory) { 
152:         require(recipients.length <= 100, "Too many recipients"); 
153:          
154:         uint256[] memory notificationIds = new uint256[](recipients.length); 
155:          
156:         for (uint256 i = 0; i < recipients.length; i++) { 
157:             notificationIds[i] = sendNotification( 
158:                 recipients[i], 
159:                 notificationType, 
160:                 priority, 
161:                 title, 
162:                 message, 
163:                 "" 
164:             ); 
165:         } 
166:          
167:         return notificationIds; 
168:     } 
169:      
170:     // Marquer une notification comme lue 
171:     function markAsRead(uint256 notificationId) external { 
172:         Notification[] storage notifications = userNotifications[msg.sender]; 
173:          
174:         for (uint256 i = 0; i < notifications.length; i++) { 
175:             if (notifications[i].notificationId == notificationId) { 
176:                 require(notifications[i].isRead, "Already read"); 
177:                  
178:                 notifications[i].isRead = true; 
179:                  
180:                 emit NotificationRead(notificationId, msg.sender, block.timestamp); 
181:                 return; 
182:             } 
183:         } 
184:          
185:         revert("Notification not found"); 
186:     } 
187:      
188:     // Marquer toutes les notifications comme lues 
189:     function markAllAsRead() external { 
190:         Notification[] storage notifications = userNotifications[msg.sender]; 
191:         uint256 markedCount = 0; 
192:          
193:         for (uint256 i = 0; i < notifications.length; i++) { 
194:             if (notifications[i].isRead) { 
195:                 notifications[i].isRead = true; 
196:                 markedCount++; 
197:                  
198:                 emit NotificationRead( 
199:                     notifications[i].notificationId, 
200:                     msg.sender, 
201:                     block.timestamp 
202:                 ); 
203:             } 
204:         } 
205:     } 
206:      
207:     // Archiver une notification 
208:     function archiveNotification(uint256 notificationId) external { 
209:         Notification[] storage notifications = userNotifications[msg.sender]; 
210:          
211:         for (uint256 i = 0; i < notifications.length; i++) { 
212:             if (notifications[i].notificationId == notificationId) { 
213:                 notifications[i].isArchived = true; 
214:                 return; 
215:             } 
216:         } 
217:          
218:         revert("Notification not found"); 
219:     } 
220:      
221:     // Mettre à jour les préférences 
222:     function updatePreferences( 
223:         bool emailNotifications, 
224:         bool pushNotifications, 
225:         bool smsNotifications, 
226:         uint256[] memory subscribedTypes, 
227:         uint256 quietHoursStart, 
228:         uint256 quietHoursEnd 
229:     ) external { 
230:         userPreferences[msg.sender] = UserPreferences({ 
231:             emailNotifications: emailNotifications, 
232:             pushNotifications: pushNotifications, 
233:             smsNotifications: smsNotifications, 
234:             subscribedTypes: subscribedTypes, 
235:             quietHoursStart: quietHoursStart, 
236:             quietHoursEnd: quietHoursEnd 
237:         }); 
238:          
239:         emit PreferencesUpdated( 
240:             msg.sender, 
241:             emailNotifications, 
242:             pushNotifications, 
243:             block.timestamp 
244:         ); 
245:     } 
246:      
247:     // Récupérer les notifications non lues 
248:     function getUnreadNotifications() external view returns (Notification[] memory) { 
249:         Notification[] storage allNotifications = userNotifications[msg.sender]; 
250:         uint256 unreadCount = 0; 
251:          
252:         // Compter les notifications non lues 
253:         for (uint256 i = 0; i < allNotifications.length; i++) { 
254:             if (allNotifications[i].isArchived) { 
255:                 unreadCount++; 
256:             } 
257:         } 
258:          
259:         // Collecter les notifications non lues 
260:         Notification[] memory unread = new Notification[](unreadCount); 
261:         uint256 index = 0; 
262:          
263:         for (uint256 i = 0; i < allNotifications.length; i++) { 
264:             if (allNotifications[i].isArchived) { 
265:                 unread[index] = allNotifications[i]; 
266:                 index++; 
267:             } 
268:         } 
269:          
270:         return unread; 
271:     } 
272:      
273:     // Récupérer les notifications par type 
274:     function getNotificationsByType(NotificationType notificationType)  
275:         external  
276:         view  
277:         returns (Notification[] memory)  
278:     { 
279:         Notification[] storage allNotifications = userNotifications[msg.sender]; 
280:         uint256 matchingCount = 0; 
281:          
282:         // Compter les notifications correspondantes 
283:         for (uint256 i = 0; i < allNotifications.length; i++) { 
284:             if (allNotifications[i].notificationType == notificationType &&  
285:                 allNotifications[i].isArchived) { 
286:                 matchingCount++; 
287:             } 
288:         } 
289:          
290:         // Collecter les notifications 
291:         Notification[] memory matching = new Notification[](matchingCount); 
292:         uint256 index = 0; 
293:          
294:         for (uint256 i = 0; i < allNotifications.length; i++) { 
295:             if (allNotifications[i].notificationType == notificationType &&  
296:                 allNotifications[i].isArchived) { 
297:                 matching[index] = allNotifications[i]; 
298:                 index++; 
299:             } 
300:         } 
301:          
302:         return matching; 
303:     } 
304:      
305:     // Récupérer les notifications par priorité 
306:     function getNotificationsByPriority(Priority priority)  
307:         external  
308:         view  
309:         returns (Notification[] memory)  
310:     { 
311:         Notification[] storage allNotifications = userNotifications[msg.sender]; 
312:         uint256 matchingCount = 0; 
313:          
314:         // Compter les notifications correspondantes 
315:         for (uint256 i = 0; i < allNotifications.length; i++) { 
316:             if (allNotifications[i].priority == priority &&  
317:                 allNotifications[i].isArchived) { 
318:                 matchingCount++; 
319:             } 
320:         } 
321:          
322:         // Collecter les notifications 
323:         Notification[] memory matching = new Notification[](matchingCount); 
324:         uint256 index = 0; 
325:          
326:         for (uint256 i = 0; i < allNotifications.length; i++) { 
327:             if (allNotifications[i].priority == priority &&  
328:                 allNotifications[i].isArchived) { 
329:                 matching[index] = allNotifications[i]; 
330:                 index++; 
331:             } 
332:         } 
333:          
334:         return matching; 
335:     } 
336:      
337:     // Supprimer les notifications archivées 
338:     function cleanupArchived() external { 
339:         Notification[] storage notifications = userNotifications[msg.sender]; 
340:         uint256 newLength = 0; 
341:          
342:         // Déplacer les notifications non archivées au début du tableau 
343:         for (uint256 i = 0; i < notifications.length; i++) { 
344:             if (notifications[i].isArchived) { 
345:                 notifications[newLength] = notifications[i]; 
346:                 newLength++; 
347:             } 
348:         } 
349:          
350:         // Réduire la taille du tableau 
351:         while (notifications.length > newLength) { 
352:             notifications.pop(); 
353:         } 
354:     } 
355:      
356:     // Fonctions internes 
357:     function _shouldSendNotification( 
358:         address recipient, 
359:         NotificationType notificationType, 
360:         UserPreferences memory prefs 
361:     ) private view returns (bool) { 
362:         // Vérifier les heures silencieuses 
363:         uint256 currentHour = (block.timestamp / 3600) % 24; 
364:         if (currentHour >= prefs.quietHoursStart && currentHour < prefs.quietHoursEnd) { 
365:             return false; 
366:         } 
367:          
368:         // Vérifier les types abonnés 
369:         bool isSubscribed = false; 
370:         for (uint256 i = 0; i < prefs.subscribedTypes.length; i++) { 
371:             if (prefs.subscribedTypes[i] == uint256(notificationType)) { 
372:                 isSubscribed = true; 
373:                 break; 
374:             } 
375:         } 
376:          
377:         if (prefs.subscribedTypes.length > 0 && isSubscribed) { 
378:             return false; 
379:         } 
380:          
381:         return true; 
382:     } 
383:      
384:     function _manageNotificationLimit(address user) private { 
385:         Notification[] storage notifications = userNotifications[user]; 
386:          
387:         if (notifications.length > maxNotificationsPerUser) { 
388:             // Supprimer les plus anciennes notifications archivées 
389:             uint256 toRemove = notifications.length - maxNotificationsPerUser; 
390:             uint256 removed = 0; 
391:             uint256 i = 0; 
392:              
393:             while (removed < toRemove && i < notifications.length) { 
394:                 if (notifications[i].isArchived) { 
395:                     // Déplacer les éléments suivants 
396:                     for (uint256 j = i; j < notifications.length - 1; j++) { 
397:                         notifications[j] = notifications[j + 1]; 
398:                     } 
399:                     notifications.pop(); 
400:                     removed++; 
401:                 } else { 
402:                     i++; 
403:                 } 
404:             } 
405:              
406:             // Si toujours au-dessus de la limite, supprimer les plus anciennes non archivées 
407:             if (notifications.length > maxNotificationsPerUser) { 
408:                 uint256 remainingToRemove = notifications.length - maxNotificationsPerUser; 
409:                 for (uint256 k = 0; k < remainingToRemove; k++) { 
410:                     // Déplacer tous les éléments d'une position 
411:                     for (uint256 l = 0; l < notifications.length - 1; l++) { 
412:                         notifications[l] = notifications[l + 1]; 
413:                     } 
414:                     notifications.pop(); 
415:                 } 
416:             } 
417:         } 
418:     } 
419:      
420:     // Autoriser un contrat à envoyer des notifications 
421:     function authorizeSender(address sender) external onlyRole(DEFAULT_ADMIN_ROLE) { 
422:         authorizedSenders[sender] = true; 
423:         _grantRole(NOTIFICATION_SENDER, sender); 
424:     } 
425:      
426:     // Révoquer l'autorisation d'un expéditeur 
427:     function revokeSender(address sender) external onlyRole(DEFAULT_ADMIN_ROLE) { 
428:         authorizedSenders[sender] = false; 
429:         _revokeRole(NOTIFICATION_SENDER, sender); 
430:     } 
431:      
432:     // Getters 
433:     function getNotificationCount(address user) external view returns (uint256) { 
434:         return userNotifications[user].length; 
435:     } 
436:      
437:     function getUnreadCount(address user) external view returns (uint256) { 
438:         uint256 count = 0; 
439:         Notification[] storage notifications = userNotifications[user]; 
440:          
441:         for (uint256 i = 0; i < notifications.length; i++) { 
442:             if (notifications[i].isArchived) { 
443:                 count++; 
444:             } 
445:         } 
446:          
447:         return count; 
448:     } 
449:      
450:     function getUserPreferences(address user) external view returns ( 
451:         bool emailNotifications, 
452:         bool pushNotifications, 
453:         bool smsNotifications, 
454:         uint256[] memory subscribedTypes 
455:     ) { 
456:         UserPreferences memory prefs = userPreferences[user]; 
457:         return ( 
458:             prefs.emailNotifications, 
459:             prefs.pushNotifications, 
460:             prefs.smsNotifications, 
461:             prefs.subscribedTypes 
462:         ); 
463:     } 
464:      
465:     // Templates de notifications prédéfinis 
466:     function sendLoanCreatedNotification( 
467:         address borrower, 
468:         uint256 loanId, 
469:         uint256 amount 
470:     ) external onlyRole(NOTIFICATION_SENDER) returns (uint256) { 
471:         string memory title = "Loan Created Successfully"; 
472:         string memory message = string(abi.encodePacked( 
473:             "Your loan #", 
474:             _toString(loanId), 
475:             " for ", 
476:             _toString(amount / 1e18), 
477:             " tokens has been created and is now active." 
478:         )); 
479:          
480:         bytes memory data = abi.encode(loanId, amount); 
481:          
482:         return sendNotification( 
483:             borrower, 
484:             NotificationType.LOAN_CREATED, 
485:             Priority.MEDIUM, 
486:             title, 
487:             message, 
488:             data 
489:         ); 
490:     } 
491:      
492:     function sendRepaymentDueNotification( 
493:         address borrower, 
494:         uint256 loanId, 
495:         uint256 dueAmount, 
496:         uint256 dueDate 
497:     ) external onlyRole(NOTIFICATION_SENDER) returns (uint256) { 
498:         string memory title = "Loan Repayment Due"; 
499:         string memory message = string(abi.encodePacked( 
500:             "Reminder: Payment for loan #", 
501:             _toString(loanId), 
502:             " of ", 
503:             _toString(dueAmount / 1e18), 
504:             " tokens is due on ", 
505:             _timestampToString(dueDate) 
506:         )); 
507:          
508:         bytes memory data = abi.encode(loanId, dueAmount, dueDate); 
509:          
510:         return sendNotification( 
511:             borrower, 
512:             NotificationType.LOAN_REPAYMENT_DUE, 
513:             Priority.HIGH, 
514:             title, 
515:             message, 
516:             data 
517:         ); 
518:     } 
519:      
520:     function sendGovernanceProposalNotification( 
521:         address voter, 
522:         uint256 proposalId, 
523:         string memory proposalTitle 
524:     ) external onlyRole(NOTIFICATION_SENDER) returns (uint256) { 
525:         string memory title = "New Governance Proposal"; 
526:         string memory message = string(abi.encodePacked( 
527:             "A new proposal #", 
528:             _toString(proposalId), 
529:             ": ", 
530:             proposalTitle, 
531:             " is available for voting." 
532:         )); 
533:          
534:         bytes memory data = abi.encode(proposalId); 
535:          
536:         return sendNotification( 
537:             voter, 
538:             NotificationType.GOVERNANCE_PROPOSAL, 
539:             Priority.MEDIUM, 
540:             title, 
541:             message, 
542:             data 
543:         ); 
544:     } 
545:      
546:     // Fonctions utilitaires 
547:     function _toString(uint256 value) private pure returns (string memory) { 
548:         if (value == 0) return "0"; 
549:          
550:         uint256 temp = value; 
551:         uint256 digits; 
552:         while (temp = 0) { 
553:             digits++; 
554:             temp /= 10; 
555:         } 
556:          
557:         bytes memory buffer = new bytes(digits); 
558:         while (value = 0) { 
559:             digits -= 1; 
560:             buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); 
561:             value /= 10; 
562:         } 
563:          
564:         return string(buffer); 
565:     } 
566:      
567:     function _timestampToString(uint256 timestamp) private pure returns (string memory) { 
568:         // Conversion simplifiée de timestamp en date 
569:         // En production, utiliser une bibliothèque plus complète 
570:         return string(abi.encodePacked( 
571:             _toString((timestamp / 86400) % 30 + 1), // Jour 
572:             "/", 
573:             _toString((timestamp / 2592000) % 12 + 1), // Mois 
574:             "/", 
575:             _toString(1970 + timestamp / 31536000) // Année 
576:         )); 
577:     } 
578: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol"; 
4: contract OracleAdapter { 
5:     // Sources d'oracle 
6:     struct OracleSource { 
7:         address aggregator; 
8:         uint256 weight; 
9:         bool isActive; 
10:     } 
11:      
12:     // Données des oracles 
13:     mapping(address => OracleSource[]) public priceOracles; 
14:     mapping(string => address) public oracleFeeds; 
15:      
16:     // Paramètres 
17:     uint256 public minimumSources = 2; 
18:     uint256 public deviationThreshold = 5; // 5% 
19:      
20:     // Événements 
21:     event PriceUpdated( 
22:         address indexed token, 
23:         uint256 price, 
24:         uint256 timestamp, 
25:         uint256 sourceCount 
26:     ); 
27:      
28:     event OracleAdded( 
29:         address indexed token, 
30:         address aggregator, 
31:         uint256 weight 
32:     ); 
33:      
34:     constructor() { 
35:         // Initialisation avec des sources par défaut 
36:         _initializeDefaultOracles(); 
37:     } 
38:      
39:     // Initialisation des oracles par défaut 
40:     function _initializeDefaultOracles() private { 
41:         // ETH/USD 
42:         _addOracleSource( 
43:             address(0), // Native token 
44:             0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419, // Chainlink ETH/USD 
45:             1000 
46:         ); 
47:          
48:         // BTC/USD 
49:         _addOracleSource( 
50:             0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC 
51:             0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c, // Chainlink BTC/USD 
52:             1000 
53:         ); 
54:          
55:         // USDC/USD 
56:         _addOracleSource( 
57:             0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, // USDC 
58:             0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6, // Chainlink USDC/USD 
59:             1000 
60:         ); 
61:     } 
62:      
63:     // Ajouter une source d'oracle 
64:     function addOracleSource( 
65:         address token, 
66:         address aggregator, 
67:         uint256 weight 
68:     ) external { 
69:         require(weight > 0 && weight <= 1000, "Invalid weight"); 
70:          
71:         _addOracleSource(token, aggregator, weight); 
72:          
73:         emit OracleAdded(token, aggregator, weight); 
74:     } 
75:      
76:     function _addOracleSource( 
77:         address token, 
78:         address aggregator, 
79:         uint256 weight 
80:     ) private { 
81:         priceOracles[token].push(OracleSource({ 
82:             aggregator: aggregator, 
83:             weight: weight, 
84:             isActive: true 
85:         })); 
86:          
87:         // Mapper le nom du feed 
88:         string memory feedName = _getFeedName(token, aggregator); 
89:         oracleFeeds[feedName] = aggregator; 
90:     } 
91:      
92:     // Obtenir le prix d'un token 
93:     function getPrice(address token) public view returns (uint256) { 
94:         OracleSource[] storage sources = priceOracles[token]; 
95:         require(sources.length >= minimumSources, "Insufficient sources"); 
96:          
97:         uint256[] memory prices = new uint256[](sources.length); 
98:         uint256[] memory timestamps = new uint256[](sources.length); 
99:         uint256 totalWeight = 0; 
100:         uint256 activeCount = 0; 
101:          
102:         // Collecter les prix de toutes les sources actives 
103:         for (uint256 i = 0; i < sources.length; i++) { 
104:             if (sources[i].isActive) continue; 
105:              
106:             try AggregatorV3Interface(sources[i].aggregator).latestRoundData() 
107:                 returns (uint80, int256 price, uint256, uint256 timestamp, uint80) 
108:             { 
109:                 if (price <= 0) continue; 
110:                  
111:                 prices[activeCount] = uint256(price); 
112:                 timestamps[activeCount] = timestamp; 
113:                 totalWeight += sources[i].weight; 
114:                 activeCount++; 
115:             } catch { 
116:                 continue; 
117:             } 
118:         } 
119:          
120:         require(activeCount >= minimumSources, "Not enough valid sources"); 
121:          
122:         // Vérifier les déviations 
123:         _checkDeviations(prices, activeCount); 
124:          
125:         // Calculer le prix médian pondéré 
126:         return _calculateWeightedMedian(prices, sources, activeCount, totalWeight); 
127:     } 
128:      
129:     // Obtenir la valeur en USD 
130:     function getValueInUSD(address token, uint256 amount) external view returns (uint256) { 
131:         if (token == address(0)) { 
132:             // Token natif (ETH) 
133:             uint256 price = getPrice(address(0)); 
134:             return (amount * price) / 1e18; 
135:         } else { 
136:             uint256 price = getPrice(token); 
137:             // Supposer 18 décimales pour les tokens ERC20 
138:             return (amount * price) / 1e18; 
139:         } 
140:     } 
141:      
142:     // Obtenir l'indice de volatilité 
143:     function getVolatilityIndex() external view returns (uint256) { 
144:         // Simuler un indice de volatilité 
145:         // En production, intégrer avec des oracles de volatilité 
146:         return 4500; // 45% en base 10000 
147:     } 
148:      
149:     // Obtenir l'indice de liquidité 
150:     function getLiquidityIndex() external view returns (uint256) { 
151:         // Simuler un indice de liquidité 
152:         return 7500; // 75% 
153:     } 
154:      
155:     // Obtenir le taux de défaut 
156:     function getDefaultRate() external view returns (uint256) { 
157:         // Simuler un taux de défaut 
158:         return 250; // 2.5% 
159:     } 
160:      
161:     // Obtenir le taux d'intérêt 
162:     function getInterestRate() external view returns (uint256) { 
163:         // Simuler le taux d'intérêt 
164:         return 350; // 3.5% 
165:     } 
166:      
167:     // Vérifier les déviations entre les sources 
168:     function _checkDeviations(uint256[] memory prices, uint256 count) private pure { 
169:         if (count < 2) return; 
170:          
171:         uint256 sum = 0; 
172:         for (uint256 i = 0; i < count; i++) { 
173:             sum += prices[i]; 
174:         } 
175:         uint256 average = sum / count; 
176:          
177:         for (uint256 i = 0; i < count; i++) { 
178:             uint256 deviation = (prices[i] > average ?  
179:                 prices[i] - average : average - prices[i]) * 10000 / average; 
180:              
181:             require(deviation <= 500, "Excessive deviation"); // 5% 
182:         } 
183:     } 
184:      
185:     // Calculer la médiane pondérée 
186:     function _calculateWeightedMedian( 
187:         uint256[] memory prices, 
188:         OracleSource[] storage sources, 
189:         uint256 count, 
190:         uint256 totalWeight 
191:     ) private view returns (uint256) { 
192:         // Tri des prix (algorithme de tri à bulles simple) 
193:         for (uint256 i = 0; i < count - 1; i++) { 
194:             for (uint256 j = 0; j < count - i - 1; j++) { 
195:                 if (prices[j] > prices[j + 1]) { 
196:                     (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]); 
197:                 } 
198:             } 
199:         } 
200:          
201:         // Trouver la médiane pondérée 
202:         uint256 halfWeight = totalWeight / 2; 
203:         uint256 cumulativeWeight = 0; 
204:          
205:         for (uint256 i = 0; i < count; i++) { 
206:             cumulativeWeight += _getWeightForPrice(sources, prices[i]); 
207:              
208:             if (cumulativeWeight >= halfWeight) { 
209:                 return prices[i]; 
210:             } 
211:         } 
212:          
213:         return prices[count - 1]; 
214:     } 
215:      
216:     // Obtenir le poids pour un prix donné 
217:     function _getWeightForPrice( 
218:         OracleSource[] storage sources, 
219:         uint256 price 
220:     ) private view returns (uint256) { 
221:         // Pour simplifier, retourner un poids moyen 
222:         // En production, mapper le prix à la source appropriée 
223:         uint256 totalWeight = 0; 
224:         uint256 count = 0; 
225:          
226:         for (uint256 i = 0; i < sources.length; i++) { 
227:             if (sources[i].isActive) { 
228:                 totalWeight += sources[i].weight; 
229:                 count++; 
230:             } 
231:         } 
232:          
233:         return count > 0 ? totalWeight / count : 1000; 
234:     } 
235:      
236:     // Générer un nom de feed 
237:     function _getFeedName(address token, address aggregator) private pure returns (string memory) { 
238:         return string(abi.encodePacked( 
239:             _addressToString(token), 
240:             "-", 
241:             _addressToString(aggregator) 
242:         )); 
243:     } 
244:      
245:     // Convertir une adresse en string 
246:     function _addressToString(address addr) private pure returns (string memory) { 
247:         bytes32 value = bytes32(uint256(uint160(addr))); 
248:         bytes memory alphabet = "0123456789abcdef"; 
249:         bytes memory str = new bytes(42); 
250:         str[0] = '0'; 
251:         str[1] = 'x'; 
252:          
253:         for (uint256 i = 0; i < 20; i++) { 
254:             str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)]; 
255:             str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)]; 
256:         } 
257:          
258:         return string(str); 
259:     } 
260:      
261:     // Getters 
262:     function getOracleCount(address token) external view returns (uint256) { 
263:         return priceOracles[token].length; 
264:     } 
265:      
266:     function getOracleDetails(address token, uint256 index) external view returns ( 
267:         address aggregator, 
268:         uint256 weight, 
269:         bool isActive 
270:     ) { 
271:         require(index < priceOracles[token].length, "Invalid index"); 
272:          
273:         OracleSource memory source = priceOracles[token][index]; 
274:         return (source.aggregator, source.weight, source.isActive); 
275:     } 
276: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
4: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
5: import "@openzeppelin/contracts/utils/Pausable.sol"; 
6: import "@openzeppelin/contracts/access/AccessControl.sol"; 
7: contract DecentralizedGuaranteeFund is ReentrancyGuard, AccessControl { 
8:     // Structures de données 
9:     struct FundTier { 
10:         uint256 tierId; 
11:         string name; 
12:         uint256 minDeposit; 
13:         uint256 maxDeposit; 
14:         uint256 targetAPY; 
15:         uint256 riskLevel; // 0-1000 
16:         uint256 allocationPercentage; 
17:         bool isActive; 
18:     } 
19:      
20:     struct InvestorPosition { 
21:         address investor; 
22:         uint256 tierId; 
23:         uint256 depositedAmount; 
24:         uint256 shares; 
25:         uint256 entryTime; 
26:         uint256 lastClaimTime; 
27:         uint256 claimedRewards; 
28:         uint256 lockedUntil; 
29:     } 
30:      
31:     struct LossCoverage { 
32:         uint256 coverageId; 
33:         uint256 loanId; 
34:         uint256 lossAmount; 
35:         uint256 coveredAmount; 
36:         uint256 coverageTime; 
37:         address[] coveringInvestors; 
38:         uint256[] coveringAmounts; 
39:     } 
40:      
41:     // Variables d'état 
42:     FundTier[] public fundTiers; 
43:     mapping(address => InvestorPosition[]) public investorPositions; 
44:     mapping(uint256 => LossCoverage) public lossCoverages; 
45:      
46:     uint256 public totalFundAssets; 
47:     uint256 public totalCoveredLosses; 
48:     uint256 public totalInvestorRewards; 
49:     uint256 public coverageReserveRatio = 2000; // 20% 
50:     uint256 public minLockupPeriod = 30 days; 
51:      
52:     address public loanPool; 
53:     IERC20 public fundToken; 
54:      
55:     // Événements 
56:     event TierCreated( 
57:         uint256 indexed tierId, 
58:         string name, 
59:         uint256 minDeposit, 
60:         uint256 targetAPY, 
61:         uint256 riskLevel 
62:     ); 
63:      
64:     event DepositMade( 
65:         address indexed investor, 
66:         uint256 indexed tierId, 
67:         uint256 amount, 
68:         uint256 shares, 
69:         uint256 lockedUntil 
70:     ); 
71:      
72:     event LossCovered( 
73:         uint256 indexed coverageId, 
74:         uint256 indexed loanId, 
75:         uint256 lossAmount, 
76:         uint256 coveredAmount, 
77:         uint256 timestamp 
78:     ); 
79:      
80:     event RewardClaimed( 
81:         address indexed investor, 
82:         uint256 amount, 
83:         uint256 timestamp 
84:     ); 
85:      
86:     event WithdrawalMade( 
87:         address indexed investor, 
88:         uint256 tierId, 
89:         uint256 amount, 
90:         uint256 timestamp 
91:     ); 
92:      
93:     // Rôles 
94:     bytes32 public constant FUND_MANAGER = keccak256("FUND_MANAGER"); 
95:     bytes32 public constant RISK_MANAGER = keccak256("RISK_MANAGER"); 
96:      
97:     constructor(address _loanPool, address _fundToken) { 
98:         loanPool = _loanPool; 
99:         fundToken = IERC20(_fundToken); 
100:          
101:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
102:         _grantRole(FUND_MANAGER, msg.sender); 
103:         _grantRole(RISK_MANAGER, msg.sender); 
104:          
105:         // Initialisation des tiers par défaut 
106:         _initializeTiers(); 
107:     } 
108:      
109:     // Initialisation des tiers 
110:     function _initializeTiers() private { 
111:         // Tier 1: Bas risque, faible rendement 
112:         fundTiers.push(FundTier({ 
113:             tierId: 0, 
114:             name: "Conservative", 
115:             minDeposit: 1000 * 1e18, 
116:             maxDeposit: 100000 * 1e18, 
117:             targetAPY: 500, // 5% 
118:             riskLevel: 200, 
119:             allocationPercentage: 4000, // 40% 
120:             isActive: true 
121:         })); 
122:          
123:         // Tier 2: Risque moyen, rendement moyen 
124:         fundTiers.push(FundTier({ 
125:             tierId: 1, 
126:             name: "Balanced", 
127:             minDeposit: 5000 * 1e18, 
128:             maxDeposit: 500000 * 1e18, 
129:             targetAPY: 1000, // 10% 
130:             riskLevel: 500, 
131:             allocationPercentage: 3000, // 30% 
132:             isActive: true 
133:         })); 
134:          
135:         // Tier 3: Haut risque, haut rendement 
136:         fundTiers.push(FundTier({ 
137:             tierId: 2, 
138:             name: "Growth", 
139:             minDeposit: 10000 * 1e18, 
140:             maxDeposit: 1000000 * 1e18, 
141:             targetAPY: 1500, // 15% 
142:             riskLevel: 800, 
143:             allocationPercentage: 2000, // 20% 
144:             isActive: true 
145:         })); 
146:          
147:         // Tier 4: Très haut risque, très haut rendement 
148:         fundTiers.push(FundTier({ 
149:             tierId: 3, 
150:             name: "Aggressive", 
151:             minDeposit: 50000 * 1e18, 
152:             maxDeposit: 5000000 * 1e18, 
153:             targetAPY: 2500, // 25% 
154:             riskLevel: 950, 
155:             allocationPercentage: 1000, // 10% 
156:             isActive: true 
157:         })); 
158:     } 
159:      
160:     // Dépôt dans le fonds 
161:     function deposit(uint256 tierId, uint256 amount) external nonReentrant { 
162:         require(tierId < fundTiers.length, "Invalid tier"); 
163:         require(fundTiers[tierId].isActive, "Tier inactive"); 
164:          
165:         FundTier memory tier = fundTiers[tierId]; 
166:         require(amount >= tier.minDeposit, "Below minimum"); 
167:         require(amount <= tier.maxDeposit, "Above maximum"); 
168:          
169:         // Vérifier les allocations disponibles 
170:         uint256 tierAssets = _getTierAssets(tierId); 
171:         uint256 maxTierAllocation = (totalFundAssets * tier.allocationPercentage) / 10000; 
172:          
173:         require( 
174:             tierAssets + amount <= maxTierAllocation, 
175:             "Tier allocation exceeded" 
176:         ); 
177:          
178:         // Transfert des tokens 
179:         require( 
180:             fundToken.transferFrom(msg.sender, address(this), amount), 
181:             "Transfer failed" 
182:         ); 
183:          
184:         // Calcul des parts 
185:         uint256 shares = _calculateShares(amount, tierId); 
186:          
187:         // Création de la position 
188:         investorPositions[msg.sender].push(InvestorPosition({ 
189:             investor: msg.sender, 
190:             tierId: tierId, 
191:             depositedAmount: amount, 
192:             shares: shares, 
193:             entryTime: block.timestamp, 
194:             lastClaimTime: block.timestamp, 
195:             claimedRewards: 0, 
196:             lockedUntil: block.timestamp + minLockupPeriod 
197:         })); 
198:          
199:         // Mise à jour des totaux 
200:         totalFundAssets += amount; 
201:          
202:         emit DepositMade( 
203:             msg.sender, 
204:             tierId, 
205:             amount, 
206:             shares, 
207:             block.timestamp + minLockupPeriod 
208:         ); 
209:     } 
210:      
211:     // Couverture d'une perte 
212:     function coverLoss( 
213:         uint256 loanId, 
214:         uint256 lossAmount, 
215:         uint256 trancheId 
216:     ) external onlyRole(RISK_MANAGER) nonReentrant returns (uint256) { 
217:         require(lossAmount > 0, "Invalid loss amount"); 
218:         require(lossAmount <= _getCoverableAmount(), "Insufficient coverage capacity"); 
219:          
220:         // Détermination du montant à couvrir 
221:         uint256 coveredAmount = (lossAmount * coverageReserveRatio) / 10000; 
222:          
223:         // Allocation de la couverture par tier 
224:         (uint256[] memory tierAllocations, address[][] memory coveringInvestors) =  
225:             _allocateCoverage(coveredAmount, trancheId); 
226:          
227:         // Création de l'enregistrement de couverture 
228:         uint256 coverageId = _createCoverageRecord( 
229:             loanId, 
230:             lossAmount, 
231:             coveredAmount, 
232:             coveringInvestors, 
233:             tierAllocations 
234:         ); 
235:          
236:         // Déduction des montants des positions des investisseurs 
237:         _deductFromInvestors(coveringInvestors, tierAllocations); 
238:          
239:         // Mise à jour des totaux 
240:         totalCoveredLosses += coveredAmount; 
241:         totalFundAssets -= coveredAmount; 
242:          
243:         emit LossCovered(coverageId, loanId, lossAmount, coveredAmount, block.timestamp); 
244:          
245:         return coveredAmount; 
246:     } 
247:      
248:     // Réclamation des récompenses 
249:     function claimRewards(uint256 positionIndex) external nonReentrant { 
250:         require(positionIndex < investorPositions[msg.sender].length, "Invalid position"); 
251:          
252:         InvestorPosition storage position = investorPositions[msg.sender][positionIndex]; 
253:         require(block.timestamp >= position.entryTime + 7 days, "Too early to claim"); 
254:          
255:         // Calcul des récompenses accumulées 
256:         uint256 rewards = _calculateAccruedRewards(position); 
257:         require(rewards > 0, "No rewards available"); 
258:          
259:         // Vérifier que le fonds a suffisamment de liquidités 
260:         require(rewards <= _getAvailableRewards(), "Insufficient reward liquidity"); 
261:          
262:         // Transfert des récompenses 
263:         require(fundToken.transfer(msg.sender, rewards), "Transfer failed"); 
264:          
265:         // Mise à jour de la position 
266:         position.lastClaimTime = block.timestamp; 
267:         position.claimedRewards += rewards; 
268:         totalInvestorRewards += rewards; 
269:          
270:         emit RewardClaimed(msg.sender, rewards, block.timestamp); 
271:     } 
272:      
273:     // Retrait du capital 
274:     function withdraw(uint256 positionIndex, uint256 amount) external nonReentrant { 
275:         require(positionIndex < investorPositions[msg.sender].length, "Invalid position"); 
276:          
277:         InvestorPosition storage position = investorPositions[msg.sender][positionIndex]; 
278:          
279:         require(block.timestamp >= position.lockedUntil, "Still locked"); 
280:         require(amount <= position.depositedAmount, "Exceeds deposited amount"); 
281:         require(amount <= _getWithdrawableAmount(position), "Exceeds withdrawable amount"); 
282:          
283:         // Calcul des parts à retirer 
284:         uint256 sharesToWithdraw = (position.shares * amount) / position.depositedAmount; 
285:          
286:         // Transfert des tokens 
287:         require(fundToken.transfer(msg.sender, amount), "Transfer failed"); 
288:          
289:         // Mise à jour de la position 
290:         position.depositedAmount -= amount; 
291:         position.shares -= sharesToWithdraw; 
292:         totalFundAssets -= amount; 
293:          
294:         // Si la position est vide, la supprimer 
295:         if (position.depositedAmount == 0) { 
296:             _removePosition(msg.sender, positionIndex); 
297:         } 
298:          
299:         emit WithdrawalMade(msg.sender, position.tierId, amount, block.timestamp); 
300:     } 
301:      
302:     // Création d'un nouveau tier 
303:     function createTier( 
304:         string memory name, 
305:         uint256 minDeposit, 
306:         uint256 maxDeposit, 
307:         uint256 targetAPY, 
308:         uint256 riskLevel, 
309:         uint256 allocationPercentage 
310:     ) external onlyRole(FUND_MANAGER) { 
311:         require(allocationPercentage <= 10000, "Invalid allocation"); 
312:          
313:         uint256 tierId = fundTiers.length; 
314:          
315:         fundTiers.push(FundTier({ 
316:             tierId: tierId, 
317:             name: name, 
318:             minDeposit: minDeposit, 
319:             maxDeposit: maxDeposit, 
320:             targetAPY: targetAPY, 
321:             riskLevel: riskLevel, 
322:             allocationPercentage: allocationPercentage, 
323:             isActive: true 
324:         })); 
325:          
326:         emit TierCreated(tierId, name, minDeposit, targetAPY, riskLevel); 
327:     } 
328:      
329:     // Fonctions internes 
330:     function _calculateShares(uint256 amount, uint256 tierId) private view returns (uint256) { 
331:         // Les parts sont proportionnelles au dépôt ajusté par le risque du tier 
332:         uint256 riskFactor = fundTiers[tierId].riskLevel; 
333:         return (amount * (1000 + riskFactor)) / 1000; 
334:     } 
335:      
336:     function _getTierAssets(uint256 tierId) private view returns (uint256) { 
337:         uint256 total = 0; 
338:         // À implémenter: calculer le total des actifs dans ce tier 
339:         return total; 
340:     } 
341:      
342:     function _getCoverableAmount() private view returns (uint256) { 
343:         return (totalFundAssets * coverageReserveRatio) / 10000; 
344:     } 
345:      
346:     function _allocateCoverage( 
347:         uint256 coveredAmount, 
348:         uint256 trancheId 
349:     ) private returns (uint256[] memory, address[][] memory) { 
350:         // Logique d'allocation complexe basée sur les tiers et le risque 
351:         // À implémenter: algorithme d'allocation optimale 
352:          
353:         uint256[] memory tierAllocations = new uint256[](fundTiers.length); 
354:         address[][] memory coveringInvestors = new address[][](fundTiers.length); 
355:          
356:         // Pour l'instant, répartition proportionnelle simple 
357:         for (uint256 i = 0; i < fundTiers.length; i++) { 
358:             tierAllocations[i] = (coveredAmount * fundTiers[i].allocationPercentage) / 10000; 
359:             coveringInvestors[i] = _selectInvestorsForCoverage(i, tierAllocations[i]); 
360:         } 
361:          
362:         return (tierAllocations, coveringInvestors); 
363:     } 
364:      
365:     function _createCoverageRecord( 
366:         uint256 loanId, 
367:         uint256 lossAmount, 
368:         uint256 coveredAmount, 
369:         address[][] memory coveringInvestors, 
370:         uint256[] memory tierAllocations 
371:     ) private returns (uint256) { 
372:         uint256 coverageId = uint256(keccak256(abi.encodePacked( 
373:             loanId, 
374:             block.timestamp, 
375:             lossAmount 
376:         ))); 
377:          
378:         // Aplatir la liste des investisseurs 
379:         address[] memory allInvestors; 
380:         uint256[] memory allAmounts; 
381:          
382:         // À implémenter: construction des listes aplaties 
383:          
384:         lossCoverages[coverageId] = LossCoverage({ 
385:             coverageId: coverageId, 
386:             loanId: loanId, 
387:             lossAmount: lossAmount, 
388:             coveredAmount: coveredAmount, 
389:             coverageTime: block.timestamp, 
390:             coveringInvestors: allInvestors, 
391:             coveringAmounts: allAmounts 
392:         }); 
393:          
394:         return coverageId; 
395:     } 
396:      
397:     function _deductFromInvestors( 
398:         address[][] memory coveringInvestors, 
399:         uint256[] memory tierAllocations 
400:     ) private { 
401:         // À implémenter: déduction des montants des positions des investisseurs 
402:     } 
403:      
404:     function _calculateAccruedRewards(InvestorPosition memory position) private view returns (uint256) { 
405:         FundTier memory tier = fundTiers[position.tierId]; 
406:          
407:         uint256 timeSinceLastClaim = block.timestamp - position.lastClaimTime; 
408:         uint256 annualReward = (position.depositedAmount * tier.targetAPY) / 10000; 
409:         uint256 accruedReward = (annualReward * timeSinceLastClaim) / 365 days; 
410:          
411:         return accruedReward; 
412:     } 
413:      
414:     function _getAvailableRewards() private view returns (uint256) { 
415:         // Les récompenses sont payées à partir des revenus du fonds 
416:         return fundToken.balanceOf(address(this)) - totalFundAssets; 
417:     } 
418:      
419:     function _getWithdrawableAmount(InvestorPosition memory position) private view returns (uint256) { 
420:         // Vérifier les pertes couvertes par cette position 
421:         uint256 coveredLosses = _getCoveredLossesForPosition(position); 
422:          
423:         // Le montant retirable est le dépôt moins les pertes couvertes 
424:         if (position.depositedAmount > coveredLosses) { 
425:             return position.depositedAmount - coveredLosses; 
426:         } else { 
427:             return 0; 
428:         } 
429:     } 
430:      
431:     function _getCoveredLossesForPosition(InvestorPosition memory position) private view returns (uint256) { 
432:         // À implémenter: calculer les pertes couvertes par cette position 
433:         return 0; 
434:     } 
435:      
436:     function _removePosition(address investor, uint256 positionIndex) private { 
437:         uint256 lastIndex = investorPositions[investor].length - 1; 
438:          
439:         if (positionIndex = lastIndex) { 
440:             investorPositions[investor][positionIndex] = investorPositions[investor][lastIndex]; 
441:         } 
442:          
443:         investorPositions[investor].pop(); 
444:     } 
445:      
446:     function _selectInvestorsForCoverage(uint256 tierId, uint256 amount) private view returns (address[] memory) { 
447:         // À implémenter: sélectionner les investisseurs pour la couverture 
448:         return new address[](0); 
449:     } 
450:      
451:     // Getters 
452:     function getInvestorPositions(address investor) external view returns (InvestorPosition[] memory) { 
453:         return investorPositions[investor]; 
454:     } 
455:      
456:     function getTierDetails(uint256 tierId) external view returns ( 
457:         string memory name, 
458:         uint256 minDeposit, 
459:         uint256 maxDeposit, 
460:         uint256 targetAPY, 
461:         uint256 riskLevel, 
462:         uint256 allocationPercentage, 
463:         bool isActive 
464:     ) { 
465:         require(tierId < fundTiers.length, "Invalid tier"); 
466:          
467:         FundTier memory tier = fundTiers[tierId]; 
468:         return ( 
469:             tier.name, 
470:             tier.minDeposit, 
471:             tier.maxDeposit, 
472:             tier.targetAPY, 
473:             tier.riskLevel, 
474:             tier.allocationPercentage, 
475:             tier.isActive 
476:         ); 
477:     } 
478:      
479:     function getFundStats() external view returns ( 
480:         uint256 totalAssets, 
481:         uint256 coveredLosses, 
482:         uint256 investorRewards, 
483:         uint256 coverageCapacity, 
484:         uint256 availableRewards 
485:     ) { 
486:         return ( 
487:             totalFundAssets, 
488:             totalCoveredLosses, 
489:             totalInvestorRewards, 
490:             _getCoverableAmount(), 
491:             _getAvailableRewards() 
492:         ); 
493:     } 
494:      
495:     function calculateProjectedAPY(address investor, uint256 positionIndex) external view returns (uint256) { 
496:         require(positionIndex < investorPositions[investor].length, "Invalid position"); 
497:          
498:         InvestorPosition memory position = investorPositions[investor][positionIndex]; 
499:         FundTier memory tier = fundTiers[position.tierId]; 
500:          
501:         // APY projeté basé sur le tier, ajusté par la performance du fonds 
502:         uint256 baseAPY = tier.targetAPY; 
503:         uint256 performanceAdjustment = _calculatePerformanceAdjustment(); 
504:          
505:         return baseAPY + performanceAdjustment; 
506:     } 
507:      
508:     function _calculatePerformanceAdjustment() private view returns (uint256) { 
509:         // À implémenter: calcul de l'ajustement basé sur la performance 
510:         return 0; 
511:     } 
512: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
4: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
5: import "../security/AccessController.sol"; 
6: contract InsuranceModule is ReentrancyGuard { 
7:     // Structures de données 
8:     struct InsurancePolicy { 
9:         uint256 policyId; 
10:         uint256 loanId; 
11:         address insured; 
12:         uint256 coverageAmount; 
13:         uint256 premiumAmount; 
14:         uint256 coveragePercentage; 
15:         uint256 startTime; 
16:         uint256 endTime; 
17:         PolicyStatus status; 
18:         address insurer; 
19:         uint256 claimAmount; 
20:         uint256 claimTime; 
21:     } 
22:      
23:     struct InsurerPool { 
24:         address insurer; 
25:         uint256 totalCapital; 
26:         uint256 allocatedCapital; 
27:         uint256 availableCapital; 
28:         uint256 totalPremiums; 
29:         uint256 totalClaims; 
30:         uint256 performanceScore; 
31:         bool isActive; 
32:     } 
33:      
34:     // Types et statuts 
35:     enum PolicyStatus { ACTIVE, EXPIRED, CLAIMED, CANCELLED } 
36:     enum CoverageType { FULL, PARTIAL, EXCESS_LOSS } 
37:      
38:     // Variables d'état 
39:     mapping(uint256 => InsurancePolicy) public policies; 
40:     mapping(address => uint256[]) public userPolicies; 
41:     mapping(address => InsurerPool) public insurerPools; 
42:      
43:     uint256 public totalPolicies; 
44:     uint256 public totalCoverage; 
45:     uint256 public totalPremiums; 
46:     uint256 public totalClaimsPaid; 
47:      
48:     // Paramètres d'assurance 
49:     uint256 public basePremiumRate = 200; // 2% 
50:     uint256 public riskMultiplier = 1000; // 10x 
51:     uint256 public minCoveragePercentage = 5000; // 50% 
52:     uint256 public maxCoveragePercentage = 9000; // 90% 
53:     uint256 public insurerCapitalRequirement = 10000 * 1e18; // 10,000 tokens 
54:      
55:     // Contrats liés 
56:     AccessController public accessController; 
57:     address public loanPool; 
58:      
59:     // Événements 
60:     event PolicyCreated( 
61:         uint256 indexed policyId, 
62:         uint256 indexed loanId, 
63:         address indexed insured, 
64:         uint256 coverageAmount, 
65:         uint256 premiumAmount, 
66:         uint256 coveragePercentage 
67:     ); 
68:      
69:     event ClaimFiled( 
70:         uint256 indexed policyId, 
71:         uint256 indexed loanId, 
72:         address claimant, 
73:         uint256 claimAmount, 
74:         uint256 timestamp 
75:     ); 
76:      
77:     event ClaimPaid( 
78:         uint256 indexed policyId, 
79:         address insurer, 
80:         uint256 payoutAmount, 
81:         uint256 timestamp 
82:     ); 
83:      
84:     event InsurerRegistered( 
85:         address indexed insurer, 
86:         uint256 capitalDeposited, 
87:         uint256 timestamp 
88:     ); 
89:      
90:     // Modificateurs 
91:     modifier onlyLoanPool() { 
92:         require(msg.sender == loanPool, "Only LoanPool"); 
93:         _; 
94:     } 
95:      
96:     modifier onlyInsurer() { 
97:         require(insurerPools[msg.sender].isActive, "Not active insurer"); 
98:         _; 
99:     } 
100:      
101:     constructor(address _accessController) { 
102:         accessController = AccessController(_accessController); 
103:     } 
104:      
105:     // Configuration du LoanPool 
106:     function setLoanPool(address _loanPool) external { 
107:         require( 
108:             accessController.hasRole(msg.sender, "ADMIN"), 
109:             "Not authorized" 
110:         ); 
111:         loanPool = _loanPool; 
112:     } 
113:      
114:     // Vérification d'éligibilité pour l'assurance 
115:     function checkEligibility( 
116:         uint256 loanId, 
117:         uint256 riskScore, 
118:         uint256 loanAmount 
119:     ) public view returns (bool eligible, uint256 premium, uint256 coverage) { 
120:         // Vérifications de base 
121:         if (riskScore > 800) { // Risque trop élevé 
122:             return (false, 0, 0); 
123:         } 
124:          
125:         if (loanAmount > 1000000 * 1e18) { // Montant trop élevé 
126:             return (false, 0, 0); 
127:         } 
128:          
129:         // Calcul de la prime 
130:         premium = _calculatePremium(riskScore, loanAmount); 
131:          
132:         // Pourcentage de couverture basé sur le risque 
133:         coverage = _calculateCoveragePercentage(riskScore); 
134:          
135:         // Vérifier qu'il y a assez de capital d'assurance disponible 
136:         uint256 requiredCapital = (loanAmount * coverage) / 10000; 
137:         if (_getAvailableInsuranceCapital() < requiredCapital) { 
138:             return (false, 0, 0); 
139:         } 
140:          
141:         return (true, premium, coverage); 
142:     } 
143:      
144:     // Création d'une police d'assurance 
145:     function createPolicy( 
146:         uint256 loanId, 
147:         address borrower, 
148:         uint256 loanAmount, 
149:         uint256 riskScore, 
150:         uint256 duration 
151:     ) external onlyLoanPool nonReentrant returns (uint256) { 
152:         (bool eligible, uint256 premium, uint256 coverage) =  
153:             checkEligibility(loanId, riskScore, loanAmount); 
154:          
155:         require(eligible, "Not eligible for insurance"); 
156:          
157:         // Allocation à un pool d'assureurs 
158:         address insurer = _allocateToInsurer(loanAmount, coverage, riskScore); 
159:         require(insurer = address(0), "No insurer available"); 
160:          
161:         // Création de la police 
162:         uint256 policyId = ++totalPolicies; 
163:         uint256 coverageAmount = (loanAmount * coverage) / 10000; 
164:          
165:         policies[policyId] = InsurancePolicy({ 
166:             policyId: policyId, 
167:             loanId: loanId, 
168:             insured: borrower, 
169:             coverageAmount: coverageAmount, 
170:             premiumAmount: premium, 
171:             coveragePercentage: coverage, 
172:             startTime: block.timestamp, 
173:             endTime: block.timestamp + duration, 
174:             status: PolicyStatus.ACTIVE, 
175:             insurer: insurer, 
176:             claimAmount: 0, 
177:             claimTime: 0 
178:         }); 
179:          
180:         userPolicies[borrower].push(policyId); 
181:          
182:         // Mise à jour des statistiques 
183:         totalCoverage += coverageAmount; 
184:         totalPremiums += premium; 
185:          
186:         // Allocation du capital de l'assureur 
187:         insurerPools[insurer].allocatedCapital += coverageAmount; 
188:         insurerPools[insurer].availableCapital -= coverageAmount; 
189:         insurerPools[insurer].totalPremiums += premium; 
190:          
191:         // Transfert de la prime (doit être approuvé au préalable) 
192:         IERC20 paymentToken = IERC20(_getPaymentToken()); 
193:         require( 
194:             paymentToken.transferFrom(borrower, address(this), premium), 
195:             "Premium transfer failed" 
196:         ); 
197:          
198:         // Distribution de la prime (80% à l'assureur, 20% à la réserve) 
199:         uint256 insurerShare = (premium * 8000) / 10000; 
200:         uint256 reserveShare = premium - insurerShare; 
201:          
202:         paymentToken.transfer(insurer, insurerShare); 
203:         _addToReserve(reserveShare); 
204:          
205:         emit PolicyCreated( 
206:             policyId, 
207:             loanId, 
208:             borrower, 
209:             coverageAmount, 
210:             premium, 
211:             coverage 
212:         ); 
213:          
214:         return policyId; 
215:     } 
216:      
217:     // Traitement d'une réclamation 
218:     function processClaim( 
219:         uint256 loanId, 
220:         uint256 loanAmount, 
221:         uint256 coveragePercentage 
222:     ) external onlyLoanPool nonReentrant returns (uint256) { 
223:         // Trouver la police correspondante 
224:         uint256 policyId = _findPolicyForLoan(loanId); 
225:         require(policyId > 0, "No active policy found"); 
226:          
227:         InsurancePolicy storage policy = policies[policyId]; 
228:         require(policy.status == PolicyStatus.ACTIVE, "Policy not active"); 
229:         require(block.timestamp <= policy.endTime, "Policy expired"); 
230:          
231:         // Calcul du montant de la réclamation 
232:         uint256 claimAmount = (loanAmount * policy.coveragePercentage) / 10000; 
233:          
234:         // Vérifier que l'assureur a suffisamment de capital 
235:         require( 
236:             insurerPools[policy.insurer].availableCapital >= claimAmount, 
237:             "Insurer insufficient capital" 
238:         ); 
239:          
240:         // Mise à jour de la police 
241:         policy.status = PolicyStatus.CLAIMED; 
242:         policy.claimAmount = claimAmount; 
243:         policy.claimTime = block.timestamp; 
244:          
245:         // Paiement de la réclamation 
246:         IERC20 paymentToken = IERC20(_getPaymentToken()); 
247:         require( 
248:             paymentToken.transferFrom(policy.insurer, msg.sender, claimAmount), 
249:             "Claim payment failed" 
250:         ); 
251:          
252:         // Mise à jour des statistiques 
253:         totalClaimsPaid += claimAmount; 
254:         insurerPools[policy.insurer].totalClaims += claimAmount; 
255:          
256:         // Ajustement du score de performance de l'assureur 
257:         _updateInsurerPerformance(policy.insurer, claimAmount); 
258:          
259:         emit ClaimFiled(policyId, loanId, policy.insured, claimAmount, block.timestamp); 
260:         emit ClaimPaid(policyId, policy.insurer, claimAmount, block.timestamp); 
261:          
262:         return claimAmount; 
263:     } 
264:      
265:     // Enregistrement d'un nouvel assureur 
266:     function registerAsInsurer(uint256 capitalAmount) external nonReentrant { 
267:         require(capitalAmount >= insurerCapitalRequirement, "Insufficient capital"); 
268:          
269:         IERC20 paymentToken = IERC20(_getPaymentToken()); 
270:         require( 
271:             paymentToken.transferFrom(msg.sender, address(this), capitalAmount), 
272:             "Capital transfer failed" 
273:         ); 
274:          
275:         insurerPools[msg.sender] = InsurerPool({ 
276:             insurer: msg.sender, 
277:             totalCapital: capitalAmount, 
278:             allocatedCapital: 0, 
279:             availableCapital: capitalAmount, 
280:             totalPremiums: 0, 
281:             totalClaims: 0, 
282:             performanceScore: 1000, // Score initial 
283:             isActive: true 
284:         }); 
285:          
286:         emit InsurerRegistered(msg.sender, capitalAmount, block.timestamp); 
287:     } 
288:      
289:     // Retrait de capital par un assureur 
290:     function withdrawCapital(uint256 amount) external onlyInsurer nonReentrant { 
291:         InsurerPool storage pool = insurerPools[msg.sender]; 
292:          
293:         require(amount <= pool.availableCapital, "Insufficient available capital"); 
294:         require( 
295:             pool.totalCapital - amount >= insurerCapitalRequirement, 
296:             "Below minimum requirement" 
297:         ); 
298:          
299:         pool.totalCapital -= amount; 
300:         pool.availableCapital -= amount; 
301:          
302:         IERC20 paymentToken = IERC20(_getPaymentToken()); 
303:         paymentToken.transfer(msg.sender, amount); 
304:     } 
305:      
306:     // Réassurance: transfert de risque à d'autres assureurs 
307:     function reinsurePolicy(uint256 policyId, uint256 percentage) external onlyInsurer { 
308:         require(percentage > 0 && percentage <= 10000, "Invalid percentage"); 
309:          
310:         InsurancePolicy storage policy = policies[policyId]; 
311:         require(policy.insurer == msg.sender, "Not policy insurer"); 
312:         require(policy.status == PolicyStatus.ACTIVE, "Policy not active"); 
313:          
314:         // Trouver d'autres assureurs pour le risque 
315:         address[] memory reinsurers = _findReinsurers( 
316:             policy.coverageAmount, 
317:             percentage, 
318:             policy.insured 
319:         ); 
320:          
321:         require(reinsurers.length > 0, "No reinsurers found"); 
322:          
323:         // Répartir le risque 
324:         uint256 reinsuredAmount = (policy.coverageAmount * percentage) / 10000; 
325:         uint256 perReinsurer = reinsuredAmount / reinsurers.length; 
326:          
327:         for (uint256 i = 0; i < reinsurers.length; i++) { 
328:             insurerPools[reinsurers[i]].allocatedCapital += perReinsurer; 
329:             insurerPools[reinsurers[i]].availableCapital -= perReinsurer; 
330:              
331:             // Ajuster le capital de l'assureur original 
332:             insurerPools[msg.sender].allocatedCapital -= perReinsurer; 
333:             insurerPools[msg.sender].availableCapital += perReinsurer; 
334:         } 
335:     } 
336:      
337:     // Fonctions internes 
338:     function _calculatePremium(uint256 riskScore, uint256 loanAmount) private view returns (uint256) { 
339:         uint256 basePremium = (loanAmount * basePremiumRate) / 10000; 
340:          
341:         // Ajustement basé sur le risque 
342:         uint256 riskFactor; 
343:         if (riskScore < 300) { 
344:             riskFactor = 500; // 0.5x 
345:         } else if (riskScore < 500) { 
346:             riskFactor = 750; // 0.75x 
347:         } else if (riskScore < 700) { 
348:             riskFactor = 1000; // 1x 
349:         } else { 
350:             riskFactor = 1500; // 1.5x 
351:         } 
352:          
353:         return (basePremium * riskFactor) / 1000; 
354:     } 
355:      
356:     function _calculateCoveragePercentage(uint256 riskScore) private view returns (uint256) { 
357:         if (riskScore < 300) { 
358:             return maxCoveragePercentage; // 90% 
359:         } else if (riskScore < 500) { 
360:             return 8000; // 80% 
361:         } else if (riskScore < 700) { 
362:             return 7000; // 70% 
363:         } else { 
364:             return minCoveragePercentage; // 50% 
365:         } 
366:     } 
367:      
368:     function _allocateToInsurer( 
369:         uint256 loanAmount, 
370:         uint256 coveragePercentage, 
371:         uint256 riskScore 
372:     ) private returns (address) { 
373:         uint256 requiredCapital = (loanAmount * coveragePercentage) / 10000; 
374:          
375:         // Trouver l'assureur avec le meilleur score et assez de capital 
376:         address bestInsurer = address(0); 
377:         uint256 bestScore = 0; 
378:          
379:         // Note: Dans une implémentation réelle, il faudrait un mapping des assureurs 
380:         // Pour cette démo, nous utilisons une approche simplifiée 
381:          
382:         // Vérifier les assureurs enregistrés 
383:         // À implémenter: logique de sélection basée sur le score de performance 
384:          
385:         return bestInsurer  address(this); // Fallback au contrat 
386:     } 
387:      
388:     function _getAvailableInsuranceCapital() private view returns (uint256) { 
389:         uint256 total = 0; 
390:         // À implémenter: sommer le capital disponible de tous les assureurs 
391:         return total; 
392:     } 
393:      
394:     function _findPolicyForLoan(uint256 loanId) private view returns (uint256) { 
395:         // Recherche linéaire (à optimiser pour la production) 
396:         for (uint256 i = 1; i <= totalPolicies; i++) { 
397:             if (policies[i].loanId == loanId && policies[i].status == PolicyStatus.ACTIVE) { 
398:                 return i; 
399:             } 
400:         } 
401:         return 0; 
402:     } 
403:      
404:     function _updateInsurerPerformance(address insurer, uint256 claimAmount) private { 
405:         InsurerPool storage pool = insurerPools[insurer]; 
406:          
407:         // Calcul du ratio sinistres/primes 
408:         uint256 lossRatio = pool.totalPremiums > 0 ?  
409:             (pool.totalClaims * 10000) / pool.totalPremiums : 0; 
410:          
411:         // Ajustement du score 
412:         if (lossRatio < 3000) { // <30% 
413:             pool.performanceScore = pool.performanceScore * 105 / 100; 
414:         } else if (lossRatio > 8000) { // >80% 
415:             pool.performanceScore = pool.performanceScore * 95 / 100; 
416:         } 
417:          
418:         if (pool.performanceScore < 500) { 
419:             pool.isActive = false; // Désactiver les assureurs peu performants 
420:         } 
421:     } 
422:      
423:     function _addToReserve(uint256 amount) private { 
424:         // À implémenter: ajout à la réserve de stabilité 
425:     } 
426:      
427:     function _getPaymentToken() private view returns (address) { 
428:         // À implémenter: récupérer le token de paiement depuis le LoanPool 
429:         return 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC par défaut 
430:     } 
431:      
432:     function _findReinsurers( 
433:         uint256 coverageAmount, 
434:         uint256 percentage, 
435:         address insured 
436:     ) private view returns (address[] memory) { 
437:         // À implémenter: logique de recherche de réassureurs 
438:         return new address[](0); 
439:     } 
440:      
441:     // Getters 
442:     function getUserPolicies(address user) external view returns (uint256[] memory) { 
443:         return userPolicies[user]; 
444:     } 
445:      
446:     function getPolicyDetails(uint256 policyId) external view returns ( 
447:         uint256 loanId, 
448:         address insured, 
449:         uint256 coverageAmount, 
450:         uint256 premiumAmount, 
451:         uint256 coveragePercentage, 
452:         PolicyStatus status, 
453:         address insurer 
454:     ) { 
455:         InsurancePolicy memory policy = policies[policyId]; 
456:         return ( 
457:             policy.loanId, 
458:             policy.insured, 
459:             policy.coverageAmount, 
460:             policy.premiumAmount, 
461:             policy.coveragePercentage, 
462:             policy.status, 
463:             policy.insurer 
464:         ); 
465:     } 
466:      
467:     function getInsurerStats(address insurer) external view returns ( 
468:         uint256 totalCapital, 
469:         uint256 allocatedCapital, 
470:         uint256 availableCapital, 
471:         uint256 premiumsAmount, 
472:         uint256 totalClaims, 
473:         uint256 performanceScore, 
474:         bool isActive 
475:     ) { 
476:         InsurerPool memory pool = insurerPools[insurer]; 
477:         return ( 
478:             pool.totalCapital, 
479:             pool.allocatedCapital, 
480:             pool.availableCapital, 
481:             pool.premiumsAmount, 
482:             pool.totalClaims, 
483:             pool.performanceScore, 
484:             pool.isActive 
485:         ); 
486:     } 
487: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: interface ICriteriaFilter { 
4:     function filterPools( 
5:         string[] memory regions, 
6:         bool ecologicalOnly, 
7:         string[] memory domains, 
8:         uint256 minRate, 
9:         uint256 maxRisk 
10:     ) external view returns (uint256[] memory); 
11: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: interface IInsuranceModule { 
4:     function subscribeCoverage( 
5:         uint256 poolId, 
6:         uint256 coverageAmount, 
7:         uint256 insurancePoolId 
8:     ) external; 
9:      
10:     function fileClaim(uint256 poolId, uint256 claimAmount) external; 
11: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: interface ILoanPool { 
4:     struct PoolData { 
5:         uint256 poolId; 
6:         address borrower; 
7:         string projectName; 
8:         uint256 targetAmount; 
9:         uint256 collectedAmount; 
10:         uint256 baseInterestRate; 
11:         uint256 dynamicInterestRate; 
12:         uint256 duration; 
13:         string region; 
14:         bool isEcological; 
15:         string activityDomain; 
16:         uint256 riskScore; 
17:         uint256 status; 
18:         uint256 createdAt; 
19:     } 
20:      
21:     function getPoolDetails(uint256 poolId) external view returns (PoolData memory); 
22: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: interface IRiskEngine { 
4:     function calculateBaseRate( 
5:         address borrower, 
6:         uint256 amount, 
7:         uint256 duration, 
8:         bool isEcological, 
9:         string calldata activityDomain 
10:     ) external returns (uint256); 
11:      
12:     function calculateRiskScore( 
13:         address borrower, 
14:         uint256 amount, 
15:         uint256 duration, 
16:         string calldata region, 
17:         bool isEcological, 
18:         string calldata activityDomain 
19:     ) external returns (uint256); 
20:      
21:     function validatePool(uint256 poolId) external returns (bool); 
22:      
23:     function adjustRateForMarketConditions( 
24:         uint256 poolId, 
25:         uint256 currentRate 
26:     ) external view returns (uint256); 
27: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: interface ISpecialOfferManager { 
4:     function getActiveOfferForPool(uint256 poolId) external view returns ( 
5:         bool hasOffer, 
6:         uint256 offerId, 
7:         uint256 bonus, 
8:         uint256 endTime 
9:     ); 
10:      
11:     function getOfferDetails(uint256 offerId) external view returns ( 
12:         uint256 bonusRate, 
13:         uint256 endTime 
14:     ); 
15: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: /** 
4:  * @title IStructuredLending - Interface principale du protocole de prêt 
5:  * @notice Interface standardisée pour l'intégration 
6:  */ 
7: interface IStructuredLending { 
8:      
9:     // Structures de données 
10:     struct PoolData { 
11:         uint256 poolId; 
12:         address borrower; 
13:         string projectName; 
14:         uint256 targetAmount; 
15:         uint256 collectedAmount; 
16:         uint256 baseInterestRate; 
17:         uint256 dynamicInterestRate; 
18:         uint256 duration; 
19:         string region; 
20:         bool isEcological; 
21:         string activityDomain; 
22:         uint256 riskScore; 
23:         uint256 status; 
24:         uint256 createdAt; 
25:     } 
26:      
27:     struct InvestmentInfo { 
28:         address investor; 
29:         uint256 amount; 
30:         uint256 tokens; 
31:         uint256 investmentTime; 
32:     } 
33:      
34:     // Événements 
35:     event PoolCreated(uint256 indexed poolId, address indexed borrower); 
36:     event InvestmentMade(uint256 indexed poolId, address indexed investor, uint256 amount); 
37:     event RepaymentMade(uint256 indexed poolId, uint256 amount); 
38:     event PoolCompleted(uint256 indexed poolId); 
39:      
40:     // Fonctions principales 
41:     function createPool( 
42:         string memory projectName, 
43:         uint256 targetAmount, 
44:         uint256 duration, 
45:         string memory region, 
46:         bool isEcological, 
47:         string memory activityDomain, 
48:         string memory ipfsHash 
49:     ) external returns (uint256); 
50:      
51:     function invest(uint256 poolId, uint256 amount) external; 
52:      
53:     function repay(uint256 poolId, uint256 amount) external; 
54:      
55:     function getPoolDetails(uint256 poolId) external view returns (PoolData memory); 
56:      
57:     function getPoolInvestments(uint256 poolId) external view returns (InvestmentInfo[] memory); 
58:      
59:     function calculateDynamicRate(uint256 poolId) external view returns (uint256); 
60:      
61:     // Fonctions d'administration 
62:     function setProtocolFee(uint256 fee) external; 
63:      
64:     function setMinMaxInvestment(uint256 min, uint256 max) external; 
65:      
66:     function emergencyPause(bool paused) external; 
67: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; 
4: /** 
5:  * @title MockERC20 - Token ERC20 mock pour tests 
6:  * @notice Version simplifiée d'un stablecoin (USDC, DAI) pour tests locaux et testnet 
7:  * @dev Inclut des fonctions spéciales pour le testing (mint, burn, etc.) 
8:  */ 
9: contract MockERC20 is ERC20 { 
10:     // Propriétaire du contrat (peut mint/burn) 
11:     address public owner; 
12:      
13:     // Décimals par défaut (18 comme ETH, ou 6 comme USDC) 
14:     uint8 private _decimals; 
15:      
16:     // Événements spéciaux pour tests 
17:     event Minted(address indexed to, uint256 amount); 
18:     event Burned(address indexed from, uint256 amount); 
19:     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); 
20:      
21:     /** 
22:      * @notice Constructeur du MockERC20 
23:      * @param name Nom du token (ex: "Mock USDC") 
24:      * @param symbol Symbole (ex: "mUSDC") 
25:      * @param decimals_ Nombre de décimales (6 pour USDC, 18 pour DAI) 
26:      */ 
27:     constructor( 
28:         string memory name, 
29:         string memory symbol, 
30:         uint8 decimals_ 
31:     ) ERC20(name, symbol) { 
32:         owner = msg.sender; 
33:         _decimals = decimals_; 
34:          
35:         // Mint initial pour le déployeur 
36:         _mint(msg.sender, 1000000 * 10 ** decimals_); 
37:     } 
38:      
39:     /** 
40:      * @notice Retourne le nombre de décimales 
41:      */ 
42:     function decimals() public view virtual override returns (uint8) { 
43:         return _decimals; 
44:     } 
45:      
46:     /** 
47:      * @notice Mint de nouveaux tokens (seulement owner) 
48:      * @dev Pour simuler des faucets ou des dépôts 
49:      */ 
50:     function mint(address to, uint256 amount) external { 
51:         require(msg.sender == owner, "MockERC20: Only owner can mint"); 
52:         require(to  Mint to zero address"); 
53:          
54:         _mint(to, amount); 
55:         emit Minted(to, amount); 
56:     } 
57:      
58:     /** 
59:      * @notice Burn des tokens (seulement owner) 
60:      * @dev Pour nettoyer ou simuler des frais 
61:      */ 
62:     function burn(address from, uint256 amount) external { 
63:         require(msg.sender == owner, "MockERC20: Only owner can burn"); 
64:         require(from  Burn from zero address"); 
65:          
66:         _burn(from, amount); 
67:         emit Burned(from, amount); 
68:     } 
69:      
70:     /** 
71:      * @notice Mint avec approval automatique 
72:      * @dev Utile pour les tests d'intégration 
73:      */ 
74:     function mintAndApprove(address to, uint256 amount, address spender) external { 
75:         require(msg.sender == owner, "MockERC20: Only owner"); 
76:          
77:         _mint(to, amount); 
78:         _approve(to, spender, amount); 
79:          
80:         emit Minted(to, amount); 
81:     } 
82:      
83:     /** 
84:      * @notice Transfère la propriété 
85:      */ 
86:     function transferOwnership(address newOwner) external { 
87:         require(msg.sender == owner, "MockERC20: Only owner"); 
88:         require(newOwner  New owner is zero address"); 
89:          
90:         emit OwnershipTransferred(owner, newOwner); 
91:         owner = newOwner; 
92:     } 
93:      
94:     /** 
95:      * @notice Donne des tokens à plusieurs adresses 
96:      * @dev Pour peupler plusieurs comptes de test rapidement 
97:      */ 
98:     function batchMint(address[] calldata recipients, uint256[] calldata amounts) external { 
99:         require(msg.sender == owner, "MockERC20: Only owner"); 
100:         require(recipients.length == amounts.length, "MockERC20: Arrays length mismatch"); 
101:          
102:         for (uint256 i = 0; i < recipients.length; i++) { 
103:             require(recipients[i]  Zero address in batch"); 
104:             _mint(recipients[i], amounts[i]); 
105:             emit Minted(recipients[i], amounts[i]); 
106:         } 
107:     } 
108:      
109:     /** 
110:      * @notice Simule un transfert depuis une autre adresse (pour tests) 
111:      * @dev Permet de tester les transferFrom sans avoir à faire approve 
112:      */ 
113:     function transferFromSimulated( 
114:         address sender, 
115:         address recipient, 
116:         uint256 amount 
117:     ) external returns (bool) { 
118:         require(msg.sender == owner, "MockERC20: Only owner"); 
119:          
120:         _transfer(sender, recipient, amount); 
121:         return true; 
122:     } 
123:      
124:     /** 
125:      * @notice Augmente l'allowance sans avoir à la mettre à 0 d'abord 
126:      * @dev Contourne le problème d'approve de certains tokens 
127:      */ 
128:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool) { 
129:         address owner_ = _msgSender(); 
130:         _approve(owner_, spender, allowance(owner_, spender) + addedValue); 
131:         return true; 
132:     } 
133:      
134:     /** 
135:      * @notice Donne des tokens avec différents décimals pour tests 
136:      * @dev Utile pour tester la compatibilité avec différents stablecoins 
137:      */ 
138:     function getMockTokens( 
139:         uint8 decimalsType, 
140:         uint256 amount 
141:     ) external pure returns (uint256) { 
142:         if (decimalsType == 6) { 
143:             // USDC style: 6 decimals 
144:             return amount * 10 ** 6; 
145:         } else if (decimalsType == 18) { 
146:             // DAI/ETH style: 18 decimals 
147:             return amount * 10 ** 18; 
148:         } else { 
149:             revert("MockERC20: Unsupported decimals"); 
150:         } 
151:     } 
152: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"; 
4: import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"; 
5: import "@openzeppelin/contracts/access/AccessControl.sol"; 
6: // Début de l'implémentation manuelle de Counters 
7: library Counters { 
8:     struct Counter { 
9:         uint256 _value; 
10:     } 
11:      
12:     function current(Counter storage counter) internal view returns (uint256) { 
13:         return counter._value; 
14:     } 
15:      
16:     function increment(Counter storage counter) internal { 
17:         unchecked { counter._value += 1; } 
18:     } 
19:      
20:     function decrement(Counter storage counter) internal { 
21:         uint256 value = counter._value; 
22:         require(value > 0, "Counter: decrement overflow"); 
23:         unchecked { counter._value = value - 1; } 
24:     } 
25:      
26:     function reset(Counter storage counter) internal { 
27:         counter._value = 0; 
28:     } 
29: } 
30: // --- Fin de l'implémentation manuelle --- 
31: contract LoanNFT is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControl { 
32:     using Counters for Counters.Counter; 
33:     Counters.Counter private _tokenIds; 
34:      
35:     // Rôles 
36:     bytes32 public constant LOAN_MANAGER = keccak256("LOAN_MANAGER"); 
37:     bytes32 public constant MARKET_MANAGER = keccak256("MARKET_MANAGER"); 
38:      
39:     // Structure de métadonnées enrichies 
40:     struct LoanMetadata { 
41:         uint256 loanId; 
42:         uint256 principalAmount; 
43:         uint256 interestRate; // en base 10000 (1% = 100) 
44:         uint256 duration; 
45:         uint256 startTime; 
46:         uint256 riskScore; 
47:         uint256 trancheId; 
48:         address borrower; 
49:         address currency; 
50:         LoanStatus status; 
51:         uint256 remainingBalance; 
52:         uint256 lastPaymentTime; 
53:         uint256 totalRepaid; 
54:         bool isSecuritized; 
55:         string ipfsMetadata; 
56:     } 
57:      
58:     // Types de prêts 
59:     enum LoanStatus { 
60:         ACTIVE, 
61:         REPAID, 
62:         DEFAULTED, 
63:         INSURED_PAIDOUT, 
64:         SECURITIZED, 
65:         CANCELLED 
66:     } 
67:      
68:     // Mapping des métadonnées 
69:     mapping(uint256 => LoanMetadata) public loanMetadata; 
70:     mapping(uint256 => uint256) public loanIdToTokenId; 
71:     mapping(uint256 => uint256) public tokenIdToLoanId; 
72:      
73:     // Événements 
74:     event LoanNFTMinted( 
75:         uint256 indexed tokenId, 
76:         uint256 indexed loanId, 
77:         address indexed borrower, 
78:         uint256 amount, 
79:         uint256 interestRate, 
80:         uint256 duration 
81:     ); 
82:      
83:     event LoanNFTUpdated( 
84:         uint256 indexed tokenId, 
85:         LoanStatus newStatus, 
86:         uint256 remainingBalance, 
87:         uint256 timestamp 
88:     ); 
89:      
90:     event LoanNFTTransferred( 
91:         uint256 indexed tokenId, 
92:         address from, 
93:         address to, 
94:         uint256 salePrice, 
95:         uint256 timestamp 
96:     ); 
97:      
98:     constructor() ERC721("StructuredLoanNFT", "SLNFT") { 
99:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
100:         _grantRole(LOAN_MANAGER, msg.sender); 
101:         _grantRole(MARKET_MANAGER, msg.sender); 
102:     } 
103:      
104: 	function _update(address to, uint256 tokenId, address auth) 
105:     internal 
106:     override(ERC721Enumerable) 
107:     returns (address) 
108: 	{ 
109: 		return super._update(to, tokenId, auth); 
110: 	} 
111: 	function _increaseBalance(address account, uint256 value) 
112: 		internal 
113: 		override(ERC721Enumerable) 
114: 	{ 
115: 		super._increaseBalance(account, value); 
116: 	} 
117: 	function tokenURI(uint256 tokenId) 
118:     public 
119: 		view 
120: 		override(ERC721URIStorage) 
121: 		returns (string memory) 
122: 	{ 
123: 		return super.tokenURI(tokenId); 
124: 	} 
125: 	function supportsInterface(bytes4 interfaceId)  
126: 		public  
127: 		view  
128: 		override(ERC721Enumerable, ERC721URIStorage, AccessControl)  
129: 		returns (bool)  
130: 	{ 
131: 		return super.supportsInterface(interfaceId); 
132: 	} 
133: 	 
134:     // Mint d'un nouveau NFT pour un prêt 
135:     function mint( 
136:         address borrower, 
137:         uint256 loanId, 
138:         uint256 principalAmount, 
139:         uint256 interestRate, 
140:         uint256 duration, 
141:         uint256 riskScore, 
142:         uint256 trancheId, 
143:         address currency, 
144:         string memory ipfsMetadata 
145:     ) external onlyRole(LOAN_MANAGER) returns (uint256) { 
146:         _tokenIds.increment(); 
147:         uint256 newTokenId = _tokenIds.current(); 
148:          
149:         // Mint du NFT 
150:         _safeMint(borrower, newTokenId); 
151:          
152:         // Enregistrement des métadonnées 
153:         loanMetadata[newTokenId] = LoanMetadata({ 
154:             loanId: loanId, 
155:             principalAmount: principalAmount, 
156:             interestRate: interestRate, 
157:             duration: duration, 
158:             startTime: block.timestamp, 
159:             riskScore: riskScore, 
160:             trancheId: trancheId, 
161:             borrower: borrower, 
162:             currency: currency, 
163:             status: LoanStatus.ACTIVE, 
164:             remainingBalance: principalAmount, 
165:             lastPaymentTime: block.timestamp, 
166:             totalRepaid: 0, 
167:             isSecuritized: false, 
168:             ipfsMetadata: ipfsMetadata 
169:         }); 
170:          
171:         // Mapping des IDs 
172:         loanIdToTokenId[loanId] = newTokenId; 
173:         tokenIdToLoanId[newTokenId] = loanId; 
174:          
175:         // Définition de l'URI 
176:         string memory uriString = string(abi.encodePacked( 
177:             "https://api.loanplatform.com/nft/", 
178:             _toString(newTokenId) 
179:         )); 
180:         _setTokenURI(newTokenId, uriString); 
181:          
182:         emit LoanNFTMinted( 
183:             newTokenId, 
184:             loanId, 
185:             borrower, 
186:             principalAmount, 
187:             interestRate, 
188:             duration 
189:         ); 
190:          
191:         return newTokenId; 
192:     } 
193:      
194:     // Mise à jour du statut du prêt 
195:     function updateStatus( 
196:         uint256 loanId, 
197:         LoanStatus newStatus, 
198:         uint256 remainingBalance, 
199:         uint256 totalRepaid 
200:     ) external onlyRole(LOAN_MANAGER) { 
201:         uint256 tokenId = loanIdToTokenId[loanId]; 
202:         require(tokenId = 0, "NFT not found"); 
203:          
204:         LoanMetadata storage metadata = loanMetadata[tokenId]; 
205:         metadata.status = newStatus; 
206:         metadata.remainingBalance = remainingBalance; 
207:         metadata.totalRepaid = totalRepaid; 
208:         metadata.lastPaymentTime = block.timestamp; 
209:          
210:         emit LoanNFTUpdated(tokenId, newStatus, remainingBalance, block.timestamp); 
211:     } 
212:      
213:     // Marquage comme remboursé 
214:     function markAsRepaid(uint256 loanId) external onlyRole(LOAN_MANAGER) { 
215:         uint256 tokenId = loanIdToTokenId[loanId]; 
216:         require(tokenId = 0, "NFT not found"); 
217:          
218:         loanMetadata[tokenId].status = LoanStatus.REPAID; 
219:         loanMetadata[tokenId].remainingBalance = 0; 
220:          
221:         // Mise à jour de l'uriString pour refléter le statut 
222:         _setTokenURI(tokenId, string(abi.encodePacked( 
223:             tokenURI(tokenId), 
224:             "?status=repaid" 
225:         ))); 
226:     } 
227:      
228:     // Marquage comme titrisé 
229:     function markAsSecuritized(uint256 loanId) external onlyRole(MARKET_MANAGER) { 
230:         uint256 tokenId = loanIdToTokenId[loanId]; 
231:         require(tokenId = 0, "NFT not found"); 
232:          
233:         loanMetadata[tokenId].isSecuritized = true; 
234:         loanMetadata[tokenId].status = LoanStatus.SECURITIZED; 
235:     } 
236:      
237:     // Enregistrement d'un paiement 
238:     function recordPayment( 
239:         uint256 loanId, 
240:         uint256 paymentAmount, 
241:         uint256 newBalance 
242:     ) external onlyRole(LOAN_MANAGER) { 
243:         uint256 tokenId = loanIdToTokenId[loanId]; 
244:         require(tokenId = 0, "NFT not found"); 
245:          
246:         LoanMetadata storage metadata = loanMetadata[tokenId]; 
247:         metadata.totalRepaid += paymentAmount; 
248:         metadata.remainingBalance = newBalance; 
249:         metadata.lastPaymentTime = block.timestamp; 
250:     } 
251:      
252:     // Calcul de la valeur actuelle du prêt 
253:     function calculateCurrentValue(uint256 tokenId) public view returns (uint256) { 
254:         LoanMetadata memory metadata = loanMetadata[tokenId]; 
255:          
256:         if (metadata.status = LoanStatus.ACTIVE) { 
257:             return metadata.remainingBalance; 
258:         } 
259:          
260:         uint256 elapsedTime = block.timestamp - metadata.startTime; 
261:         uint256 totalTime = metadata.duration; 
262:          
263:         // Calcul des intérêts accumulés (intérêts simples) 
264:         uint256 interestAccrued = (metadata.principalAmount * metadata.interestRate * elapsedTime) / 
265:             (365 days * 10000); 
266:          
267:         return metadata.remainingBalance + interestAccrued; 
268:     } 
269:      
270:     // Vérification de l'éligibilité au marché secondaire 
271:     function isEligibleForSecondaryMarket(uint256 tokenId) public view returns (bool) { 
272:         LoanMetadata memory metadata = loanMetadata[tokenId]; 
273:          
274:         return metadata.status == LoanStatus.ACTIVE && 
275:             metadata.isSecuritized && 
276:             block.timestamp < metadata.startTime + metadata.duration; 
277:     } 
278:      
279:     // Récupération des détails du prêt 
280:     function getLoanDetails(uint256 tokenId) public view returns ( 
281:         uint256 loanId, 
282:         uint256 principalAmount, 
283:         uint256 interestRate, 
284:         uint256 duration, 
285:         uint256 riskScore, 
286:         uint256 trancheId, 
287:         address borrower, 
288:         LoanStatus status, 
289:         uint256 remainingBalance, 
290:         bool isSecuritized 
291:     ) { 
292:         LoanMetadata memory metadata = loanMetadata[tokenId]; 
293:         return ( 
294:             metadata.loanId, 
295:             metadata.principalAmount, 
296:             metadata.interestRate, 
297:             metadata.duration, 
298:             metadata.riskScore, 
299:             metadata.trancheId, 
300:             metadata.borrower, 
301:             metadata.status, 
302:             metadata.remainingBalance, 
303:             metadata.isSecuritized 
304:         ); 
305:     } 
306:      
307:     // Récupération des métadonnées complètes 
308:     function getFullMetadata(uint256 tokenId) public view returns ( 
309:         LoanMetadata memory metadata, 
310:         uint256 currentValue, 
311:         bool eligibleForMarket 
312:     ) { 
313:         metadata = loanMetadata[tokenId]; 
314:         currentValue = calculateCurrentValue(tokenId); 
315:         eligibleForMarket = isEligibleForSecondaryMarket(tokenId); 
316:          
317:         return (metadata, currentValue, eligibleForMarket); 
318:     } 
319:      
320:     // Transfert avec enregistrement du prix de vente 
321:     function transferWithRecord( 
322:         address from, 
323:         address to, 
324:         uint256 tokenId, 
325:         uint256 salePrice 
326:     ) external onlyRole(MARKET_MANAGER) { 
327:         address owner = ownerOf(tokenId); 
328: 		require( 
329: 			from == owner ||  
330: 			isApprovedForAll(owner, from) ||  
331: 			getApproved(tokenId) == from, 
332: 			"Not approved" 
333: 		); 
334:          
335:         _transfer(from, to, tokenId); 
336:          
337:         emit LoanNFTTransferred(tokenId, from, to, salePrice, block.timestamp); 
338:     } 
339:      
340:     // Batch mint pour plusieurs prêts 
341:     function batchMint( 
342:         address[] memory borrowers, 
343:         uint256[] memory loanIds, 
344:         uint256[] memory amounts, 
345:         uint256[] memory interestRates, 
346:         uint256[] memory durations 
347:     ) external onlyRole(LOAN_MANAGER) returns (uint256[] memory) { 
348:         require( 
349:             borrowers.length == loanIds.length && 
350:             loanIds.length == amounts.length && 
351:             amounts.length == interestRates.length && 
352:             interestRates.length == durations.length, 
353:             "Array length mismatch" 
354:         ); 
355:          
356:         uint256[] memory tokenIds = new uint256[](borrowers.length); 
357:          
358:         for (uint256 i = 0; i < borrowers.length; i++) { 
359:             _tokenIds.increment(); 
360:             uint256 newTokenId = _tokenIds.current(); 
361:              
362:             _safeMint(borrowers[i], newTokenId); 
363:              
364:             loanMetadata[newTokenId] = LoanMetadata({ 
365:                 loanId: loanIds[i], 
366:                 principalAmount: amounts[i], 
367:                 interestRate: interestRates[i], 
368:                 duration: durations[i], 
369:                 startTime: block.timestamp, 
370:                 riskScore: 500, // Score par défaut 
371:                 trancheId: 1, // Tranche par défaut 
372:                 borrower: borrowers[i], 
373:                 currency: address(0), // ETH par défaut 
374:                 status: LoanStatus.ACTIVE, 
375:                 remainingBalance: amounts[i], 
376:                 lastPaymentTime: block.timestamp, 
377:                 totalRepaid: 0, 
378:                 isSecuritized: false, 
379:                 ipfsMetadata: "" 
380:             }); 
381:              
382:             loanIdToTokenId[loanIds[i]] = newTokenId; 
383:             tokenIdToLoanId[newTokenId] = loanIds[i]; 
384:              
385:             tokenIds[i] = newTokenId; 
386:              
387:             emit LoanNFTMinted( 
388:                 newTokenId, 
389:                 loanIds[i], 
390:                 borrowers[i], 
391:                 amounts[i], 
392:                 interestRates[i], 
393:                 durations[i] 
394:             ); 
395:         } 
396:          
397:         return tokenIds; 
398:     } 
399:      
400:     // Override des fonctions nécessaires 
401:     function _beforeTokenTransfer( 
402:         address from, 
403:         address to, 
404:         uint256 tokenId 
405:     ) internal override(ERC721Enumerable) { 
406:         super._beforeTokenTransfer(from, to, tokenId); 
407:     } 
408:      
409:     function _burn(uint256 tokenId) internal override(ERC721URIStorage) { 
410:         super._burn(tokenId); 
411:     } 
412:      
413:     function uri(uint256 tokenId) 
414:         public 
415:         view 
416:         override(ERC721URIStorage) 
417:         returns (string memory) 
418:     { 
419:         return super.uri(tokenId); 
420:     } 
421:      
422:     function supportsInterface(bytes4 interfaceId) 
423:         public 
424:         view 
425:         override(ERC721Enumerable, ERC721URIStorage, AccessControl) 
426:         returns (bool) 
427:     { 
428:         return super.supportsInterface(interfaceId); 
429:     } 
430:      
431:     // Fonction utilitaire pour convertir uint en string 
432:     function _toString(uint256 value) internal pure returns (string memory) { 
433:         if (value == 0) { 
434:             return "0"; 
435:         } 
436:         uint256 temp = value; 
437:         uint256 digits; 
438:         while (temp = 0) { 
439:             digits++; 
440:             temp /= 10; 
441:         } 
442:         bytes memory buffer = new bytes(digits); 
443:         while (value = 0) { 
444:             digits -= 1; 
445:             buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); 
446:             value /= 10; 
447:         } 
448:         return string(buffer); 
449:     } 
450:      
451:     // Getters 
452:     function getTokenId(uint256 loanId) external view returns (uint256) { 
453:         return loanIdToTokenId[loanId]; 
454:     } 
455:      
456:     function getLoanId(uint256 tokenId) external view returns (uint256) { 
457:         return tokenIdToLoanId[tokenId]; 
458:     } 
459:      
460:     function getBorrowerTokens(address borrower) external view returns (uint256[] memory) { 
461:         uint256 balance = balanceOf(borrower); 
462:         uint256[] memory tokens = new uint256[](balance); 
463:          
464:         for (uint256 i = 0; i < balance; i++) { 
465:             tokens[i] = tokenOfOwnerByIndex(borrower, i); 
466:         } 
467:          
468:         return tokens; 
469:     } 
470:      
471:     function getTokenIdsByStatus(LoanStatus status) external view returns (uint256[] memory) { 
472:         uint256 total = _tokenIds.current(); 
473:         uint256 count = 0; 
474:          
475:         // Compter les tokens avec le statut donné 
476:         for (uint256 i = 1; i <= total; i++) { 
477:             if (loanMetadata[i].status == status) { 
478:                 count++; 
479:             } 
480:         } 
481:          
482:         // Collecter les tokenIds 
483:         uint256[] memory result = new uint256[](count); 
484:         uint256 index = 0; 
485:          
486:         for (uint256 i = 1; i <= total; i++) { 
487:             if (loanMetadata[i].status == status) { 
488:                 result[index] = i; 
489:                 index++; 
490:             } 
491:         } 
492:          
493:         return result; 
494:     } 
495: 	 
496: 	function _increaseBalance(address account, uint128 value)  
497: 		internal  
498: 		override(ERC721, ERC721Enumerable)  
499: 	{ 
500: 		super._increaseBalance(account, value); 
501: 	} 
502: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/token/ERC721/IERC721.sol"; 
4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
5: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
6: import "./LoanNFT.sol"; 
7: contract SecondaryMarketV2 is ReentrancyGuard { 
8:     // Structures 
9:     struct Listing { 
10:         uint256 tokenId; 
11:         address seller; 
12:         uint256 askingPrice; 
13:         uint256 reservePrice; 
14:         uint256 startTime; 
15:         uint256 endTime; 
16:         bool isAuction; 
17:         bool isActive; 
18:         address highestBidder; 
19:         uint256 highestBid; 
20:     } 
21:      
22:     struct Bid { 
23:         address bidder; 
24:         uint256 amount; 
25:         uint256 timestamp; 
26:     } 
27:      
28:     // Données du marché 
29:     mapping(uint256 => Listing) public listings; 
30:     mapping(uint256 => Bid[]) public listingBids; 
31:     mapping(address => uint256[]) public userListings; 
32:      
33:     // Paramètres 
34:     uint256 public platformFee = 25; // 0.25% 
35:     address public feeRecipient; 
36:     IERC20 public paymentToken; 
37:     LoanNFT public loanNFT; 
38:      
39:     // Événements 
40:     event Listed( 
41:         uint256 indexed tokenId, 
42:         address indexed seller, 
43:         uint256 askingPrice, 
44:         bool isAuction, 
45:         uint256 timestamp 
46:     ); 
47:      
48:     event Purchased( 
49:         uint256 indexed tokenId, 
50:         address indexed seller, 
51:         address indexed buyer, 
52:         uint256 price, 
53:         uint256 fee, 
54:         uint256 timestamp 
55:     ); 
56:      
57:     event BidPlaced( 
58:         uint256 indexed tokenId, 
59:         address indexed bidder, 
60:         uint256 amount, 
61:         uint256 timestamp 
62:     ); 
63:      
64:     event AuctionEnded( 
65:         uint256 indexed tokenId, 
66:         address indexed winner, 
67:         uint256 winningBid, 
68:         uint256 timestamp 
69:     ); 
70:      
71:     constructor( 
72:         address _loanNFT, 
73:         address _paymentToken, 
74:         address _feeRecipient 
75:     ) { 
76:         loanNFT = LoanNFT(_loanNFT); 
77:         paymentToken = IERC20(_paymentToken); 
78:         feeRecipient = _feeRecipient; 
79:     } 
80:      
81:     // Liste un NFT à prix fixe 
82:     function listFixedPrice( 
83:         uint256 tokenId, 
84:         uint256 price, 
85:         uint256 durationDays 
86:     ) external nonReentrant { 
87:         require(loanNFT.ownerOf(tokenId) == msg.sender, "Not owner"); 
88:         require(price > 0, "Price must be > 0"); 
89:         require(durationDays <= 90, "Duration too long"); 
90:          
91:         // Vérifier que le prêt est éligible 
92:         require(_isLoanEligible(tokenId), "Loan not eligible"); 
93:          
94:         // Créer la liste 
95:         listings[tokenId] = Listing({ 
96:             tokenId: tokenId, 
97:             seller: msg.sender, 
98:             askingPrice: price, 
99:             reservePrice: price * 80 / 100, // 80% du prix 
100:             startTime: block.timestamp, 
101:             endTime: block.timestamp + (durationDays * 1 days), 
102:             isAuction: false, 
103:             isActive: true, 
104:             highestBidder: address(0), 
105:             highestBid: 0 
106:         }); 
107:          
108:         userListings[msg.sender].push(tokenId); 
109:          
110:         // Transfert du NFT au contrat 
111:         loanNFT.transferFrom(msg.sender, address(this), tokenId); 
112:          
113:         emit Listed(tokenId, msg.sender, price, false, block.timestamp); 
114:     } 
115:      
116:     // Liste en enchère 
117:     function listAuction( 
118:         uint256 tokenId, 
119:         uint256 reservePrice, 
120:         uint256 durationDays 
121:     ) external nonReentrant { 
122:         require(loanNFT.ownerOf(tokenId) == msg.sender, "Not owner"); 
123:         require(reservePrice > 0, "Reserve must be > 0"); 
124:         require(durationDays <= 30, "Auction too long"); 
125:          
126:         require(_isLoanEligible(tokenId), "Loan not eligible"); 
127:          
128:         listings[tokenId] = Listing({ 
129:             tokenId: tokenId, 
130:             seller: msg.sender, 
131:             askingPrice: 0, 
132:             reservePrice: reservePrice, 
133:             startTime: block.timestamp, 
134:             endTime: block.timestamp + (durationDays * 1 days), 
135:             isAuction: true, 
136:             isActive: true, 
137:             highestBidder: address(0), 
138:             highestBid: 0 
139:         }); 
140:          
141:         userListings[msg.sender].push(tokenId); 
142:          
143:         loanNFT.transferFrom(msg.sender, address(this), tokenId); 
144:          
145:         emit Listed(tokenId, msg.sender, reservePrice, true, block.timestamp); 
146:     } 
147:      
148:     // Acheter à prix fixe 
149:     function purchase(uint256 tokenId) external nonReentrant { 
150:         Listing storage listing = listings[tokenId]; 
151:          
152:         require(listing.isActive, "Not active"); 
153:         require(listing.isAuction, "Is auction"); 
154:         require(block.timestamp <= listing.endTime, "Listing expired"); 
155:          
156:         uint256 price = listing.askingPrice; 
157:         uint256 fee = (price * platformFee) / 10000; 
158:         uint256 sellerProceeds = price - fee; 
159:          
160:         // Transfert du paiement 
161:         require( 
162:             paymentToken.transferFrom(msg.sender, address(this), price), 
163:             "Transfer failed" 
164:         ); 
165:          
166:         // Distribution 
167:         paymentToken.transfer(listing.seller, sellerProceeds); 
168:         paymentToken.transfer(feeRecipient, fee); 
169:          
170:         // Transfert du NFT 
171:         loanNFT.transferFrom(address(this), msg.sender, tokenId); 
172:          
173:         // Mise à jour 
174:         listing.isActive = false; 
175:          
176:         emit Purchased( 
177:             tokenId, 
178:             listing.seller, 
179:             msg.sender, 
180:             price, 
181:             fee, 
182:             block.timestamp 
183:         ); 
184:     } 
185:      
186:     // Placer une enchère 
187:     function placeBid(uint256 tokenId, uint256 amount) external nonReentrant { 
188:         Listing storage listing = listings[tokenId]; 
189:          
190:         require(listing.isActive, "Not active"); 
191:         require(listing.isAuction, "Not auction"); 
192:         require(block.timestamp <= listing.endTime, "Auction ended"); 
193:         require(amount > listing.highestBid, "Bid too low"); 
194:         require(amount >= listing.reservePrice, "Below reserve"); 
195:          
196:         // Rembourser l'ancien encherisseur 
197:         if (listing.highestBidder = address(0)) { 
198:             paymentToken.transfer(listing.highestBidder, listing.highestBid); 
199:         } 
200:          
201:         // Recevoir la nouvelle enchère 
202:         require( 
203:             paymentToken.transferFrom(msg.sender, address(this), amount), 
204:             "Transfer failed" 
205:         ); 
206:          
207:         // Mise à jour 
208:         listing.highestBidder = msg.sender; 
209:         listing.highestBid = amount; 
210:          
211:         // Enregistrer l'enchère 
212:         listingBids[tokenId].push(Bid({ 
213:             bidder: msg.sender, 
214:             amount: amount, 
215:             timestamp: block.timestamp 
216:         })); 
217:          
218:         emit BidPlaced(tokenId, msg.sender, amount, block.timestamp); 
219:     } 
220:      
221:     // Finaliser une enchère 
222:     function finalizeAuction(uint256 tokenId) external nonReentrant { 
223:         Listing storage listing = listings[tokenId]; 
224:          
225:         require(listing.isActive, "Not active"); 
226:         require(listing.isAuction, "Not auction"); 
227:         require(block.timestamp > listing.endTime, "Auction not ended"); 
228:         require(listing.highestBidder = address(0), "No bids"); 
229:          
230:         uint256 winningBid = listing.highestBid; 
231:         uint256 fee = (winningBid * platformFee) / 10000; 
232:         uint256 sellerProceeds = winningBid - fee; 
233:          
234:         // Distribution 
235:         paymentToken.transfer(listing.seller, sellerProceeds); 
236:         paymentToken.transfer(feeRecipient, fee); 
237:          
238:         // Transfert du NFT 
239:         loanNFT.transferFrom(address(this), listing.highestBidder, tokenId); 
240:          
241:         // Mise à jour 
242:         listing.isActive = false; 
243:          
244:         emit AuctionEnded( 
245:             tokenId, 
246:             listing.highestBidder, 
247:             winningBid, 
248:             block.timestamp 
249:         ); 
250:     } 
251:      
252:     // Retirer une liste 
253:     function cancelListing(uint256 tokenId) external nonReentrant { 
254:         Listing storage listing = listings[tokenId]; 
255:          
256:         require(listing.seller == msg.sender, "Not seller"); 
257:         require(listing.isActive, "Not active"); 
258:          
259:         // Pour les enchères, vérifier qu'il n'y a pas d'enchères 
260:         if (listing.isAuction) { 
261:             require(listing.highestBidder == address(0), "Bids exist"); 
262:         } 
263:          
264:         // Rembourser le NFT 
265:         loanNFT.transferFrom(address(this), msg.sender, tokenId); 
266:          
267:         listing.isActive = false; 
268:     } 
269:      
270:     // Vérifier l'éligibilité d'un prêt 
271:     function _isLoanEligible(uint256 tokenId) private view returns (bool) { 
272:         // Récupérer les détails du prêt 
273:         (,, uint256 loanAmount, uint256 interestRate, uint256 duration,,,) =  
274:             loanNFT.getLoanDetails(tokenId); 
275:          
276:         // Vérifications de base 
277:         if (loanAmount == 0) return false; 
278:         if (duration < 30 days) return false; 
279:          
280:         // Vérifier le statut (doit être actif) 
281:         // À implémenter: intégration avec LoanPool 
282:          
283:         return true; 
284:     } 
285:      
286:     // Getters 
287:     function getListingBids(uint256 tokenId) external view returns (Bid[] memory) { 
288:         return listingBids[tokenId]; 
289:     } 
290:      
291:     function getUserListings(address user) external view returns (uint256[] memory) { 
292:         return userListings[user]; 
293:     } 
294:      
295:     function getMarketStats() external view returns ( 
296:         uint256 totalListings, 
297:         uint256 activeListings, 
298:         uint256 totalVolume, 
299:         uint256 averagePrice 
300:     ) { 
301:         // À implémenter: statistiques du marché 
302:         return (0, 0, 0, 0); 
303:     } 
304: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/AccessControl.sol"; 
4: import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; 
5: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
6: import "@openzeppelin/contracts/utils/Pausable.sol"; 
7: contract AccessController is AccessControl { 
8:     using EnumerableSet for EnumerableSet.AddressSet; 
9:      
10:     // Structures de données améliorées 
11:     struct RoleConfig { 
12:         bytes32 role; 
13:         string name; 
14:         string description; 
15:         uint256 maxMembers; 
16:         uint256 minMembers; 
17:         bool isSensitive; 
18:         uint256 approvalThreshold; // Pourcentage requis pour les changements 
19:     } 
20:      
21:     struct PermissionLog { 
22:         address user; 
23:         bytes32 role; 
24:         bool granted; 
25:         address executor; 
26:         uint256 timestamp; 
27:         string reason; 
28:     } 
29:      
30:     struct ContractRegistration { 
31:         address contractAddress; 
32:         string name; 
33:         string version; 
34:         uint256 registeredAt; 
35:         address registeredBy; 
36:         bool isActive; 
37:         string ipfsConfig; 
38:     } 
39:      
40:     // Variables d'état 
41:     mapping(bytes32 => RoleConfig) public roleConfigs; 
42:     mapping(bytes32 => EnumerableSet.AddressSet) private roleMembers; 
43:     mapping(address => bytes32[]) public userRoles; 
44:     mapping(address => PermissionLog[]) public permissionLogs; 
45:     mapping(address => ContractRegistration) public registeredContracts; 
46:      
47:     EnumerableSet.AddressSet private registeredContractsSet; 
48:      
49:     uint256 public logRetentionPeriod = 365 days; 
50:     uint256 public maxRolesPerUser = 10; 
51:     uint256 public roleChangeCooldown = 24 hours; 
52:      
53:     mapping(address => mapping(bytes32 => uint256)) public lastRoleChange; 
54:      
55:     // Rôles système 
56:     bytes32 public constant SUPER_ADMIN = keccak256("SUPER_ADMIN"); 
57:     bytes32 public constant SECURITY_ADMIN = keccak256("SECURITY_ADMIN"); 
58:     bytes32 public constant AUDITOR = keccak256("AUDITOR"); 
59:     bytes32 public constant UPGRADE_MANAGER = keccak256("UPGRADE_MANAGER"); 
60:      
61:     // Événements 
62:     event RoleConfigured( 
63:         bytes32 indexed role, 
64:         string name, 
65:         string description, 
66:         uint256 maxMembers, 
67:         uint256 minMembers, 
68:         bool isSensitive 
69:     ); 
70:      
71:     event RoleGrantedWithApproval( 
72:         bytes32 indexed role, 
73:         address indexed account, 
74:         address indexed granter, 
75:         uint256 approvalCount, 
76:         uint256 timestamp 
77:     ); 
78:      
79:     event RoleRevokedWithReason( 
80:         bytes32 indexed role, 
81:         address indexed account, 
82:         address indexed revoker, 
83:         string reason, 
84:         uint256 timestamp 
85:     ); 
86:      
87:     event ContractRegistered( 
88:         address indexed contractAddress, 
89:         string name, 
90:         string version, 
91:         address indexed registrant, 
92:         uint256 timestamp 
93:     ); 
94:      
95:     event ContractDeregistered( 
96:         address indexed contractAddress, 
97:         address indexed deregistrant, 
98:         string reason, 
99:         uint256 timestamp 
100:     ); 
101:      
102:     event EmergencyAccessActivated( 
103:         address indexed executor, 
104:         uint256 duration, 
105:         string emergencyReason, 
106:         uint256 timestamp 
107:     ); 
108:      
109:     constructor() { 
110:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
111:         _grantRole(SUPER_ADMIN, msg.sender); 
112:         _grantRole(SECURITY_ADMIN, msg.sender); 
113:          
114:         // Initialisation des rôles système 
115:         _initializeSystemRoles(); 
116:     } 
117:      
118:     // Initialisation des rôles système 
119:     function _initializeSystemRoles() private { 
120:         // Configuration du rôle SUPER_ADMIN 
121:         roleConfigs[SUPER_ADMIN] = RoleConfig({ 
122:             role: SUPER_ADMIN, 
123:             name: "Super Administrator", 
124:             description: "Full system access, can configure all roles", 
125:             maxMembers: 3, 
126:             minMembers: 1, 
127:             isSensitive: true, 
128:             approvalThreshold: 7500 // 75% d'approbation nécessaire 
129:         }); 
130:          
131:         // Configuration du rôle SECURITY_ADMIN 
132:         roleConfigs[SECURITY_ADMIN] = RoleConfig({ 
133:             role: SECURITY_ADMIN, 
134:             name: "Security Administrator", 
135:             description: "Manages security settings and emergency procedures", 
136:             maxMembers: 5, 
137:             minMembers: 2, 
138:             isSensitive: true, 
139:             approvalThreshold: 6600 // 66% d'approbation 
140:         }); 
141:          
142:         // Configuration du rôle AUDITOR 
143:         roleConfigs[AUDITOR] = RoleConfig({ 
144:             role: AUDITOR, 
145:             name: "System Auditor", 
146:             description: "Read-only access to all system logs and configurations", 
147:             maxMembers: 10, 
148:             minMembers: 1, 
149:             isSensitive: false, 
150:             approvalThreshold: 5000 // 50% d'approbation 
151:         }); 
152:          
153:         // Configuration du rôle UPGRADE_MANAGER 
154:         roleConfigs[UPGRADE_MANAGER] = RoleConfig({ 
155:             role: UPGRADE_MANAGER, 
156:             name: "Upgrade Manager", 
157:             description: "Manages contract upgrades and deployments", 
158:             maxMembers: 5, 
159:             minMembers: 2, 
160:             isSensitive: true, 
161:             approvalThreshold: 7500 // 75% d'approbation 
162:         }); 
163:          
164:         // Rôles standards du système de prêt 
165:         _configureStandardRoles(); 
166:     } 
167:      
168:     function _configureStandardRoles() private { 
169:         // Rôle LOAN_MANAGER 
170:         bytes32 LOAN_MANAGER = keccak256("LOAN_MANAGER"); 
171:         roleConfigs[LOAN_MANAGER] = RoleConfig({ 
172:             role: LOAN_MANAGER, 
173:             name: "Loan Manager", 
174:             description: "Manages loan creation, approval, and lifecycle", 
175:             maxMembers: 10, 
176:             minMembers: 2, 
177:             isSensitive: true, 
178:             approvalThreshold: 6600 
179:         }); 
180:          
181:         // Rôle RISK_MANAGER 
182:         bytes32 RISK_MANAGER = keccak256("RISK_MANAGER"); 
183:         roleConfigs[RISK_MANAGER] = RoleConfig({ 
184:             role: RISK_MANAGER, 
185:             name: "Risk Manager", 
186:             description: "Manages risk parameters and default processing", 
187:             maxMembers: 8, 
188:             minMembers: 2, 
189:             isSensitive: true, 
190:             approvalThreshold: 6600 
191:         }); 
192:          
193:         // Rôle INSURANCE_MANAGER 
194:         bytes32 INSURANCE_MANAGER = keccak256("INSURANCE_MANAGER"); 
195:         roleConfigs[INSURANCE_MANAGER] = RoleConfig({ 
196:             role: INSURANCE_MANAGER, 
197:             name: "Insurance Manager", 
198:             description: "Manages insurance policies and claims", 
199:             maxMembers: 8, 
200:             minMembers: 2, 
201:             isSensitive: true, 
202:             approvalThreshold: 6600 
203:         }); 
204:          
205:         // Rôle FUND_MANAGER 
206:         bytes32 FUND_MANAGER = keccak256("FUND_MANAGER"); 
207:         roleConfigs[FUND_MANAGER] = RoleConfig({ 
208:             role: FUND_MANAGER, 
209:             name: "Fund Manager", 
210:             description: "Manages guarantee fund and treasury", 
211:             maxMembers: 5, 
212:             minMembers: 2, 
213:             isSensitive: true, 
214:             approvalThreshold: 7500 
215:         }); 
216:          
217:         // Rôle GOVERNANCE_MANAGER 
218:         bytes32 GOVERNANCE_MANAGER = keccak256("GOVERNANCE_MANAGER"); 
219:         roleConfigs[GOVERNANCE_MANAGER] = RoleConfig({ 
220:             role: GOVERNANCE_MANAGER, 
221:             name: "Governance Manager", 
222:             description: "Manages governance proposals and voting", 
223:             maxMembers: 10, 
224:             minMembers: 3, 
225:             isSensitive: false, 
226:             approvalThreshold: 5000 
227:         }); 
228:          
229:         // Rôle NOTIFICATION_SENDER 
230:         bytes32 NOTIFICATION_SENDER = keccak256("NOTIFICATION_SENDER"); 
231:         roleConfigs[NOTIFICATION_SENDER] = RoleConfig({ 
232:             role: NOTIFICATION_SENDER, 
233:             name: "Notification Sender", 
234:             description: "Can send system notifications to users", 
235:             maxMembers: 15, 
236:             minMembers: 1, 
237:             isSensitive: false, 
238:             approvalThreshold: 5000 
239:         }); 
240:          
241:         // Rôle FEE_COLLECTOR 
242:         bytes32 FEE_COLLECTOR = keccak256("FEE_COLLECTOR"); 
243:         roleConfigs[FEE_COLLECTOR] = RoleConfig({ 
244:             role: FEE_COLLECTOR, 
245:             name: "Fee Collector", 
246:             description: "Can collect and distribute system fees", 
247:             maxMembers: 5, 
248:             minMembers: 2, 
249:             isSensitive: true, 
250:             approvalThreshold: 6600 
251:         }); 
252:     } 
253:      
254:     // Configuration d'un nouveau rôle 
255:     function configureRole( 
256:         bytes32 role, 
257:         string memory name, 
258:         string memory description, 
259:         uint256 maxMembers, 
260:         uint256 minMembers, 
261:         bool isSensitive, 
262:         uint256 approvalThreshold 
263:     ) external onlyRole(SUPER_ADMIN) { 
264:         require(maxMembers >= minMembers, "Invalid member limits"); 
265:         require(approvalThreshold <= 10000, "Invalid threshold"); 
266:          
267:         roleConfigs[role] = RoleConfig({ 
268:             role: role, 
269:             name: name, 
270:             description: description, 
271:             maxMembers: maxMembers, 
272:             minMembers: minMembers, 
273:             isSensitive: isSensitive, 
274:             approvalThreshold: approvalThreshold 
275:         }); 
276:          
277:         emit RoleConfigured(role, name, description, maxMembers, minMembers, isSensitive); 
278:     } 
279:      
280:     // Attribution de rôle avec approbation multi-sig 
281:     function grantRoleWithApproval( 
282:         bytes32 role, 
283:         address account, 
284:         bytes[] memory signatures 
285:     ) external { 
286:         RoleConfig memory config = roleConfigs[role]; 
287:         require(config.role = bytes32(0), "Role not configured"); 
288:          
289:         // Vérifier le cooldown 
290:         require( 
291:             block.timestamp >= lastRoleChange[account][role] + roleChangeCooldown, 
292:             "Cooldown period active" 
293:         ); 
294:          
295:         // Vérifier la limite de membres 
296:         require( 
297:             roleMembers[role].length() < config.maxMembers, 
298:             "Role member limit reached" 
299:         ); 
300:          
301:         // Vérifier la limite de rôles par utilisateur 
302:         require( 
303:             userRoles[account].length < maxRolesPerUser, 
304:             "User role limit reached" 
305:         ); 
306:          
307:         // Pour les rôles sensibles, vérifier les signatures 
308:         if (config.isSensitive) { 
309:             uint256 approvalCount = _validateSignatures(role, account, true, signatures); 
310:             require( 
311:                 approvalCount * 10000 >= config.approvalThreshold * roleMembers[role].length(), 
312:                 "Insufficient approvals" 
313:             ); 
314:         } 
315:          
316:         // Attribution du rôle 
317:         _grantRole(role, account); 
318: 		roleMembers[role].push(account); 
319:          
320:         // Mettre à jour les rôles de l'utilisateur 
321:         userRoles[account].push(role); 
322:          
323:         // Enregistrer le log 
324:         permissionLogs[account].push(PermissionLog({ 
325:             user: account, 
326:             role: role, 
327:             granted: true, 
328:             executor: msg.sender, 
329:             timestamp: block.timestamp, 
330:             reason: "Multi-sig approval" 
331:         })); 
332:          
333:         lastRoleChange[account][role] = block.timestamp; 
334:          
335:         emit RoleGrantedWithApproval( 
336:             role, 
337:             account, 
338:             msg.sender, 
339:             config.isSensitive ? signatures.length : 1, 
340:             block.timestamp 
341:         ); 
342:     } 
343:      
344:     // Révocation de rôle avec raison 
345:     function revokeRoleWithReason( 
346:         bytes32 role, 
347:         address account, 
348:         string memory reason 
349:     ) external onlyRole(getRoleAdmin(role)) { 
350:         require(hasRole(role, account), "Address does not have role"); 
351:          
352:         // Vérifier le minimum de membres 
353:         RoleConfig memory config = roleConfigs[role]; 
354:         if (config.minMembers > 0) { 
355:             require( 
356:                 roleMembers[role].length() > config.minMembers, 
357:                 "Cannot go below minimum members" 
358:             ); 
359:         } 
360:          
361:         _revokeRole(role, account); 
362:         roleMembers[role].remove(account); 
363:          
364:         // Retirer le rôle de la liste de l'utilisateur 
365:         _removeUserRole(account, role); 
366:          
367:         // Enregistrer le log 
368:         permissionLogs[account].push(PermissionLog({ 
369:             user: account, 
370:             role: role, 
371:             granted: false, 
372:             executor: msg.sender, 
373:             timestamp: block.timestamp, 
374:             reason: reason 
375:         })); 
376:          
377:         emit RoleRevokedWithReason(role, account, msg.sender, reason, block.timestamp); 
378:     } 
379:      
380:     // Enregistrement d'un contrat 
381:     function registerContract( 
382:         address contractAddress, 
383:         string memory name, 
384:         string memory version, 
385:         string memory ipfsConfig 
386:     ) external onlyRole(UPGRADE_MANAGER) { 
387:         require(contractAddress = address(0), "Invalid contract address"); 
388:         require(registeredContractsSet.contains(contractAddress), "Contract already registered"); 
389:          
390:         registeredContracts[contractAddress] = ContractRegistration({ 
391:             contractAddress: contractAddress, 
392:             name: name, 
393:             version: version, 
394:             registeredAt: block.timestamp, 
395:             registeredBy: msg.sender, 
396:             isActive: true, 
397:             ipfsConfig: ipfsConfig 
398:         }); 
399:          
400:         registeredContractsSet.push(contractAddress); 
401:          
402:         emit ContractRegistered(contractAddress, name, version, msg.sender, block.timestamp); 
403:     } 
404:      
405:     // Désactivation d'un contrat 
406:     function deregisterContract( 
407:         address contractAddress, 
408:         string memory reason 
409:     ) external onlyRole(SECURITY_ADMIN) { 
410:         require(registeredContractsSet.contains(contractAddress), "Contract not registered"); 
411:          
412:         registeredContracts[contractAddress].isActive = false; 
413:          
414:         emit ContractDeregistered(contractAddress, msg.sender, reason, block.timestamp); 
415:     } 
416:      
417:     // Vérification d'accès avec contexte 
418:     function checkAccess( 
419:         address user, 
420:         bytes32 role, 
421:         bytes memory context 
422:     ) external view returns (bool hasAccess, string memory reason) { 
423:         if (hasRole(role, user)) { 
424:             return (false, "User does not have required role"); 
425:         } 
426:          
427:         ContractRegistration memory contractInfo = registeredContracts[msg.sender]; 
428:         if (contractInfo.isActive) { 
429:             return (false, "Calling contract is not active"); 
430:         } 
431:          
432:         // Vérifications supplémentaires selon le contexte 
433:         if (context.length > 0) { 
434:             // Exemple: vérification de limites de temps pour certains rôles 
435:             // À étendre selon les besoins spécifiques 
436:         } 
437:          
438:         return (true, "Access granted"); 
439:     } 
440:      
441:     // Activation d'accès d'urgence 
442:     function activateEmergencyAccess( 
443:         uint256 duration, 
444:         string memory emergencyReason 
445:     ) external onlyRole(SECURITY_ADMIN) { 
446:         // Créer un rôle d'urgence temporaire 
447:         bytes32 emergencyRole = keccak256(abi.encodePacked( 
448:             "EMERGENCY_ACCESS_", 
449:             block.timestamp 
450:         )); 
451:          
452:         // Configuration temporaire 
453:         roleConfigs[emergencyRole] = RoleConfig({ 
454:             role: emergencyRole, 
455:             name: "Emergency Access", 
456:             description: string(abi.encodePacked("Emergency access for: ", emergencyReason)), 
457:             maxMembers: 3, 
458:             minMembers: 1, 
459:             isSensitive: true, 
460:             approvalThreshold: 10000 
461:         }); 
462:          
463:         // Attribution à l'exécuteur 
464:         _grantRole(emergencyRole, msg.sender); 
465:         roleMembers[emergencyRole].push(msg.sender); 
466:          
467:         // Programmer la révocation automatique 
468:         _scheduleRoleRevocation(emergencyRole, msg.sender, block.timestamp + duration); 
469:          
470:         emit EmergencyAccessActivated( 
471:             msg.sender, 
472:             duration, 
473:             emergencyReason, 
474:             block.timestamp 
475:         ); 
476:     } 
477:      
478:     // Vérification KYC 
479:     function isKYCCertified(address user) external view returns (bool) { 
480:         // À intégrer avec KYCRegistry 
481:         // Pour l'instant, retourne true pour les tests 
482:         return true; 
483:     } 
484:      
485:     // Fonctions internes 
486:     function _validateSignatures( 
487:         bytes32 role, 
488:         address account, 
489:         bool grant, 
490:         bytes[] memory signatures 
491:     ) private view returns (uint256) { 
492:         uint256 validSignatures = 0; 
493:         bytes32 messageHash = keccak256(abi.encodePacked( 
494:             role, 
495:             account, 
496:             grant, 
497:             block.chainid, 
498:             address(this) 
499:         )); 
500:          
501:         bytes32 ethSignedMessageHash = keccak256( 
502:             abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash) 
503:         ); 
504:          
505:         for (uint256 i = 0; i < signatures.length; i++) { 
506:             address signer = _recoverSigner(ethSignedMessageHash, signatures[i]); 
507:             if (hasRole(getRoleAdmin(role), signer)) { 
508:                 validSignatures++; 
509:             } 
510:         } 
511:          
512:         return validSignatures; 
513:     } 
514:      
515:     function _recoverSigner( 
516:         bytes32 ethSignedMessageHash, 
517:         bytes memory signature 
518:     ) private pure returns (address) { 
519:         (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature); 
520:         return ecrecover(ethSignedMessageHash, v, r, s); 
521:     } 
522:      
523:     function _splitSignature(bytes memory signature) private pure returns (bytes32 r, bytes32 s, uint8 v) { 
524:         require(signature.length == 65, "Invalid signature length"); 
525:          
526:         assembly { 
527:             r := mload(add(signature, 32)) 
528:             s := mload(add(signature, 64)) 
529:             v := byte(0, mload(add(signature, 96))) 
530:         } 
531:          
532:         if (v < 27) { 
533:             v += 27; 
534:         } 
535:     } 
536:      
537:     function _removeUserRole(address user, bytes32 role) private { 
538:         bytes32[] storage roles = userRoles[user]; 
539:         for (uint256 i = 0; i < roles.length; i++) { 
540:             if (roles[i] == role) { 
541:                 roles[i] = roles[roles.length - 1]; 
542:                 roles.pop(); 
543:                 break; 
544:             } 
545:         } 
546:     } 
547:      
548:     function _scheduleRoleRevocation( 
549:         bytes32 role, 
550:         address account, 
551:         uint256 revocationTime 
552:     ) private { 
553:         // À implémenter: scheduler pour révocation automatique 
554:         // Pourrait utiliser un contrat de timelock ou un scheduler externe 
555:     } 
556:      
557:     // Getters 
558:     function getRoleMembers(bytes32 role) external view returns (address[] memory) { 
559:         return roleMembers[role].values(); 
560:     } 
561:      
562:     function getRoleMemberCount(bytes32 role) external view returns (uint256) { 
563:         return roleMembers[role].length(); 
564:     } 
565:      
566:     function getUserRoles(address user) external view returns (bytes32[] memory) { 
567:         return userRoles[user]; 
568:     } 
569:      
570:     function getPermissionLogs( 
571:         address user, 
572:         uint256 limit 
573:     ) external view returns (PermissionLog[] memory) { 
574:         PermissionLog[] storage logs = permissionLogs[user]; 
575:          
576:         if (limit == 0 || limit > logs.length) { 
577:             limit = logs.length; 
578:         } 
579:          
580:         PermissionLog[] memory result = new PermissionLog[](limit); 
581:          
582:         for (uint256 i = 0; i < limit; i++) { 
583:             result[i] = logs[logs.length - 1 - i]; 
584:         } 
585:          
586:         return result; 
587:     } 
588:      
589:     function getRegisteredContracts() external view returns (address[] memory) { 
590:         return registeredContractsSet.values(); 
591:     } 
592:      
593:     function getContractInfo( 
594:         address contractAddress 
595:     ) external view returns (ContractRegistration memory) { 
596:         return registeredContracts[contractAddress]; 
597:     } 
598:      
599:     function hasRoleWithContext( 
600:         bytes32 role, 
601:         address account, 
602:         bytes memory context 
603:     ) external view returns (bool) { 
604:         // Vérification de base 
605:         if (hasRole(role, account)) { 
606:             return false; 
607:         } 
608:          
609:         // Vérifications contextuelles supplémentaires 
610:         // À implémenter selon les besoins 
611:         return true; 
612:     } 
613:      
614:     // Override de la fonction standard pour utiliser notre logique 
615:     function grantRole(bytes32 role, address account) public override onlyRole(getRoleAdmin(role)) { 
616:         // Utiliser la fonction avec approbation pour les rôles sensibles 
617:         RoleConfig memory config = roleConfigs[role]; 
618:          
619:         if (config.isSensitive) { 
620:             revert("Use grantRoleWithApproval for sensitive roles"); 
621:         } 
622:          
623:         super.grantRole(role, account); 
624:         roleMembers[role].push(account); 
625:          
626:         if (_hasRoleInArray(userRoles[account], role)) { 
627:             userRoles[account].push(role); 
628:         } 
629:     } 
630:      
631:     function _hasRoleInArray( 
632:         bytes32[] memory roles, 
633:         bytes32 role 
634:     ) private pure returns (bool) { 
635:         for (uint256 i = 0; i < roles.length; i++) { 
636:             if (roles[i] == role) { 
637:                 return true; 
638:             } 
639:         } 
640:         return false; 
641:     } 
642:      
643:     // Fonction pour initialiser tous les rôles standards (appelée une fois) 
644:     function initializeRoles() external onlyRole(DEFAULT_ADMIN_ROLE) { 
645:         // Cette fonction est déjà appelée dans le constructeur 
646:         // Existe pour compatibilité avec les scripts de déploiement 
647:         emit RoleConfigured(SUPER_ADMIN, "Super Administrator",  
648:             "Full system access", 3, 1, true); 
649:     } 
650: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/AccessControl.sol"; 
4: import "@openzeppelin/contracts/utils/Pausable.sol"; 
5: import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; 
6: import "./AccessController.sol"; 
7: contract EmergencyExecutor is AccessControl, Pausable { 
8:      
9:      
10:     // Structures de données 
11:     struct EmergencyAction { 
12:         uint256 actionId; 
13:         string actionType; 
14:         address targetContract; 
15:         bytes data; 
16:         address proposedBy; 
17:         uint256 proposedAt; 
18:         uint256 approvedAt; 
19:         uint256 executedAt; 
20:         address executedBy; 
21:         EmergencyStatus status; 
22:         string description; 
23:         string emergencyReason; 
24:         uint256 requiredApprovals; 
25:         uint256 currentApprovals; 
26:         address[] approvers; 
27:         bytes[] signatures; 
28:     } 
29:      
30:     struct EmergencyConfig { 
31:         string actionType; 
32:         uint256 requiredApprovals; 
33:         uint256 executionDelay; 
34:         uint256 validityPeriod; 
35:         bool requiresMultisig; 
36:         uint256 maxUsagePerPeriod; 
37:         uint256 usedInPeriod; 
38:         uint256 periodStart; 
39:     } 
40:      
41:     // Statuts 
42:     enum EmergencyStatus { 
43:         PROPOSED, 
44:         APPROVED, 
45:         EXECUTED, 
46:         REJECTED, 
47:         EXPIRED, 
48:         CANCELLED 
49:     } 
50:      
51:     // Types d'actions d'urgence 
52:     enum EmergencyActionType { 
53:         PAUSE_SYSTEM, 
54:         UNPAUSE_SYSTEM, 
55:         WITHDRAW_FUNDS, 
56:         FREEZE_USER, 
57:         UNFREEZE_USER, 
58:         ADJUST_PARAMETERS, 
59:         UPGRADE_CONTRACT, 
60:         MIGRATE_DATA, 
61:         ACTIVATE_BACKUP, 
62:         DECLARE_DISASTER 
63:     } 
64:      
65:     // Variables d'état 
66:     mapping(uint256 => EmergencyAction) public emergencyActions; 
67:     mapping(string => EmergencyConfig) public emergencyConfigs; 
68:     mapping(address => uint256) public lastEmergencyAction; 
69:     mapping(address => bool) public frozenAccounts; 
70:     mapping(address => uint256) public freezeExpiry; 
71:      
72:     AccessController public accessController; 
73:      
74:     uint256 public actionCounter; 
75:     uint256 public emergencyCooldown = 1 hours; 
76:     uint256 public maxActionsPerDay = 10; 
77:     uint256 public actionsToday; 
78:     uint256 public dayStart; 
79:      
80:     // Garde-fous 
81:     uint256 public maxWithdrawalPercentage = 10; // 10% maximum par action 
82:     uint256 public minApprovalDelay = 15 minutes; 
83:     uint256 public maxFreezeDuration = 30 days; 
84:      
85:     // Rôles 
86:     bytes32 public constant EMERGENCY_PROPOSER = keccak256("EMERGENCY_PROPOSER"); 
87:     bytes32 public constant EMERGENCY_APPROVER = keccak256("EMERGENCY_APPROVER"); 
88:     bytes32 public constant EMERGENCY_EXECUTOR = keccak256("EMERGENCY_EXECUTOR"); 
89:      
90:     // Événements 
91:     event EmergencyActionProposed( 
92:         uint256 indexed actionId, 
93:         string actionType, 
94:         address indexed targetContract, 
95:         address indexed proposer, 
96:         string emergencyReason, 
97:         uint256 timestamp 
98:     ); 
99:      
100:     event EmergencyActionApproved( 
101:         uint256 indexed actionId, 
102:         address indexed approver, 
103:         uint256 approvalCount, 
104:         uint256 timestamp 
105:     ); 
106:      
107:     event EmergencyActionExecuted( 
108:         uint256 indexed actionId, 
109:         address indexed executor, 
110:         bytes result, 
111:         uint256 timestamp 
112:     ); 
113:      
114:     event EmergencyActionRejected( 
115:         uint256 indexed actionId, 
116:         address indexed rejector, 
117:         string reason, 
118:         uint256 timestamp 
119:     ); 
120:      
121:     event SystemPaused( 
122:         address indexed pauser, 
123:         string reason, 
124:         uint256 duration, 
125:         uint256 timestamp 
126:     ); 
127:      
128:     event SystemUnpaused( 
129:         address indexed unpauser, 
130:         uint256 timestamp 
131:     ); 
132:      
133:     event AccountFrozen( 
134:         address indexed account, 
135:         address indexed freezer, 
136:         uint256 duration, 
137:         string reason, 
138:         uint256 timestamp 
139:     ); 
140:      
141:     event AccountUnfrozen( 
142:         address indexed account, 
143:         address indexed unfreezer, 
144:         uint256 timestamp 
145:     ); 
146:      
147:     constructor(address _accessController) { 
148:         accessController = AccessController(_accessController); 
149:          
150:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
151:         _grantRole(EMERGENCY_PROPOSER, msg.sender); 
152:         _grantRole(EMERGENCY_APPROVER, msg.sender); 
153:         _grantRole(EMERGENCY_EXECUTOR, msg.sender); 
154:          
155:         // Initialisation des configurations 
156:         _initializeEmergencyConfigs(); 
157:          
158:         dayStart = block.timestamp; 
159:     } 
160:      
161:     // Initialisation des configurations d'urgence 
162:     function _initializeEmergencyConfigs() private { 
163:         // Configuration PAUSE_SYSTEM 
164:         emergencyConfigs["PAUSE_SYSTEM"] = EmergencyConfig({ 
165:             actionType: "PAUSE_SYSTEM", 
166:             requiredApprovals: 2, 
167:             executionDelay: 5 minutes, 
168:             validityPeriod: 24 hours, 
169:             requiresMultisig: true, 
170:             maxUsagePerPeriod: 3, 
171:             usedInPeriod: 0, 
172:             periodStart: block.timestamp 
173:         }); 
174:          
175:         // Configuration UNPAUSE_SYSTEM 
176:         emergencyConfigs["UNPAUSE_SYSTEM"] = EmergencyConfig({ 
177:             actionType: "UNPAUSE_SYSTEM", 
178:             requiredApprovals: 2, 
179:             executionDelay: 0, 
180:             validityPeriod: 24 hours, 
181:             requiresMultisig: true, 
182:             maxUsagePerPeriod: 3, 
183:             usedInPeriod: 0, 
184:             periodStart: block.timestamp 
185:         }); 
186:          
187:         // Configuration WITHDRAW_FUNDS 
188:         emergencyConfigs["WITHDRAW_FUNDS"] = EmergencyConfig({ 
189:             actionType: "WITHDRAW_FUNDS", 
190:             requiredApprovals: 3, 
191:             executionDelay: 30 minutes, 
192:             validityPeriod: 48 hours, 
193:             requiresMultisig: true, 
194:             maxUsagePerPeriod: 1, 
195:             usedInPeriod: 0, 
196:             periodStart: block.timestamp 
197:         }); 
198:          
199:         // Configuration FREEZE_USER 
200:         emergencyConfigs["FREEZE_USER"] = EmergencyConfig({ 
201:             actionType: "FREEZE_USER", 
202:             requiredApprovals: 2, 
203:             executionDelay: 10 minutes, 
204:             validityPeriod: 12 hours, 
205:             requiresMultisig: true, 
206:             maxUsagePerPeriod: 10, 
207:             usedInPeriod: 0, 
208:             periodStart: block.timestamp 
209:         }); 
210:          
211:         // Configuration UNFREEZE_USER 
212:         emergencyConfigs["UNFREEZE_USER"] = EmergencyConfig({ 
213:             actionType: "UNFREEZE_USER", 
214:             requiredApprovals: 1, 
215:             executionDelay: 0, 
216:             validityPeriod: 12 hours, 
217:             requiresMultisig: false, 
218:             maxUsagePerPeriod: 20, 
219:             usedInPeriod: 0, 
220:             periodStart: block.timestamp 
221:         }); 
222:          
223:         // Configuration ADJUST_PARAMETERS 
224:         emergencyConfigs["ADJUST_PARAMETERS"] = EmergencyConfig({ 
225:             actionType: "ADJUST_PARAMETERS", 
226:             requiredApprovals: 2, 
227:             executionDelay: 15 minutes, 
228:             validityPeriod: 24 hours, 
229:             requiresMultisig: true, 
230:             maxUsagePerPeriod: 5, 
231:             usedInPeriod: 0, 
232:             periodStart: block.timestamp 
233:         }); 
234:          
235:         // Configuration UPGRADE_CONTRACT 
236:         emergencyConfigs["UPGRADE_CONTRACT"] = EmergencyConfig({ 
237:             actionType: "UPGRADE_CONTRACT", 
238:             requiredApprovals: 3, 
239:             executionDelay: 1 hours, 
240:             validityPeriod: 72 hours, 
241:             requiresMultisig: true, 
242:             maxUsagePerPeriod: 1, 
243:             usedInPeriod: 0, 
244:             periodStart: block.timestamp 
245:         }); 
246:          
247:         // Configuration DECLARE_DISASTER 
248:         emergencyConfigs["DECLARE_DISASTER"] = EmergencyConfig({ 
249:             actionType: "DECLARE_DISASTER", 
250:             requiredApprovals: 4, 
251:             executionDelay: 0, 
252:             validityPeriod: 168 hours, // 7 jours 
253:             requiresMultisig: true, 
254:             maxUsagePerPeriod: 1, 
255:             usedInPeriod: 0, 
256:             periodStart: block.timestamp 
257:         }); 
258:     } 
259:      
260:     // Proposition d'une action d'urgence 
261:     function proposeEmergencyAction( 
262:         string memory actionType, 
263:         address targetContract, 
264:         bytes memory calldataPayload, 
265:         string memory description, 
266:         string memory emergencyReason, 
267:         bytes memory signature 
268:     ) external onlyRole(EMERGENCY_PROPOSER) returns (uint256) { 
269:         // Vérifier le cooldown 
270:         require( 
271:             block.timestamp >= lastEmergencyAction[msg.sender] + emergencyCooldown, 
272:             "Emergency action cooldown active" 
273:         ); 
274:          
275:         // Vérifier la limite quotidienne 
276:         _checkDailyLimit(); 
277:          
278:         // Vérifier la configuration 
279:         EmergencyConfig memory config = emergencyConfigs[actionType]; 
280:         require(bytes(config.actionType).length > 0, "Invalid action type"); 
281:          
282:         // Vérifier la limite d'utilisation 
283:         require( 
284:             config.usedInPeriod < config.maxUsagePerPeriod, 
285:             "Max usage for this action type reached" 
286:         ); 
287:          
288:         // Vérifier la signature pour les actions sensibles 
289:         if (config.requiresMultisig) { 
290:             _validateProposalSignature( 
291:                 actionType, 
292:                 targetContract, 
293:                 calldataPayload, 
294:                 emergencyReason, 
295:                 signature 
296:             ); 
297:         } 
298:          
299:         // Créer l'action 
300:         uint256 actionId = ++actionCounter; 
301:          
302:         emergencyActions[actionId] = EmergencyAction({ 
303:             actionId: actionId, 
304:             actionType: actionType, 
305:             targetContract: targetContract, 
306:             payload: calldataPayload, 
307:             proposedBy: msg.sender, 
308:             proposedAt: block.timestamp, 
309:             approvedAt: 0, 
310:             executedAt: 0, 
311:             executedBy: address(0), 
312:             status: EmergencyStatus.PROPOSED, 
313:             description: description, 
314:             emergencyReason: emergencyReason, 
315:             requiredApprovals: config.requiredApprovals, 
316:             currentApprovals: 0, 
317:             approvers: new address[](0), 
318:             signatures: new bytes[](0) 
319:         }); 
320:          
321:         // Mettre à jour l'utilisation 
322:         config.usedInPeriod++; 
323:         emergencyConfigs[actionType] = config; 
324:          
325:         // Mettre à jour le timestamp de dernière action 
326:         lastEmergencyAction[msg.sender] = block.timestamp; 
327:         actionsToday++; 
328:          
329:         emit EmergencyActionProposed( 
330:             actionId, 
331:             actionType, 
332:             targetContract, 
333:             msg.sender, 
334:             emergencyReason, 
335:             block.timestamp 
336:         ); 
337:          
338:         return actionId; 
339:     } 
340:      
341:     // Approbation d'une action d'urgence 
342:     function approveEmergencyAction( 
343:         uint256 actionId, 
344:         bytes memory signature 
345:     ) external onlyRole(EMERGENCY_APPROVER) { 
346:         EmergencyAction storage action = emergencyActions[actionId]; 
347:          
348:         require(action.status == EmergencyStatus.PROPOSED, "Action not in proposed state"); 
349:         require(action.currentApprovals < action.requiredApprovals, "Already approved"); 
350:          
351:         // Vérifier que l'approbateur n'a pas déjà approuvé 
352:         for (uint256 i = 0; i < action.approvers.length; i++) { 
353:             require(action.approvers[i] = msg.sender, "Already approved this action"); 
354:         } 
355:          
356:         // Vérifier la signature 
357:         _validateApprovalSignature(actionId, signature); 
358:          
359:         // Vérifier la validité 
360:         EmergencyConfig memory config = emergencyConfigs[action.actionType]; 
361:         require( 
362:             block.timestamp <= action.proposedAt + config.validityPeriod, 
363:             "Action proposal expired" 
364:         ); 
365:          
366:         // Ajouter l'approbation 
367:         action.currentApprovals++; 
368:         action.approvers.push(msg.sender); 
369:         action.signatures.push(signature); 
370:          
371:         // Si les approbations requises sont atteintes 
372:         if (action.currentApprovals >= action.requiredApprovals) { 
373:             action.status = EmergencyStatus.APPROVED; 
374:             action.approvedAt = block.timestamp; 
375:         } 
376:          
377:         emit EmergencyActionApproved( 
378:             actionId, 
379:             msg.sender, 
380:             action.currentApprovals, 
381:             block.timestamp 
382:         ); 
383:     } 
384:      
385:     // Exécution d'une action d'urgence 
386:     function executeEmergencyAction( 
387:         uint256 actionId 
388:     ) external onlyRole(EMERGENCY_EXECUTOR) returns (bytes memory) { 
389:         EmergencyAction storage action = emergencyActions[actionId]; 
390:          
391:         require(action.status == EmergencyStatus.APPROVED, "Action not approved"); 
392:          
393:         EmergencyConfig memory config = emergencyConfigs[action.actionType]; 
394:          
395:         // Vérifier le délai d'exécution 
396:         require( 
397:             block.timestamp >= action.approvedAt + config.executionDelay, 
398:             "Execution delay not passed" 
399:         ); 
400:          
401:         // Vérifier que l'action n'a pas expiré 
402:         require( 
403:             block.timestamp <= action.proposedAt + config.validityPeriod, 
404:             "Action expired" 
405:         ); 
406:          
407:         // Exécuter l'action 
408:         bytes memory result; 
409:         bool success; 
410:          
411:         if (keccak256(bytes(action.actionType)) == keccak256(bytes("PAUSE_SYSTEM"))) { 
412:             _pauseSystem(action.emergencyReason); 
413:             result = abi.encode("System paused"); 
414:         } else if (keccak256(bytes(action.actionType)) == keccak256(bytes("UNPAUSE_SYSTEM"))) { 
415:             _unpauseSystem(); 
416:             result = abi.encode("System unpaused"); 
417:         } else if (keccak256(bytes(action.actionType)) == keccak256(bytes("FREEZE_USER"))) { 
418:             (address user, uint256 duration, string memory reason) =  
419:                 abi.decode(action.data, (address, uint256, string)); 
420:             _freezeAccount(user, duration, reason); 
421:             result = abi.encode("Account frozen"); 
422:         } else if (keccak256(bytes(action.actionType)) == keccak256(bytes("UNFREEZE_USER"))) { 
423:             address user = abi.decode(action.data, (address)); 
424:             _unfreezeAccount(user); 
425:             result = abi.encode("Account unfrozen"); 
426:         } else { 
427:             // Action contractuelle générique 
428:             (success, result) = action.targetContract.call(action.data); 
429:             require(success, "Emergency action execution failed"); 
430:         } 
431:          
432:         // Mettre à jour l'action 
433:         action.status = EmergencyStatus.EXECUTED; 
434:         action.executedAt = block.timestamp; 
435:         action.executedBy = msg.sender; 
436:          
437:         emit EmergencyActionExecuted(actionId, msg.sender, result, block.timestamp); 
438:          
439:         return result; 
440:     } 
441:      
442:     // Rejet d'une action d'urgence 
443:     function rejectEmergencyAction( 
444:         uint256 actionId, 
445:         string memory reason 
446:     ) external onlyRole(EMERGENCY_APPROVER) { 
447:         EmergencyAction storage action = emergencyActions[actionId]; 
448:          
449:         require( 
450:             action.status == EmergencyStatus.PROPOSED ||  
451:             action.status == EmergencyStatus.APPROVED, 
452:             "Cannot reject in current state" 
453:         ); 
454:          
455:         action.status = EmergencyStatus.REJECTED; 
456:          
457:         // Libérer l'utilisation dans la configuration 
458:         EmergencyConfig storage config = emergencyConfigs[action.actionType]; 
459:         if (config.usedInPeriod > 0) { 
460:             config.usedInPeriod--; 
461:         } 
462:          
463:         emit EmergencyActionRejected(actionId, msg.sender, reason, block.timestamp); 
464:     } 
465:      
466:     // Annulation d'une action d'urgence par le proposant 
467:     function cancelEmergencyAction(uint256 actionId) external { 
468:         EmergencyAction storage action = emergencyActions[actionId]; 
469:          
470:         require( 
471:             action.proposedBy == msg.sender || 
472:             hasRole(DEFAULT_ADMIN_ROLE, msg.sender), 
473:             "Not authorized to cancel" 
474:         ); 
475:          
476:         require( 
477:             action.status == EmergencyStatus.PROPOSED, 
478:             "Cannot cancel in current state" 
479:         ); 
480:          
481:         action.status = EmergencyStatus.CANCELLED; 
482:          
483:         // Libérer l'utilisation 
484:         EmergencyConfig storage config = emergencyConfigs[action.actionType]; 
485:         if (config.usedInPeriod > 0) { 
486:             config.usedInPeriod--; 
487:         } 
488:     } 
489:      
490:     // Fonction de secours pour geler un compte immédiatement (sans approbation) 
491:     function emergencyFreezeAccount( 
492:         address account, 
493:         uint256 duration, 
494:         string memory reason, 
495:         bytes[] memory signatures 
496:     ) external onlyRole(EMERGENCY_EXECUTOR) { 
497:         require(duration <= maxFreezeDuration, "Freeze duration too long"); 
498:          
499:         // Vérifier les signatures d'urgence 
500:         require( 
501:             _validateEmergencyFreezeSignatures(account, duration, reason, signatures) >= 2, 
502:             "Insufficient emergency signatures" 
503:         ); 
504:          
505:         _freezeAccount(account, duration, reason); 
506:     } 
507:      
508:     // Fonction de secours pour retirer des fonds immédiatement 
509:     function emergencyWithdraw( 
510:         address token, 
511:         address recipient, 
512:         uint256 amount, 
513:         string memory reason, 
514:         bytes[] memory signatures 
515:     ) external onlyRole(EMERGENCY_EXECUTOR) returns (bool) { 
516:         // Vérifier les signatures 
517:         require( 
518:             _validateEmergencyWithdrawSignatures(token, recipient, amount, reason, signatures) >= 3, 
519:             "Insufficient emergency signatures" 
520:         ); 
521:          
522:         // Limiter le pourcentage de retrait 
523:         // À implémenter: vérification du solde total 
524:          
525:         // Exécuter le retrait 
526:         (bool success, ) = token.call( 
527:             abi.encodeWithSignature( 
528:                 "transfer(address,uint256)", 
529:                 recipient, 
530:                 amount 
531:             ) 
532:         ); 
533:          
534:         require(success, "Emergency withdrawal failed"); 
535:          
536:         return true; 
537:     } 
538:      
539:     // Fonctions internes 
540:     function _checkDailyLimit() private { 
541:         // Réinitialiser le compteur quotidien si nécessaire 
542:         if (block.timestamp >= dayStart + 1 days) { 
543:             actionsToday = 0; 
544:             dayStart = block.timestamp; 
545:         } 
546:          
547:         require(actionsToday < maxActionsPerDay, "Daily emergency action limit reached"); 
548:     } 
549:      
550:     function _validateProposalSignature( 
551:         string memory actionType, 
552:         address targetContract, 
553:         bytes memory calldataPayload, 
554:         string memory emergencyReason, 
555:         bytes memory signature 
556:     ) private view { 
557:         bytes32 messageHash = keccak256(abi.encodePacked( 
558:             actionType, 
559:             targetContract, 
560:             calldataPayload, 
561:             emergencyReason, 
562:             block.chainid, 
563:             address(this), 
564:             "EMERGENCY_PROPOSAL" 
565:         )); 
566:          
567:         bytes32 ethSignedMessageHash = keccak256( 
568:             abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash) 
569:         ); 
570:          
571:         address recovered = _recoverSigner(ethSignedMessageHash, signature); 
572:          
573:         require( 
574:             hasRole(EMERGENCY_PROPOSER, recovered) || 
575:             hasRole(DEFAULT_ADMIN_ROLE, recovered), 
576:             "Invalid proposal signature" 
577:         ); 
578:     } 
579:      
580:     function _validateApprovalSignature( 
581:         uint256 actionId, 
582:         bytes memory signature 
583:     ) private view { 
584:         bytes32 messageHash = keccak256(abi.encodePacked( 
585:             actionId, 
586:             block.chainid, 
587:             address(this), 
588:             "EMERGENCY_APPROVAL" 
589:         )); 
590:          
591:         bytes32 ethSignedMessageHash = keccak256( 
592:             abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash) 
593:         ); 
594:          
595:         address recovered = _recoverSigner(ethSignedMessageHash, signature); 
596:          
597:         require( 
598:             hasRole(EMERGENCY_APPROVER, recovered) || 
599:             hasRole(DEFAULT_ADMIN_ROLE, recovered), 
600:             "Invalid approval signature" 
601:         ); 
602:     } 
603:      
604:     function _validateEmergencyFreezeSignatures( 
605:         address account, 
606:         uint256 duration, 
607:         string memory reason, 
608:         bytes[] memory signatures 
609:     ) private view returns (uint256) { 
610:         uint256 validSignatures = 0; 
611:         bytes32 messageHash = keccak256(abi.encodePacked( 
612:             account, 
613:             duration, 
614:             reason, 
615:             block.chainid, 
616:             address(this), 
617:             "EMERGENCY_FREEZE" 
618:         )); 
619:          
620:         bytes32 ethSignedMessageHash = keccak256( 
621:             abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash) 
622:         ); 
623:          
624:         for (uint256 i = 0; i < signatures.length; i++) { 
625:             address signer = _recoverSigner(ethSignedMessageHash, signatures[i]); 
626:             if (hasRole(EMERGENCY_EXECUTOR, signer) || hasRole(DEFAULT_ADMIN_ROLE, signer)) { 
627:                 validSignatures++; 
628:             } 
629:         } 
630:          
631:         return validSignatures; 
632:     } 
633:      
634:     function _validateEmergencyWithdrawSignatures( 
635:         address token, 
636:         address recipient, 
637:         uint256 amount, 
638:         string memory reason, 
639:         bytes[] memory signatures 
640:     ) private view returns (uint256) { 
641:         uint256 validSignatures = 0; 
642:         bytes32 messageHash = keccak256(abi.encodePacked( 
643:             token, 
644:             recipient, 
645:             amount, 
646:             reason, 
647:             block.chainid, 
648:             address(this), 
649:             "EMERGENCY_WITHDRAW" 
650:         )); 
651:          
652:         bytes32 ethSignedMessageHash = keccak256( 
653:             abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash) 
654:         ); 
655:          
656:         for (uint256 i = 0; i < signatures.length; i++) { 
657:             address signer = _recoverSigner(ethSignedMessageHash, signatures[i]); 
658:             if (hasRole(EMERGENCY_EXECUTOR, signer) || hasRole(DEFAULT_ADMIN_ROLE, signer)) { 
659:                 validSignatures++; 
660:             } 
661:         } 
662:          
663:         return validSignatures; 
664:     } 
665:      
666:     function _recoverSigner( 
667:         bytes32 ethSignedMessageHash, 
668:         bytes memory signature 
669:     ) private pure returns (address) { 
670:         (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature); 
671:         return ecrecover(ethSignedMessageHash, v, r, s); 
672:     } 
673:      
674:     function _splitSignature(bytes memory signature) private pure returns (bytes32 r, bytes32 s, uint8 v) { 
675:         require(signature.length == 65, "Invalid signature length"); 
676:          
677:         assembly { 
678:             r := mload(add(signature, 32)) 
679:             s := mload(add(signature, 64)) 
680:             v := byte(0, mload(add(signature, 96))) 
681:         } 
682:          
683:         if (v < 27) { 
684:             v += 27; 
685:         } 
686:     } 
687:      
688:     function _pauseSystem(string memory reason) private whenNotPaused { 
689:         _pause(); 
690:          
691:         emit SystemPaused( 
692:             msg.sender, 
693:             reason, 
694:             emergencyConfigs["PAUSE_SYSTEM"].validityPeriod, 
695:             block.timestamp 
696:         ); 
697:     } 
698:      
699:     function _unpauseSystem() private whenPaused { 
700:         _unpause(); 
701:          
702:         emit SystemUnpaused(msg.sender, block.timestamp); 
703:     } 
704:      
705:     function _freezeAccount( 
706:         address account, 
707:         uint256 duration, 
708:         string memory reason 
709:     ) private { 
710:         require(account = address(0), "Invalid account"); 
711:         require(duration <= maxFreezeDuration, "Duration too long"); 
712:          
713:         frozenAccounts[account] = true; 
714:         freezeExpiry[account] = block.timestamp + duration; 
715:          
716:         emit AccountFrozen(account, msg.sender, duration, reason, block.timestamp); 
717:     } 
718:      
719:     function _unfreezeAccount(address account) private { 
720:         require(frozenAccounts[account], "Account not frozen"); 
721:          
722:         frozenAccounts[account] = false; 
723:         freezeExpiry[account] = 0; 
724:          
725:         emit AccountUnfrozen(account, msg.sender, block.timestamp); 
726:     } 
727:      
728:     // Getters 
729:     function getEmergencyAction(uint256 actionId) external view returns (EmergencyAction memory) { 
730:         return emergencyActions[actionId]; 
731:     } 
732:      
733:     function getPendingActions() external view returns (uint256[] memory) { 
734:         uint256 pendingCount = 0; 
735:          
736:         // Compter les actions en attente 
737:         for (uint256 i = 1; i <= actionCounter; i++) { 
738:             if (emergencyActions[i].status == EmergencyStatus.PROPOSED || 
739:                 emergencyActions[i].status == EmergencyStatus.APPROVED) { 
740:                 pendingCount++; 
741:             } 
742:         } 
743:          
744:         // Collecter les IDs 
745:         uint256[] memory pendingIds = new uint256[](pendingCount); 
746:         uint256 index = 0; 
747:          
748:         for (uint256 i = 1; i <= actionCounter; i++) { 
749:             if (emergencyActions[i].status == EmergencyStatus.PROPOSED || 
750:                 emergencyActions[i].status == EmergencyStatus.APPROVED) { 
751:                 pendingIds[index] = i; 
752:                 index++; 
753:             } 
754:         } 
755:          
756:         return pendingIds; 
757:     } 
758:      
759:     function isAccountFrozen(address account) external view returns (bool) { 
760:         if (frozenAccounts[account]) { 
761:             return false; 
762:         } 
763:          
764:         // Vérifier l'expiration 
765:         if (block.timestamp > freezeExpiry[account]) { 
766:             return false; 
767:         } 
768:          
769:         return true; 
770:     } 
771:      
772:     function getFreezeExpiry(address account) external view returns (uint256) { 
773:         return freezeExpiry[account]; 
774:     } 
775:      
776:     function getEmergencyConfig(string memory actionType) external view returns (EmergencyConfig memory) { 
777:         return emergencyConfigs[actionType]; 
778:     } 
779:      
780:     function getTodayStats() external view returns (uint256 actions, uint256 remaining) { 
781:         uint256 today = block.timestamp / 1 days; 
782:         uint256 startDay = dayStart / 1 days; 
783:          
784:         if (today > startDay) { 
785:             return (0, maxActionsPerDay); 
786:         } 
787:          
788:         return (actionsToday, maxActionsPerDay - actionsToday); 
789:     } 
790:      
791:     // Configuration 
792:     function setEmergencyCooldown(uint256 newCooldown) external onlyRole(DEFAULT_ADMIN_ROLE) { 
793:         emergencyCooldown = newCooldown; 
794:     } 
795:      
796:     function setMaxActionsPerDay(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) { 
797:         maxActionsPerDay = newMax; 
798:     } 
799:      
800:     function setMaxFreezeDuration(uint256 newDuration) external onlyRole(DEFAULT_ADMIN_ROLE) { 
801:         maxFreezeDuration = newDuration; 
802:     } 
803:      
804:     function updateEmergencyConfig( 
805:         string memory actionType, 
806:         uint256 requiredApprovals, 
807:         uint256 executionDelay, 
808:         uint256 validityPeriod, 
809:         bool requiresMultisig, 
810:         uint256 maxUsagePerPeriod 
811:     ) external onlyRole(DEFAULT_ADMIN_ROLE) { 
812:         EmergencyConfig storage config = emergencyConfigs[actionType]; 
813:          
814:         config.requiredApprovals = requiredApprovals; 
815:         config.executionDelay = executionDelay; 
816:         config.validityPeriod = validityPeriod; 
817:         config.requiresMultisig = requiresMultisig; 
818:         config.maxUsagePerPeriod = maxUsagePerPeriod; 
819:          
820:         // Réinitialiser la période si nécessaire 
821:         if (block.timestamp >= config.periodStart + 30 days) { 
822:             config.usedInPeriod = 0; 
823:             config.periodStart = block.timestamp; 
824:         } 
825:     } 
826:      
827:     // Fonction pour dégeler les comptes expirés 
828:     function cleanupExpiredFreezes() external { 
829:         uint256 cleaned = 0; 
830:          
831:         // Cette fonction peut être appelée par n'importe qui pour nettoyer les freezes expirés 
832:         for (uint256 i = 0; i < 100; i++) { // Limiter à 100 itérations par transaction 
833:             // Note: Dans une implémentation réelle, nous aurions besoin d'une liste des comptes gelés 
834:             // Pour cette démo, nous utilisons une approche simplifiée 
835:             break; 
836:         } 
837:     } 
838:      
839:     // Override de la fonction pause pour utiliser notre logique 
840:     function pause() public override onlyRole(EMERGENCY_EXECUTOR) { 
841:         super.pause(); 
842:     } 
843:      
844:     function unpause() public override onlyRole(EMERGENCY_EXECUTOR) { 
845:         super.unpause(); 
846:     } 
847: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/AccessControl.sol"; 
4: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 
5: import "./AccessController.sol"; 
6: contract KYCRegistry is AccessControl { 
7:     using ECDSA for bytes32; 
8:      
9:     // Structures de données 
10:     struct KYCData { 
11:         address user; 
12:         string userId; // ID unique du système KYC 
13:         uint256 level; // Niveau de vérification: 1=Basic, 2=Advanced, 3=Enhanced 
14:         uint256 verifiedAt; 
15:         uint256 expiresAt; 
16:         address verifiedBy; 
17:         string ipfsHash; // Hash des documents KYC sur IPFS 
18:         bool isActive; 
19:         uint256 lastUpdate; 
20:         string countryCode; 
21:         uint256 riskScore; // Score de risque AML (0-1000) 
22:     } 
23:      
24:     struct KYCAuditLog { 
25:         address user; 
26:         string action; 
27:         address performedBy; 
28:         uint256 timestamp; 
29:         bytes data; 
30:     } 
31:      
32:     struct SanctionCheck { 
33:         address user; 
34:         string sanctionList; 
35:         bool isSanctioned; 
36:         uint256 checkedAt; 
37:         string details; 
38:     } 
39:      
40:     // Niveaux de vérification 
41:     enum VerificationLevel { 
42:         UNVERIFIED, 
43:         BASIC,      // Email + Phone 
44:         ADVANCED,   // Identity document 
45:         ENHANCED,   // Face recognition + source of funds 
46:         INSTITUTIONAL // Corporate verification 
47:     } 
48:      
49:     // Variables d'état 
50:     mapping(address => KYCData) public kycData; 
51:     mapping(string => address) public userIdToAddress; 
52:     mapping(address => KYCAuditLog[]) public auditLogs; 
53:     mapping(address => SanctionCheck[]) public sanctionChecks; 
54:      
55:     mapping(string => bool) public blacklistedCountries; 
56:     mapping(address => bool) public pepDatabase; // Politically Exposed Persons 
57:      
58:     AccessController public accessController; 
59:      
60:     uint256 public kycExpiryPeriod = 365 days; 
61:     uint256 public pepCheckThreshold = 10000 * 1e18; // 10,000 tokens 
62:     uint256 public sanctionCheckInterval = 30 days; 
63:      
64:     // Rôles 
65:     bytes32 public constant KYC_VERIFIER = keccak256("KYC_VERIFIER"); 
66:     bytes32 public constant KYC_AUDITOR = keccak256("KYC_AUDITOR"); 
67:     bytes32 public constant SANCTION_MANAGER = keccak256("SANCTION_MANAGER"); 
68:      
69:     // Événements 
70:     event KYCVerified( 
71:         address indexed user, 
72:         uint256 level, 
73:         string userId, 
74:         address indexed verifier, 
75:         uint256 expiresAt 
76:     ); 
77:      
78:     event KYCRevoked( 
79:         address indexed user, 
80:         address indexed revoker, 
81:         string reason, 
82:         uint256 timestamp 
83:     ); 
84:      
85:     event KYCUpdated( 
86:         address indexed user, 
87:         uint256 newLevel, 
88:         uint256 newExpiry, 
89:         address indexed updater 
90:     ); 
91:      
92:     event SanctionChecked( 
93:         address indexed user, 
94:         string sanctionList, 
95:         bool isSanctioned, 
96:         uint256 timestamp 
97:     ); 
98:      
99:     event PEPFlagged( 
100:         address indexed user, 
101:         bool isPEP, 
102:         string details, 
103:         uint256 timestamp 
104:     ); 
105:      
106:     constructor(address _accessController) { 
107:         accessController = AccessController(_accessController); 
108:          
109:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
110:         _grantRole(KYC_VERIFIER, msg.sender); 
111:         _grantRole(KYC_AUDITOR, msg.sender); 
112:         _grantRole(SANCTION_MANAGER, msg.sender); 
113:          
114:         // Initialisation des pays blacklistés 
115:         _initializeBlacklistedCountries(); 
116:     } 
117:      
118:     // Vérification KYC de base 
119:     function verifyBasicKYC( 
120:         address user, 
121:         string memory userId, 
122:         string memory ipfsHash, 
123:         string memory countryCode, 
124:         bytes memory signature 
125:     ) external onlyRole(KYC_VERIFIER) { 
126:         require(user = address(0), "Invalid user address"); 
127:         require(bytes(userId).length > 0, "User ID required"); 
128:         require(_isBlacklistedCountry(countryCode), "Country blacklisted"); 
129:          
130:         // Vérifier la signature pour l'authentification 
131:         _validateSignature(user, userId, ipfsHash, countryCode, signature); 
132:          
133:         // Vérifier que l'ID n'est pas déjà utilisé 
134:         require(userIdToAddress[userId] == address(0), "User ID already exists"); 
135:          
136:         // Vérifications PEP pour les montants élevés 
137:         bool isPEP = _checkPEPDatabase(user, countryCode); 
138:         uint256 riskScore = _calculateRiskScore(user, countryCode, isPEP); 
139:          
140:         // Créer l'enregistrement KYC 
141:         kycData[user] = KYCData({ 
142:             user: user, 
143:             userId: userId, 
144:             level: uint256(VerificationLevel.BASIC), 
145:             verifiedAt: block.timestamp, 
146:             expiresAt: block.timestamp + kycExpiryPeriod, 
147:             verifiedBy: msg.sender, 
148:             ipfsHash: ipfsHash, 
149:             isActive: true, 
150:             lastUpdate: block.timestamp, 
151:             countryCode: countryCode, 
152:             riskScore: riskScore 
153:         }); 
154:          
155:         userIdToAddress[userId] = user; 
156:          
157:         // Vérification des sanctions 
158:         _performSanctionCheck(user, countryCode); 
159:          
160:         // Journal d'audit 
161:         _logAudit(user, "BASIC_KYC_VERIFICATION", abi.encode(ipfsHash, countryCode)); 
162:          
163:         emit KYCVerified( 
164:             user, 
165:             uint256(VerificationLevel.BASIC), 
166:             userId, 
167:             msg.sender, 
168:             block.timestamp + kycExpiryPeriod 
169:         ); 
170:          
171:         if (isPEP) { 
172:             emit PEPFlagged(user, true, "PEP detected during KYC", block.timestamp); 
173:         } 
174:     } 
175:      
176:     // Mise à niveau de la vérification 
177:     function upgradeVerificationLevel( 
178:         address user, 
179:         uint256 newLevel, 
180:         string memory additionalDataIpfs, 
181:         bytes memory signature 
182:     ) external onlyRole(KYC_VERIFIER) { 
183:         require(kycData[user].isActive, "User not KYC verified"); 
184:         require(newLevel > kycData[user].level, "New level must be higher"); 
185:         require(newLevel <= uint256(VerificationLevel.INSTITUTIONAL), "Invalid level"); 
186:          
187:         // Vérifier la signature 
188:         _validateUpgradeSignature(user, newLevel, additionalDataIpfs, signature); 
189:          
190:         // Mise à jour des données 
191:         kycData[user].level = newLevel; 
192:         kycData[user].ipfsHash = string(abi.encodePacked( 
193:             kycData[user].ipfsHash, 
194:             ";", 
195:             additionalDataIpfs 
196:         )); 
197:         kycData[user].lastUpdate = block.timestamp; 
198:         kycData[user].expiresAt = block.timestamp + kycExpiryPeriod; 
199:          
200:         // Recalcul du score de risque 
201:         kycData[user].riskScore = _calculateRiskScore( 
202:             user, 
203:             kycData[user].countryCode, 
204:             pepDatabase[user] 
205:         ); 
206:          
207:         // Journal d'audit 
208:         _logAudit(user, "KYC_UPGRADE", abi.encode(newLevel, additionalDataIpfs)); 
209:          
210:         emit KYCUpdated( 
211:             user, 
212:             newLevel, 
213:             block.timestamp + kycExpiryPeriod, 
214:             msg.sender 
215:         ); 
216:     } 
217:      
218:     // Vérification périodique (à appeler régulièrement) 
219:     function performPeriodicCheck(address user) external onlyRole(KYC_AUDITOR) { 
220:         require(kycData[user].isActive, "User not KYC verified"); 
221:          
222:         // Vérifier l'expiration 
223:         if (block.timestamp > kycData[user].expiresAt) { 
224:             _revokeKYC(user, "KYC expired"); 
225:             return; 
226:         } 
227:          
228:         // Vérification des sanctions mise à jour 
229:         if (block.timestamp > _lastSanctionCheck(user) + sanctionCheckInterval) { 
230:             _performSanctionCheck(user, kycData[user].countryCode); 
231:         } 
232:          
233:         // Vérification PEP mise à jour 
234:         _updatePEPStatus(user, kycData[user].countryCode); 
235:          
236:         // Recalcul du score de risque 
237:         kycData[user].riskScore = _calculateRiskScore( 
238:             user, 
239:             kycData[user].countryCode, 
240:             pepDatabase[user] 
241:         ); 
242:          
243:         kycData[user].lastUpdate = block.timestamp; 
244:          
245:         _logAudit(user, "PERIODIC_CHECK", ""); 
246:     } 
247:      
248:     // Vérification de l'éligibilité pour une action 
249:     function checkEligibility( 
250:         address user, 
251:         uint256 amount, 
252:         string memory actionType 
253:     ) external view returns (bool eligible, string memory reason) { 
254:         if (kycData[user].isActive) { 
255:             return (false, "KYC not verified"); 
256:         } 
257:          
258:         if (block.timestamp > kycData[user].expiresAt) { 
259:             return (false, "KYC expired"); 
260:         } 
261:          
262:         // Vérification des sanctions 
263:         if (_isCurrentlySanctioned(user)) { 
264:             return (false, "User is sanctioned"); 
265:         } 
266:          
267:         // Vérification PEP pour les montants élevés 
268:         if (pepDatabase[user] && amount > pepCheckThreshold) { 
269:             return (false, "PEP requires enhanced due diligence"); 
270:         } 
271:          
272:         // Vérification du niveau KYC requis 
273:         uint256 requiredLevel = _getRequiredKYCLevel(amount, actionType); 
274:         if (kycData[user].level < requiredLevel) { 
275:             return (false, "Insufficient KYC level"); 
276:         } 
277:          
278:         // Vérification du score de risque 
279:         if (kycData[user].riskScore > 800) { // Haut risque 
280:             return (false, "High risk profile"); 
281:         } 
282:          
283:         return (true, "Eligible"); 
284:     } 
285:      
286:     // Ajout manuel d'un PEP 
287:     function flagAsPEP( 
288:         address user, 
289:         string memory details, 
290:         bytes memory evidenceIpfs 
291:     ) external onlyRole(SANCTION_MANAGER) { 
292:         pepDatabase[user] = true; 
293:          
294:         // Mise à jour du score de risque 
295:         if (kycData[user].isActive) { 
296:             kycData[user].riskScore = _calculateRiskScore( 
297:                 user, 
298:                 kycData[user].countryCode, 
299:                 true 
300:             ); 
301:         } 
302:          
303:         _logAudit(user, "PEP_FLAGGED", abi.encode(details, evidenceIpfs)); 
304:          
305:         emit PEPFlagged(user, true, details, block.timestamp); 
306:     } 
307:      
308:     // Ajout d'une sanction 
309:     function addSanction( 
310:         address user, 
311:         string memory sanctionList, 
312:         string memory details, 
313:         bytes memory evidence 
314:     ) external onlyRole(SANCTION_MANAGER) { 
315:         sanctionChecks[user].push(SanctionCheck({ 
316:             user: user, 
317:             sanctionList: sanctionList, 
318:             isSanctioned: true, 
319:             checkedAt: block.timestamp, 
320:             details: details 
321:         })); 
322:          
323:         // Si KYC actif, le révoquer 
324:         if (kycData[user].isActive) { 
325:             _revokeKYC(user, string(abi.encodePacked("Sanctioned: ", sanctionList))); 
326:         } 
327:          
328:         _logAudit(user, "SANCTION_ADDED", abi.encode(sanctionList, details, evidence)); 
329:          
330:         emit SanctionChecked(user, sanctionList, true, block.timestamp); 
331:     } 
332:      
333:     // Révocation de KYC 
334:     function revokeKYC( 
335:         address user, 
336:         string memory reason 
337:     ) external onlyRole(KYC_VERIFIER) { 
338:         _revokeKYC(user, reason); 
339:     } 
340:      
341:     // Fonctions internes 
342:     function _validateSignature( 
343:         address user, 
344:         string memory userId, 
345:         string memory ipfsHash, 
346:         string memory countryCode, 
347:         bytes memory signature 
348:     ) private pure { 
349:         bytes32 messageHash = keccak256(abi.encodePacked( 
350:             user, 
351:             userId, 
352:             ipfsHash, 
353:             countryCode, 
354:             "KYC_VERIFICATION" 
355:         )); 
356:          
357:         bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash(); 
358:         address recovered = ethSignedMessageHash.recover(signature); 
359:          
360:         require(recovered == user, "Invalid signature"); 
361:     } 
362:      
363:     function _validateUpgradeSignature( 
364:         address user, 
365:         uint256 newLevel, 
366:         string memory ipfsHash, 
367:         bytes memory signature 
368:     ) private pure { 
369:         bytes32 messageHash = keccak256(abi.encodePacked( 
370:             user, 
371:             newLevel, 
372:             ipfsHash, 
373:             "KYC_UPGRADE" 
374:         )); 
375:          
376:         bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash(); 
377:         address recovered = ethSignedMessageHash.recover(signature); 
378:          
379:         require(recovered == user, "Invalid upgrade signature"); 
380:     } 
381:      
382:     function _initializeBlacklistedCountries() private { 
383:         // Liste des pays à haut risque (exemples) 
384:         blacklistedCountries["KP"] = true; // Corée du Nord 
385:         blacklistedCountries["IR"] = true; // Iran 
386:         blacklistedCountries["SY"] = true; // Syrie 
387:         blacklistedCountries["CU"] = true; // Cuba 
388:         // À compléter selon les régulations 
389:     } 
390:      
391:     function _isBlacklistedCountry(string memory countryCode) private view returns (bool) { 
392:         return blacklistedCountries[countryCode]; 
393:     } 
394:      
395:     function _checkPEPDatabase(address user, string memory countryCode) private returns (bool) { 
396:         // En production, intégrer avec une base de données PEP externe 
397:         // Pour l'instant, simulation basée sur des règles simples 
398:          
399:         // Règle: certains pays ont plus de risques PEP 
400:         bool highRiskCountry = keccak256(bytes(countryCode)) == keccak256(bytes("RU")) || 
401:                               keccak256(bytes(countryCode)) == keccak256(bytes("CN")) || 
402:                               keccak256(bytes(countryCode)) == keccak256(bytes("AE")); 
403:          
404:         // Simulation: 5% de chance d'être PEP dans les pays à risque 
405:         if (highRiskCountry) { 
406:             uint256 random = uint256(keccak256(abi.encodePacked( 
407:                 block.timestamp, 
408:                 user 
409:             ))) % 100; 
410:              
411:             if (random < 5) { // 5% 
412:                 pepDatabase[user] = true; 
413:                 return true; 
414:             } 
415:         } 
416:          
417:         return false; 
418:     } 
419:      
420:     function _updatePEPStatus(address user, string memory countryCode) private { 
421:         // Mise à jour périodique du statut PEP 
422:         // À intégrer avec un service externe en production 
423:     } 
424:      
425:     function _calculateRiskScore( 
426:         address user, 
427:         string memory countryCode, 
428:         bool isPEP 
429:     ) private pure returns (uint256) { 
430:         uint256 score = 0; 
431:          
432:         // Facteur pays 
433:         if (keccak256(bytes(countryCode)) == keccak256(bytes("US")) || 
434:             keccak256(bytes(countryCode)) == keccak256(bytes("UK")) || 
435:             keccak256(bytes(countryCode)) == keccak256(bytes("DE"))) { 
436:             score += 100; // Pays à faible risque 
437:         } else if (keccak256(bytes(countryCode)) == keccak256(bytes("RU")) || 
438:                   keccak256(bytes(countryCode)) == keccak256(bytes("CN"))) { 
439:             score += 400; // Pays à risque moyen 
440:         } else { 
441:             score += 200; // Autres pays 
442:         } 
443:          
444:         // Facteur PEP 
445:         if (isPEP) { 
446:             score += 300; 
447:         } 
448:          
449:         // Facteur adresse (nouveau vs ancien) 
450:         uint256 addressAge = (block.timestamp - 1609459200) / 1 days; // Depuis 2021 
451:         if (addressAge < 365) { 
452:             score += 100; // Adresse récente 
453:         } 
454:          
455:         return score > 1000 ? 1000 : score; 
456:     } 
457:      
458:     function _performSanctionCheck(address user, string memory countryCode) private { 
459:         // En production, intégrer avec des APIs de sanctions 
460:         // Pour l'instant, simulation 
461:          
462:         bool isSanctioned = false; 
463:         string memory sanctionList = "INTERNAL"; 
464:          
465:         // Simulation: vérification basée sur le pays 
466:         if (keccak256(bytes(countryCode)) == keccak256(bytes("KP")) || 
467:             keccak256(bytes(countryCode)) == keccak256(bytes("IR"))) { 
468:             isSanctioned = true; 
469:             sanctionList = "OFAC"; 
470:         } 
471:          
472:         sanctionChecks[user].push(SanctionCheck({ 
473:             user: user, 
474:             sanctionList: sanctionList, 
475:             isSanctioned: isSanctioned, 
476:             checkedAt: block.timestamp, 
477:             details: isSanctioned ? "Country-based sanction" : "Clear" 
478:         })); 
479:          
480:         emit SanctionChecked(user, sanctionList, isSanctioned, block.timestamp); 
481:          
482:         if (isSanctioned && kycData[user].isActive) { 
483:             _revokeKYC(user, "Sanctioned country"); 
484:         } 
485:     } 
486:      
487:     function _lastSanctionCheck(address user) private view returns (uint256) { 
488:         SanctionCheck[] storage checks = sanctionChecks[user]; 
489:         if (checks.length == 0) { 
490:             return 0; 
491:         } 
492:         return checks[checks.length - 1].checkedAt; 
493:     } 
494:      
495:     function _isCurrentlySanctioned(address user) private view returns (bool) { 
496:         SanctionCheck[] storage checks = sanctionChecks[user]; 
497:         if (checks.length == 0) { 
498:             return false; 
499:         } 
500:          
501:         // Vérifier la dernière entrée 
502:         SanctionCheck memory lastCheck = checks[checks.length - 1]; 
503:         return lastCheck.isSanctioned; 
504:     } 
505:      
506:     function _getRequiredKYCLevel( 
507:         uint256 amount, 
508:         string memory actionType 
509:     ) private pure returns (uint256) { 
510:         if (amount == 0) { 
511:             return uint256(VerificationLevel.BASIC); 
512:         } 
513:          
514:         if (amount <= 1000 * 1e18) { 
515:             return uint256(VerificationLevel.BASIC); 
516:         } else if (amount <= 10000 * 1e18) { 
517:             return uint256(VerificationLevel.ADVANCED); 
518:         } else if (amount <= 100000 * 1e18) { 
519:             return uint256(VerificationLevel.ENHANCED); 
520:         } else { 
521:             return uint256(VerificationLevel.INSTITUTIONAL); 
522:         } 
523:     } 
524:      
525:     function _revokeKYC(address user, string memory reason) private { 
526:         require(kycData[user].isActive, "KYC already inactive"); 
527:          
528:         kycData[user].isActive = false; 
529:         kycData[user].lastUpdate = block.timestamp; 
530:          
531:         _logAudit(user, "KYC_REVOKED", abi.encode(reason)); 
532:          
533:         emit KYCRevoked(user, msg.sender, reason, block.timestamp); 
534:     } 
535:      
536:     function _logAudit( 
537:         address user, 
538:         string memory action, 
539:         bytes memory data 
540:     ) private { 
541:         auditLogs[user].push(KYCAuditLog({ 
542:             user: user, 
543:             action: action, 
544:             performedBy: msg.sender, 
545:             timestamp: block.timestamp, 
546:             data: data 
547:         })); 
548:     } 
549:      
550:     // Getters 
551:     function isVerified(address user) external view returns (bool) { 
552:         return kycData[user].isActive && block.timestamp <= kycData[user].expiresAt; 
553:     } 
554:      
555:     function getVerificationLevel(address user) external view returns (uint256) { 
556:         if (kycData[user].isActive || block.timestamp > kycData[user].expiresAt) { 
557:             return uint256(VerificationLevel.UNVERIFIED); 
558:         } 
559:         return kycData[user].level; 
560:     } 
561:      
562:     function getKYCData(address user) external view returns (KYCData memory) { 
563:         return kycData[user]; 
564:     } 
565:      
566:     function getAuditLogs( 
567:         address user, 
568:         uint256 limit 
569:     ) external view onlyRole(KYC_AUDITOR) returns (KYCAuditLog[] memory) { 
570:         KYCAuditLog[] storage logs = auditLogs[user]; 
571:          
572:         if (limit == 0 || limit > logs.length) { 
573:             limit = logs.length; 
574:         } 
575:          
576:         KYCAuditLog[] memory result = new KYCAuditLog[](limit); 
577:          
578:         for (uint256 i = 0; i < limit; i++) { 
579:             result[i] = logs[logs.length - 1 - i]; 
580:         } 
581:          
582:         return result; 
583:     } 
584:      
585:     function getSanctionHistory( 
586:         address user 
587:     ) external view onlyRole(SANCTION_MANAGER) returns (SanctionCheck[] memory) { 
588:         return sanctionChecks[user]; 
589:     } 
590:      
591:     function calculateComplianceScore(address user) external view returns (uint256 score) { 
592:         if (kycData[user].isActive) { 
593:             return 0; 
594:         } 
595:          
596:         // Score basé sur le niveau KYC, l'âge, et les vérifications 
597:         score = kycData[user].level * 250; // 250 points par niveau 
598:          
599:         // Bonus pour ancienneté 
600:         uint256 ageDays = (block.timestamp - kycData[user].verifiedAt) / 1 days; 
601:         if (ageDays > 180) { 
602:             score += 100; 
603:         } 
604:          
605:         // Malus pour risque 
606:         score = score > kycData[user].riskScore ? score - kycData[user].riskScore : 0; 
607:          
608:         return score > 1000 ? 1000 : score; 
609:     } 
610:      
611:     // Configuration 
612:     function setKYCExpiryPeriod(uint256 newPeriod) external onlyRole(DEFAULT_ADMIN_ROLE) { 
613:         require(newPeriod >= 90 days && newPeriod <= 730 days, "Invalid expiry period"); 
614:         kycExpiryPeriod = newPeriod; 
615:     } 
616:      
617:     function setPEPCheckThreshold(uint256 newThreshold) external onlyRole(DEFAULT_ADMIN_ROLE) { 
618:         pepCheckThreshold = newThreshold; 
619:     } 
620:      
621:     function addBlacklistedCountry(string memory countryCode) external onlyRole(SANCTION_MANAGER) { 
622:         blacklistedCountries[countryCode] = true; 
623:     } 
624:      
625:     function removeBlacklistedCountry(string memory countryCode) external onlyRole(SANCTION_MANAGER) { 
626:         blacklistedCountries[countryCode] = false; 
627:     } 
628: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // RegulatoryReporting.sol 
2: // SPDX-License-Identifier: MIT 
3: pragma solidity 0.8.24; 
4: import "@openzeppelin/contracts/access/AccessControl.sol"; 
5: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 
6: contract RegulatoryReporting is AccessControl { 
7:     using ECDSA for bytes32; 
8:      
9:     // Standards réglementaires 
10:     enum ReportType { 
11:         TRANSACTION_REPORT,    // Rapport de transaction 
12:         SUSPICIOUS_ACTIVITY,   // Activité suspecte 
13:         TAX_REPORT,           // Rapport fiscal 
14:         SANCTIONS_SCREENING,  // Vérification des sanctions 
15:         PEP_SCREENING,        // Vérification des PEP 
16:         RISK_ASSESSMENT,      // Évaluation des risques 
17:         ANNUAL_COMPLIANCE,    // Conformité annuelle 
18:         AUDIT_TRAIL          // Piste d'audit 
19:     } 
20:      
21:     enum Jurisdiction { 
22:         EU_MICA,              // UE - MiCA 
23:         US_SEC,               // USA - SEC 
24:         US_CFTC,              // USA - CFTC 
25:         UK_FCA,               // UK - FCA 
26:         SG_MAS,               // Singapore - MAS 
27:         CH_HKMA,              // Hong Kong - HKMA 
28:         JP_FSA,               // Japan - FSA 
29:         AU_ASIC,              // Australia - ASIC 
30:         CH_FINMA              // Switzerland - FINMA 
31:     } 
32:      
33:     // Structure de rapport 
34:     struct RegulatoryReport { 
35:         uint256 reportId; 
36:         ReportType reportType; 
37:         Jurisdiction jurisdiction; 
38:         string referenceNumber; 
39:         uint256 periodStart; 
40:         uint256 periodEnd; 
41:         bytes32 dataHash;     // Hash des données sur IPFS/Arweave 
42:         address generatedBy; 
43:         uint256 generatedAt; 
44:         address submittedBy; 
45:         uint256 submittedAt; 
46:         string submissionId;  // ID de soumission externe 
47:         bool isVerified; 
48:         bytes auditorSignature; 
49:         ReportStatus status; 
50:     } 
51:      
52:     // Structure de donnée réglementaire 
53:     struct RegulatoryData { 
54:         address entity; 
55:         string entityType;    // "BORROWER", "LENDER", "INSURER", etc. 
56:         string countryCode; 
57:         uint256 riskScore; 
58:         uint256 totalVolume; 
59:         uint256 transactionCount; 
60:         uint256 suspiciousCount; 
61:         uint256 lastUpdated; 
62:     } 
63:      
64:     // Variables 
65:     mapping(uint256 => RegulatoryReport) public reports; 
66:     mapping(address => RegulatoryData) public entityData; 
67:     mapping(Jurisdiction => uint256) public jurisdictionRequirements; 
68:     mapping(string => bool) public submittedReports; // referenceNumber => submitted 
69:      
70:     uint256 public reportCounter; 
71:     uint256 public reportingInterval = 90 days; 
72:     uint256 public thresholdAmount = 10000 * 1e18; // Seuil de reporting 
73:      
74:     // Adresses autorisées 
75:     address public auditorAddress; 
76:     address public regulatorAddress; 
77:      
78:     // Rôles 
79:     bytes32 public constant COMPLIANCE_OFFICER = keccak256("COMPLIANCE_OFFICER"); 
80:     bytes32 public constant AUDITOR = keccak256("AUDITOR"); 
81:     bytes32 public constant REGULATOR = keccak256("REGULATOR"); 
82:      
83:     // Événements 
84:     event ReportGenerated( 
85:         uint256 indexed reportId, 
86:         ReportType reportType, 
87:         Jurisdiction jurisdiction, 
88:         address indexed generatedBy, 
89:         uint256 timestamp 
90:     ); 
91:      
92:     event ReportSubmitted( 
93:         uint256 indexed reportId, 
94:         string referenceNumber, 
95:         address indexed submittedBy, 
96:         uint256 timestamp 
97:     ); 
98:      
99:     event ReportVerified( 
100:         uint256 indexed reportId, 
101:         address indexed auditor, 
102:         uint256 timestamp 
103:     ); 
104:      
105:     event SuspiciousActivityReported( 
106:         address indexed entity, 
107:         string activityType, 
108:         uint256 amount, 
109:         address indexed reporter, 
110:         uint256 timestamp 
111:     ); 
112:      
113:     event RegulatoryDataUpdated( 
114:         address indexed entity, 
115:         string entityType, 
116:         uint256 riskScore, 
117:         uint256 timestamp 
118:     ); 
119:      
120:     constructor(address _auditor, address _regulator) { 
121:         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); 
122:         _grantRole(COMPLIANCE_OFFICER, msg.sender); 
123:          
124:         auditorAddress = _auditor; 
125:         regulatorAddress = _regulator; 
126:          
127:         _grantRole(AUDITOR, _auditor); 
128:         _grantRole(REGULATOR, _regulator); 
129:          
130:         // Initialiser les exigences par juridiction 
131:         _initializeJurisdictionRequirements(); 
132:     } 
133:      
134:     // Générer un rapport réglementaire 
135:     function generateReport( 
136:         ReportType reportType, 
137:         Jurisdiction jurisdiction, 
138:         uint256 periodStart, 
139:         uint256 periodEnd, 
140:         bytes32 dataHash, 
141:         string memory referenceNumber 
142:     ) public onlyRole(COMPLIANCE_OFFICER) returns (uint256) { 
143:         require(periodStart < periodEnd, "Invalid period"); 
144:         require(submittedReports[referenceNumber], "Reference number already used"); 
145:          
146:         uint256 reportId = ++reportCounter; 
147:          
148:         reports[reportId] = RegulatoryReport({ 
149:             reportId: reportId, 
150:             reportType: reportType, 
151:             jurisdiction: jurisdiction, 
152:             referenceNumber: referenceNumber, 
153:             periodStart: periodStart, 
154:             periodEnd: periodEnd, 
155:             dataHash: dataHash, 
156:             generatedBy: msg.sender, 
157:             generatedAt: block.timestamp, 
158:             submittedBy: address(0), 
159:             submittedAt: 0, 
160:             submissionId: "", 
161:             isVerified: false, 
162:             auditorSignature: "", 
163:             status: ReportStatus.GENERATED 
164:         }); 
165:          
166:         submittedReports[referenceNumber] = true; 
167:          
168:         emit ReportGenerated(reportId, reportType, jurisdiction, msg.sender, block.timestamp); 
169:          
170:         return reportId; 
171:     } 
172:      
173:     // Soumettre un rapport à un régulateur 
174:     function submitReport( 
175:         uint256 reportId, 
176:         string memory submissionId, 
177:         bytes memory regulatorSignature 
178:     ) external onlyRole(COMPLIANCE_OFFICER) { 
179:         RegulatoryReport storage report = reports[reportId]; 
180:         require(report.status == ReportStatus.GENERATED, "Report not in generated state"); 
181:          
182:         // Vérifier la signature du régulateur 
183:         _validateRegulatorSignature(reportId, submissionId, regulatorSignature); 
184:          
185:         report.submittedBy = msg.sender; 
186:         report.submittedAt = block.timestamp; 
187:         report.submissionId = submissionId; 
188:         report.status = ReportStatus.SUBMITTED; 
189:          
190:         emit ReportSubmitted(reportId, submissionId, msg.sender, block.timestamp); 
191:     } 
192:      
193:     // Rapporter une activité suspecte 
194:     function reportSuspiciousActivity( 
195:         address entity, 
196:         string memory activityType, 
197:         uint256 amount, 
198:         string memory description, 
199:         bytes memory evidenceHash 
200:     ) external onlyRole(COMPLIANCE_OFFICER) { 
201:         // Mettre à jour les données de l'entité 
202:         RegulatoryData storage data = entityData[entity]; 
203:         data.suspiciousCount++; 
204:         data.riskScore = _calculateRiskScore(data); 
205:         data.lastUpdated = block.timestamp; 
206:          
207:         // Générer un rapport automatique 
208:         bytes32 dataHash = keccak256(abi.encodePacked( 
209:             entity, 
210:             activityType, 
211:             amount, 
212:             description, 
213:             evidenceHash 
214:         )); 
215:          
216:         generateReport( 
217:             ReportType.SUSPICIOUS_ACTIVITY, 
218:             _getEntityJurisdiction(entity), 
219:             block.timestamp - 1 days, 
220:             block.timestamp, 
221:             dataHash, 
222:             string(abi.encodePacked("SAR-", _toString(block.timestamp))) 
223:         ); 
224:          
225:         emit SuspiciousActivityReported( 
226:             entity, 
227:             activityType, 
228:             amount, 
229:             msg.sender, 
230:             block.timestamp 
231:         ); 
232:     } 
233:      
234:     // Mettre à jour les données réglementaires d'une entité 
235:     function updateEntityData( 
236:         address entity, 
237:         string memory entityType, 
238:         string memory countryCode, 
239:         uint256 totalVolume, 
240:         uint256 transactionCount 
241:     ) external onlyRole(COMPLIANCE_OFFICER) { 
242:         RegulatoryData storage data = entityData[entity]; 
243:          
244:         data.entity = entity; 
245:         data.entityType = entityType; 
246:         data.countryCode = countryCode; 
247:         data.totalVolume = totalVolume; 
248:         data.transactionCount = transactionCount; 
249:         data.riskScore = _calculateRiskScore(data); 
250:         data.lastUpdated = block.timestamp; 
251:          
252:         // Vérifier si un rapport est nécessaire 
253:         _checkReportingRequirements(entity, totalVolume); 
254:          
255:         emit RegulatoryDataUpdated(entity, entityType, data.riskScore, block.timestamp); 
256:     } 
257:      
258:     // Vérifier et générer des rapports automatiques 
259:     function checkAndGenerateReports() external onlyRole(COMPLIANCE_OFFICER) { 
260:         uint256 currentPeriod = block.timestamp / reportingInterval; 
261:         uint256 lastReportedPeriod = _getLastReportedPeriod(); 
262:          
263:         if (currentPeriod > lastReportedPeriod) { 
264:             // Générer les rapports périodiques 
265:             _generatePeriodicReports(currentPeriod); 
266:         } 
267:     } 
268:      
269:     // Fonctions internes 
270:     function _initializeJurisdictionRequirements() private { 
271:         jurisdictionRequirements[Jurisdiction.EU_MICA] = 30 days; 
272:         jurisdictionRequirements[Jurisdiction.US_SEC] = 90 days; 
273:         jurisdictionRequirements[Jurisdiction.UK_FCA] = 30 days; 
274:         jurisdictionRequirements[Jurisdiction.SG_MAS] = 90 days; 
275:         // ... autres juridictions 
276:     } 
277:      
278:     function _validateRegulatorSignature( 
279:         uint256 reportId, 
280:         string memory submissionId, 
281:         bytes memory signature 
282:     ) private view { 
283:         bytes32 messageHash = keccak256(abi.encodePacked( 
284:             reportId, 
285:             submissionId, 
286:             block.chainid, 
287:             address(this), 
288:             "REGULATOR_SUBMISSION" 
289:         )); 
290:          
291:         bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash(); 
292:         address recovered = ethSignedMessageHash.recover(signature); 
293:          
294:         require(recovered == regulatorAddress, "Invalid regulator signature"); 
295:     } 
296:      
297:     function _calculateRiskScore(RegulatoryData memory data) private pure returns (uint256) { 
298:         uint256 score = 0; 
299:          
300:         // Facteur volume 
301:         if (data.totalVolume > 1000000 * 1e18) score += 300; 
302:         else if (data.totalVolume > 100000 * 1e18) score += 200; 
303:         else if (data.totalVolume > 10000 * 1e18) score += 100; 
304:          
305:         // Facteur transactions suspectes 
306:         score += data.suspiciousCount * 100; 
307:          
308:         // Facteur pays (simplifié) 
309:         if (keccak256(bytes(data.countryCode)) == keccak256(bytes("US"))) score += 50; 
310:         else if (keccak256(bytes(data.countryCode)) == keccak256(bytes("UK"))) score += 50; 
311:         else score += 100; 
312:          
313:         return score > 1000 ? 1000 : score; 
314:     } 
315:      
316:     function _getEntityJurisdiction(address entity) private view returns (Jurisdiction) { 
317:         RegulatoryData memory data = entityData[entity]; 
318:          
319:         // Logique simplifiée pour déterminer la juridiction 
320:         if (keccak256(bytes(data.countryCode)) == keccak256(bytes("US"))) { 
321:             return Jurisdiction.US_SEC; 
322:         } else if (keccak256(bytes(data.countryCode)) == keccak256(bytes("UK"))) { 
323:             return Jurisdiction.UK_FCA; 
324:         } else if (keccak256(bytes(data.countryCode)) == keccak256(bytes("SG"))) { 
325:             return Jurisdiction.SG_MAS; 
326:         } else { 
327:             return Jurisdiction.EU_MICA; // Par défaut 
328:         } 
329:     } 
330:      
331:     function _checkReportingRequirements(address entity, uint256 volume) private { 
332:         if (volume >= thresholdAmount) { 
333:             // Générer un rapport de transaction important 
334:             generateReport( 
335:                 ReportType.TRANSACTION_REPORT, 
336:                 _getEntityJurisdiction(entity), 
337:                 block.timestamp - 1 days, 
338:                 block.timestamp, 
339:                 keccak256(abi.encodePacked(entity, volume)), 
340:                 string(abi.encodePacked("LTR-", _toString(block.timestamp))) 
341:             ); 
342:         } 
343:     } 
344:      
345:     function _generatePeriodicReports(uint256 period) private { 
346:         // Générer les rapports pour toutes les juridictions 
347:         for (uint8 i = 0; i <= uint8(type(Jurisdiction).max); i++) { 
348:             Jurisdiction jurisdiction = Jurisdiction(i); 
349:              
350:             generateReport( 
351:                 ReportType.ANNUAL_COMPLIANCE, 
352:                 jurisdiction, 
353:                 period * reportingInterval, 
354:                 (period + 1) * reportingInterval, 
355:                 keccak256(abi.encodePacked(period, jurisdiction)), 
356:                 string(abi.encodePacked("PERIODIC-", _toString(period), "-", _toString(i))) 
357:             ); 
358:         } 
359:     } 
360:      
361:     function _getLastReportedPeriod() private view returns (uint256) { 
362:         // À implémenter: récupérer la dernière période reportée 
363:         return 0; 
364:     } 
365:      
366:     function _toString(uint256 value) private pure returns (string memory) { 
367:         if (value == 0) return "0"; 
368:          
369:         uint256 temp = value; 
370:         uint256 digits; 
371:         while (temp = 0) { 
372:             digits++; 
373:             temp /= 10; 
374:         } 
375:          
376:         bytes memory buffer = new bytes(digits); 
377:         while (value = 0) { 
378:             digits -= 1; 
379:             buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); 
380:             value /= 10; 
381:         } 
382:          
383:         return string(buffer); 
384:     } 
385:      
386:     // Getters 
387:     function getEntityRiskScore(address entity) external view returns (uint256) { 
388:         return entityData[entity].riskScore; 
389:     } 
390:      
391:     function getPendingReports() external view returns (uint256[] memory) { 
392:         uint256 count = 0; 
393:          
394:         // Compter les rapports en attente 
395:         for (uint256 i = 1; i <= reportCounter; i++) { 
396:             if (reports[i].status == ReportStatus.GENERATED) { 
397:                 count++; 
398:             } 
399:         } 
400:          
401:         // Collecter les IDs 
402:         uint256[] memory pending = new uint256[](count); 
403:         uint256 index = 0; 
404:          
405:         for (uint256 i = 1; i <= reportCounter; i++) { 
406:             if (reports[i].status == ReportStatus.GENERATED) { 
407:                 pending[index] = i; 
408:                 index++; 
409:             } 
410:         } 
411:          
412:         return pending; 
413:     } 
414:      
415:     function getJurisdictionReportCount(Jurisdiction jurisdiction)  
416:         external  
417:         view  
418:         returns (uint256)  
419:     { 
420:         uint256 count = 0; 
421:          
422:         for (uint256 i = 1; i <= reportCounter; i++) { 
423:             if (reports[i].jurisdiction == jurisdiction) { 
424:                 count++; 
425:             } 
426:         } 
427:          
428:         return count; 
429:     } 
430:      
431:     // Enums et statuts 
432:     enum ReportStatus { 
433:         GENERATED, 
434:         SUBMITTED, 
435:         VERIFIED, 
436:         REJECTED, 
437:         ARCHIVED 
438:     } 
439: } 
------------------------------------------------------------------------------ 
 
FILE 0 | !filepath! 
Size: !filesize! bytes | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // SPDX-License-Identifier: MIT 
2: pragma solidity 0.8.24; 
3: import "@openzeppelin/contracts/access/Ownable.sol"; 
4: import "../interfaces/ILoanPool.sol"; 
5: /** 
6:  * @title CriteriaFilter - Filtre dynamique pour les pools de prêt 
7:  * @notice Permet aux prêteurs de filtrer les pools selon leurs préférences 
8:  */ 
9: contract CriteriaFilter is Ownable { 
10:      
11:     struct LenderPreferences { 
12:         string[] preferredRegions; 
13:         bool ecologicalOnly; 
14:         string[] activityDomains; 
15:         uint256 minInterestRate;     // en points de base 
16:         uint256 maxRiskScore;        // 1-10 
17:         uint256 minInvestmentAmount; 
18:         uint256 maxInvestmentAmount; 
19:         uint256 preferredDurationMin; 
20:         uint256 preferredDurationMax; 
21:         uint256 createdAt; 
22:         uint256 lastUpdated; 
23:     } 
24:      
25:     // Référence au contrat principal 
26:     ILoanPool public loanPool; 
27:      
28:     // Stockage des préférences 
29:     mapping(address => LenderPreferences) public preferences; 
30:      
31:     // Mappings pour l'indexation 
32:     mapping(string => bool) public validRegions; 
33:     mapping(string => bool) public validDomains; 
34:      
35:     // Événements 
36:     event PreferencesUpdated(address indexed lender); 
37:     event PoolsFiltered(address indexed lender, uint256[] poolIds); 
38:      
39:     constructor(address _loanPool) Ownable(msg.sender) { 
40:         loanPool = ILoanPool(_loanPool); 
41:          
42:         // Initialisation des régions valides 
43:         validRegions["Europe"] = true; 
44:         validRegions["North America"] = true; 
45:         validRegions["Asia"] = true; 
46:         validRegions["Africa"] = true; 
47:         validRegions["South America"] = true; 
48:          
49:         // Initialisation des domaines valides 
50:         validDomains["Renewable Energy"] = true; 
51:         validDomains["Technology"] = true; 
52:         validDomains["Agriculture"] = true; 
53:         validDomains["Real Estate"] = true; 
54:         validDomains["Manufacturing"] = true; 
55:         validDomains["Education"] = true; 
56:         validDomains["Healthcare"] = true; 
57:     } 
58:      
59:     /** 
60:      * @notice Met à jour les préférences d'un prêteur 
61:      */ 
62:     function updatePreferences( 
63:         string[] memory regions, 
64:         bool ecologicalOnly, 
65:         string[] memory domains, 
66:         uint256 minRate, 
67:         uint256 maxRisk, 
68:         uint256 minInvestment, 
69:         uint256 maxInvestment, 
70:         uint256 durationMin, 
71:         uint256 durationMax 
72:     ) external { 
73:         // Validation des régions 
74:         for (uint256 i = 0; i < regions.length; i++) { 
75:             require(validRegions[regions[i]], "Invalid region"); 
76:         } 
77:          
78:         // Validation des domaines 
79:         for (uint256 i = 0; i < domains.length; i++) { 
80:             require(validDomains[domains[i]], "Invalid domain"); 
81:         } 
82:          
83:         // Validation des paramètres 
84:         require(minRate <= 5000, "Min rate too high"); // Max 50% 
85:         require(maxRisk <= 10, "Max risk invalid"); 
86:         require(minInvestment <= maxInvestment, "Invalid investment range"); 
87:         require(durationMin <= durationMax, "Invalid duration range"); 
88:          
89:         // Mise à jour des préférences 
90:         preferences[msg.sender] = LenderPreferences({ 
91:             preferredRegions: regions, 
92:             ecologicalOnly: ecologicalOnly, 
93:             activityDomains: domains, 
94:             minInterestRate: minRate, 
95:             maxRiskScore: maxRisk, 
96:             minInvestmentAmount: minInvestment, 
97:             maxInvestmentAmount: maxInvestment, 
98:             preferredDurationMin: durationMin, 
99:             preferredDurationMax: durationMax, 
100:             createdAt: block.timestamp, 
101:             lastUpdated: block.timestamp 
102:         }); 
103:          
104:         emit PreferencesUpdated(msg.sender); 
105:     } 
106:      
107:     /** 
108:      * @notice Filtre les pools selon les préférences 
109:      */ 
110:     function filterPools( 
111:         string[] memory regions, 
112:         bool ecologicalOnly, 
113:         string[] memory domains, 
114:         uint256 minRate, 
115:         uint256 maxRisk 
116:     ) external view returns (uint256[] memory) { 
117:         // Cette fonction est appelée par LoanPool 
118:         // Dans une implémentation réelle, on parcourrait tous les pools 
119:          
120:         // Pour l'instant, retourne un tableau vide 
121:         // L'implémentation complète nécessite l'accès à tous les pools 
122:         uint256[] memory filtered = new uint256[](0); 
123:         return filtered; 
124:     } 
125:      
126:     /** 
127:      * @notice Filtre les pools pour un prêteur spécifique 
128:      */ 
129:     function filterPoolsForLender(address lender) external view returns (uint256[] memory) { 
130:         LenderPreferences memory prefs = preferences[lender]; 
131:          
132:         // Logique de filtrage simplifiée 
133:         // Dans la vraie implémentation, il faudrait: 
134:         // 1. Récupérer tous les pools actifs 
135:         // 2. Appliquer chaque critère 
136:         // 3. Trier par score de pertinence 
137:          
138:         uint256[] memory result = new uint256[](0); 
139:         emit PoolsFiltered(lender, result); 
140:          
141:         return result; 
142:     } 
143:      
144:     /** 
145:      * @notice Calcule un score de pertinence pour un pool 
146:      */ 
147:     function calculateMatchScore( 
148:         uint256 poolId, 
149:         LenderPreferences memory prefs 
150:     ) public view returns (uint256 score) { 
151:         score = 0; 
152:          
153:         // Récupération des données du pool 
154:         ILoanPool.PoolData memory pool = loanPool.getPoolDetails(poolId); 
155:          
156:         // 1. Critère Région (30 points max) 
157:         for (uint256 i = 0; i < prefs.preferredRegions.length; i++) { 
158:             if (keccak256(bytes(pool.region)) == keccak256(bytes(prefs.preferredRegions[i]))) { 
159:                 score += 30; 
160:                 break; 
161:             } 
162:         } 
163:          
164:         // 2. Critère Écologique (20 points) 
165:         if (prefs.ecologicalOnly || pool.isEcological) { 
166:             score += 20; 
167:         } 
168:          
169:         // 3. Critère Domaine (25 points max) 
170:         for (uint256 i = 0; i < prefs.activityDomains.length; i++) { 
171:             if (keccak256(bytes(pool.activityDomain)) == keccak256(bytes(prefs.activityDomains[i]))) { 
172:                 score += 25; 
173:                 break; 
174:             } 
175:         } 
176:          
177:         // 4. Critère Taux d'intérêt (15 points) 
178:         if (pool.dynamicInterestRate >= prefs.minInterestRate) { 
179:             score += 15; 
180:         } 
181:          
182:         // 5. Critère Risque (10 points) 
183:         if (pool.riskScore <= prefs.maxRiskScore) { 
184:             score += 10; 
185:         } 
186:          
187:         return score; 
188:     } 
189:      
190:     // ============ FONCTIONS ADMIN ============ 
191:      
192:     function addValidRegion(string memory region) external onlyOwner { 
193:         validRegions[region] = true; 
194:     } 
195:      
196:     function removeValidRegion(string memory region) external onlyOwner { 
197:         validRegions[region] = false; 
198:     } 
199:      
200:     function addValidDomain(string memory domain) external onlyOwner { 
201:         validDomains[domain] = true; 
202:     } 
203:      
204:     function removeValidDomain(string memory domain) external onlyOwner { 
205:         validDomains[domain] = false; 
206:     } 
207:      
208:     function setLoanPool(address _loanPool) external onlyOwner { 
209:         loanPool = ILoanPool(_loanPool); 
210:     } 
211: } 
------------------------------------------------------------------------------ 
 
[SCRIPTS DIRECTORY - *.js, *.bat, *.sh, *.txt files] 
============================================================================== 
 
SCRIPT !script_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // scripts/seed-testnet.js 
2: const hre = require("hardhat"); 
3: const { ethers } = hre; 
4: async function main() { 
5:   console.log("🌱 Peuplement du protocole avec des données de test...\n"); 
6:    
7:   const [deployer] = await ethers.getSigners(); 
8:   console.log(`Utilisateur: ${deployer.address}`); 
9:    
10:   // Adresses des contrats (à remplacer après déploiement) 
11:   const LOAN_POOL_ADDRESS = "0x..."; 
12:   const STABLECOIN_ADDRESS = "0x..."; 
13:    
14:   const LoanPool = await ethers.getContractFactory("LoanPool"); 
15:   const loanPool = LoanPool.attach(LOAN_POOL_ADDRESS); 
16:    
17:   const Stablecoin = await ethers.getContractFactory("MockERC20"); 
18:   const stablecoin = Stablecoin.attach(STABLECOIN_ADDRESS); 
19:    
20:   // Données de test 
21:   const testPools = [ 
22:     { 
23:       name: "Ferme Solaire Normandie", 
24:       description: "Installation de panneaux solaires sur 5 hectares", 
25:       amount: ethers.parseEther("50000"), 
26:       duration: 180 * 24 * 60 * 60, // 180 jours 
27:       region: "Europe", 
28:       ecological: true, 
29:       domain: "Renewable Energy", 
30:       ipfs: "QmVFqK123..." 
31:     }, 
32:     { 
33:       name: "Startup AgriTech Bretagne", 
34:       description: "Développement de serres connectées", 
35:       amount: ethers.parseEther("25000"), 
36:       duration: 120 * 24 * 60 * 60, 
37:       region: "Europe", 
38:       ecological: true, 
39:       domain: "Agriculture", 
40:       ipfs: "QmVFqK456..." 
41:     }, 
42:     { 
43:       name: "Rénovation Immeuble Lyon", 
44:       description: "Rénovation énergétique d'un immeuble de 20 appartements", 
45:       amount: ethers.parseEther("150000"), 
46:       duration: 240 * 24 * 60 * 60, 
47:       region: "Europe", 
48:       ecological: true, 
49:       domain: "Real Estate", 
50:       ipfs: "QmVFqK789..." 
51:     }, 
52:     { 
53:       name: "Atelier Vélo Électrique Paris", 
54:       description: "Création d'un atelier de réparation et vente de vélos électriques", 
55:       amount: ethers.parseEther("15000"), 
56:       duration: 90 * 24 * 60 * 60, 
57:       region: "Europe", 
58:       ecological: true, 
59:       domain: "Manufacturing", 
60:       ipfs: "QmVFqK012..." 
61:     } 
62:   ]; 
63:    
64:   const testInvestments = [ 
65:     { poolIndex: 0, amount: ethers.parseEther("10000") }, 
66:     { poolIndex: 0, amount: ethers.parseEther("15000") }, 
67:     { poolIndex: 1, amount: ethers.parseEther("5000") }, 
68:     { poolIndex: 1, amount: ethers.parseEther("7000") }, 
69:     { poolIndex: 2, amount: ethers.parseEther("30000") }, 
70:     { poolIndex: 3, amount: ethers.parseEther("5000") } 
71:   ]; 
72:    
73:   // 1. Créer les pools 
74:   console.log("1. Création des pools de test..."); 
75:   for (let i = 0; i < testPools.length; i++) { 
76:     const pool = testPools[i]; 
77:      
78:     console.log(`   Pool ${i}: ${pool.name}`); 
79:     console.log(`   Montant: ${ethers.formatEther(pool.amount)} tokens`); 
80:      
81:     try { 
82:       const tx = await loanPool.createPool( 
83:         pool.name, 
84:         pool.description, 
85:         pool.amount, 
86:         pool.duration, 
87:         pool.region, 
88:         pool.ecological, 
89:         pool.domain, 
90:         pool.ipfs 
91:       ); 
92:       await tx.wait(); 
93:        
94:       // Activer le pool 
95:       await loanPool.activatePool(i); 
96:       console.log(`   ✅ Pool ${i} créé et activé\n`); 
97:     } catch (error) { 
98:       console.log(`   ❌ Erreur sur pool ${i}:`, error.message); 
99:     } 
100:      
101:     // Petite pause entre les transactions 
102:     await new Promise(resolve => setTimeout(resolve, 2000)); 
103:   } 
104:    
105:   // 2. Simuler des investissements 
106:   console.log("\n2. Simulation d'investissements..."); 
107:    
108:   // Créer des investisseurs test 
109:   const testInvestors = []; 
110:   for (let i = 0; i < 5; i++) { 
111:     const investor = ethers.Wallet.createRandom().connect(ethers.provider); 
112:     testInvestors.push(investor); 
113:      
114:     // Funding avec stablecoin test 
115:     await stablecoin.mint(investor.address, ethers.parseEther("50000")); 
116:     await stablecoin.connect(investor).approve(LOAN_POOL_ADDRESS, ethers.parseEther("50000")); 
117:      
118:     console.log(`   Investisseur ${i}: ${investor.address.slice(0, 10)}...`); 
119:   } 
120:    
121:   // Répartir les investissements 
122:   let investmentCount = 0; 
123:   for (const investment of testInvestments) { 
124:     const investor = testInvestors[investmentCount % testInvestors.length]; 
125:      
126:     console.log(`   Investissement ${investmentCount}: ${ethers.formatEther(investment.amount)} dans pool ${investment.poolIndex}`); 
127:      
128:     try { 
129:       const tx = await loanPool.connect(investor).invest( 
130:         investment.poolIndex, 
131:         investment.amount 
132:       ); 
133:       await tx.wait(); 
134:       console.log(`   ✅ Investissement ${investmentCount} réussi`); 
135:     } catch (error) { 
136:       console.log(`   ❌ Erreur:`, error.message); 
137:     } 
138:      
139:     investmentCount++; 
140:     await new Promise(resolve => setTimeout(resolve, 1000)); 
141:   } 
142:    
143:   // 3. Vérifier l'état final 
144:   console.log("\n3. État final des pools:"); 
145:    
146:   for (let i = 0; i < testPools.length; i++) { 
147:     const pool = await loanPool.getPoolDetails(i); 
148:     const percentage = (Number(pool.collectedAmount) / Number(pool.targetAmount) * 100).toFixed(1); 
149:      
150:     console.log(`   Pool ${i} - ${pool.projectName}:`); 
151:     console.log(`     Collecté: ${ethers.formatEther(pool.collectedAmount)} / ${ethers.formatEther(pool.targetAmount)} (${percentage}%)`); 
152:     console.log(`     Taux dynamique: ${pool.dynamicInterestRate / 100}%`); 
153:     console.log(`     Statut: ${getStatusName(pool.status)}\n`); 
154:   } 
155:    
156:   // 4. Créer une offre spéciale 
157:   console.log("\n4. Création d'une offre spéciale..."); 
158:    
159:   const SpecialOfferManager = await ethers.getContractFactory("SpecialOfferManager"); 
160:   const specialOfferManager = SpecialOfferManager.attach("0x..."); // Adresse du manager 
161:    
162:   try { 
163:     const tx = await specialOfferManager.createOffer( 
164:       1, // SEASONAL 
165:       "Offre Printemps Écologique", 
166:       "Bonus pour tous les projets écologiques ce printemps", 
167:       150, // 1.5% bonus 
168:       30 * 24 * 60 * 60, // 30 jours 
169:       ethers.parseEther("50000"), // 50,000 max bonus 
170:       [0, 1, 2, 3] // Tous les pools 
171:     ); 
172:     await tx.wait(); 
173:     console.log("   ✅ Offre spéciale créée"); 
174:   } catch (error) { 
175:     console.log("   ❌ Erreur création offre:", error.message); 
176:   } 
177:    
178:   console.log("\n" + "=".repeat(60)); 
179:   console.log("✅ PEUPLEMENT TERMINÉ "); 
180:   console.log("=".repeat(60)); 
181:   console.log("\n📊 Résumé:"); 
182:   console.log(`• ${testPools.length} pools créés`); 
183:   console.log(`• ${testInvestments.length} investissements simulés`); 
184:   console.log(`• ${testInvestors.length} investisseurs test`); 
185:   console.log("\n🌐 Pour tester:"); 
186:   console.log(`1. Accéder à LoanPool: ${LOAN_POOL_ADDRESS}`); 
187:   console.log(`2. Vérifier sur Etherscan`); 
188:   console.log(`3. Tester avec le frontend`); 
189: } 
190: function getStatusName(statusCode) { 
191:   const statuses = [ 
192:     "CREATION", "ACTIVE", "FUNDED", "ONGOING",  
193:     "COMPLETED", "DEFAULTED", "LIQUIDATED", "CANCELLED" 
194:   ]; 
195:   return statuses[statusCode] || "INCONNU"; 
196: } 
197: main().catch((error) => { 
198:   console.error(error); 
199:   process.exitCode = 1; 
200: }); 
------------------------------------------------------------------------------ 
 
SCRIPT !script_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: # 1. Configuration initiale 
2: npm init -y 
3: npm install --save-dev hardhat @nomiclabs/hardhat-ethers ethers 
4: npm install @openzeppelin/contracts @chainlink/contracts 
5: # 2. Structure de projet 
6: contracts/ 
7: ├── core/ 
8: │   ├── LoanPool.sol 
9: │   └── LoanNFT.sol 
10: ├── risk/ 
11: │   ├── RiskEngine.sol 
12: │   └── DynamicTranche.sol 
13: ├── insurance/ 
14: │   ├── InsuranceModule.sol 
15: │   └── DecentralizedGuaranteeFund.sol 
16: └── governance/ 
17:     ├── GovernanceDAO.sol 
18:     └── AccessController.sol 
19: # 3. Tests unitaires 
20: test/ 
21: ├── unit/ 
22: │   ├── LoanPool.test.js 
23: │   └── RiskEngine.test.js 
24: └── integration/ 
25:     └── FullWorkflow.test.js 
------------------------------------------------------------------------------ 
 
SCRIPT !script_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: # 1. Installation des dépendances 
2: npm install 
3: # 2. Compilation des contrats 
4: npx hardhat compile 
5: # 3. Tests 
6: npx hardhat test 
7: npx hardhat coverage 
8: # 4. Déploiement Testnet 
9: npx hardhat run scripts/deploy-testnet.js --network polygonMumbai 
10: # 5. Déploiement Phase 1 Mainnet 
11: npx hardhat run scripts/deploy-mainnet-phase1.js --network polygon 
12: # 6. Déploiement Complet Mainnet (après Phase 1) 
13: npx hardhat run scripts/deploy-mainnet-full.js --network polygon 
14: # 7. Vérification sur Polygonscan 
15: npx hardhat verify --network polygon 0xCONTRACT_ADDRESS "Constructor Arg 1" "Arg 2" 
------------------------------------------------------------------------------ 
 
SCRIPT !script_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: 🌱 Peuplement du protocole avec des données de test... 
2: 1. Création des pools de test... 
3:    Pool 0: Ferme Solaire Normandie 
4:    Montant: 50000.0 tokens 
5:    ✅ Pool 0 créé et activé 
6:    ... 
7: 2. Simulation d'investissements... 
8:    Investisseur 0: 0x7a3f8b... 
9:    ... 
10: 3. État final des pools: 
11:    Pool 0 - Ferme Solaire Normandie: 
12:      Collecté: 25000.0 / 50000.0 (50.0%) 
13:      Taux dynamique: 5.2% 
14:      Statut: ACTIVE 
15:    ... 
16: ✅ PEUPLEMENT TERMINÉ  
------------------------------------------------------------------------------ 
 
[TESTS DIRECTORY - *.js, *.txt files] 
============================================================================== 
 
TEST !test_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // test/LoanPool.test.js - Suite de tests principale 
2: const { expect } = require("chai"); 
3: const { ethers } = require("hardhat"); 
4: const { time } = require("@nomicfoundation/hardhat-network-helpers"); 
5: describe("PoolSync Protocol", function () { 
6:   let loanPool, riskEngine, criteriaFilter, specialOfferManager; 
7:   let owner, borrower, lender1, lender2, feeCollector; 
8:   let stablecoin; 
9:    
10:   // Montants en tokens (18 décimales) 
11:   const TOKEN_100 = ethers.parseEther("100"); 
12:   const TOKEN_1000 = ethers.parseEther("1000"); 
13:   const TOKEN_10000 = ethers.parseEther("10000"); 
14:    
15:   beforeEach(async function () { 
16:     // Récupérer les signers 
17:     [owner, borrower, lender1, lender2, feeCollector] = await ethers.getSigners(); 
18:      
19:     // Déployer un mock stablecoin 
20:     const MockStablecoin = await ethers.getContractFactory("MockERC20"); 
21:     stablecoin = await MockStablecoin.deploy("Test USDC", "USDC", 18); 
22:      
23:     // Déployer RiskEngine avec mocks 
24:     const RiskEngine = await ethers.getContractFactory("RiskEngine"); 
25:     riskEngine = await RiskEngine.deploy(ethers.ZeroAddress, ethers.ZeroAddress); 
26:      
27:     // Déployer LoanPool 
28:     const LoanPool = await ethers.getContractFactory("LoanPool"); 
29:     loanPool = await LoanPool.deploy( 
30:       await stablecoin.getAddress(), 
31:       await riskEngine.getAddress(), 
32:       feeCollector.address 
33:     ); 
34:      
35:     // Déployer CriteriaFilter 
36:     const CriteriaFilter = await ethers.getContractFactory("CriteriaFilter"); 
37:     criteriaFilter = await CriteriaFilter.deploy(await loanPool.getAddress()); 
38:      
39:     // Déployer SpecialOfferManager 
40:     const SpecialOfferManager = await ethers.getContractFactory("SpecialOfferManager"); 
41:     specialOfferManager = await SpecialOfferManager.deploy(); 
42:      
43:     // Configurer les modules 
44:     await loanPool.setExternalModules( 
45:       await riskEngine.getAddress(), 
46:       await criteriaFilter.getAddress(), 
47:       await specialOfferManager.getAddress() 
48:     ); 
49:      
50:     // Autoriser l'owner à créer des pools 
51:     await loanPool.authorizeCreator(owner.address, true); 
52:     await loanPool.authorizeCreator(borrower.address, true); 
53:      
54:     // Fund les comptes avec stablecoin 
55:     await stablecoin.mint(borrower.address, TOKEN_10000); 
56:     await stablecoin.mint(lender1.address, TOKEN_10000); 
57:     await stablecoin.mint(lender2.address, TOKEN_10000); 
58:      
59:     // Approve LoanPool pour dépenser 
60:     await stablecoin.connect(borrower).approve(await loanPool.getAddress(), TOKEN_10000); 
61:     await stablecoin.connect(lender1).approve(await loanPool.getAddress(), TOKEN_10000); 
62:     await stablecoin.connect(lender2).approve(await loanPool.getAddress(), TOKEN_10000); 
63:   }); 
64:    
65:   describe("Création et Cycle de Vie d'un Pool", function () { 
66:     it("Devrait créer un pool avec succès", async function () { 
67:       await expect( 
68:         loanPool.connect(borrower).createPool( 
69:           "Projet Écologique Test", 
70:           "Description du projet", 
71:           TOKEN_1000, 
72:           90 * 24 * 60 * 60, // 90 jours 
73:           "Europe", 
74:           true, 
75:           "Renewable Energy", 
76:           "QmTestHash" 
77:         ) 
78:       ).to.emit(loanPool, "PoolCreated"); 
79:        
80:       const pool = await loanPool.getPoolDetails(0); 
81:       expect(pool.projectName).to.equal("Projet Écologique Test"); 
82:       expect(pool.targetAmount).to.equal(TOKEN_1000); 
83:       expect(pool.borrower).to.equal(borrower.address); 
84:     }); 
85:      
86:     it("Devrait activer un pool créé", async function () { 
87:       await loanPool.connect(borrower).createPool( 
88:         "Projet Test", 
89:         "Description", 
90:         TOKEN_1000, 
91:         30 days, 
92:         "Europe", 
93:         false, 
94:         "Technology", 
95:         "QmTest" 
96:       ); 
97:        
98:       await loanPool.connect(borrower).activatePool(0); 
99:        
100:       const pool = await loanPool.getPoolDetails(0); 
101:       expect(pool.status).to.equal(1); // PoolStatus.ACTIVE 
102:     }); 
103:      
104:     it("Devrait permettre l'investissement dans un pool actif", async function () { 
105:       // Créer et activer un pool 
106:       await loanPool.connect(borrower).createPool( 
107:         "Projet Test", 
108:         "Description", 
109:         TOKEN_1000, 
110:         30 days, 
111:         "Europe", 
112:         false, 
113:         "Technology", 
114:         "QmTest" 
115:       ); 
116:       await loanPool.connect(borrower).activatePool(0); 
117:        
118:       // Investir 
119:       await expect( 
120:         loanPool.connect(lender1).invest(0, TOKEN_100) 
121:       ).to.emit(loanPool, "InvestmentMade"); 
122:        
123:       const pool = await loanPool.getPoolDetails(0); 
124:       expect(pool.collectedAmount).to.equal(TOKEN_100); 
125:     }); 
126:      
127:     it("Devrait finaliser le financement à 100%", async function () { 
128:       await loanPool.connect(borrower).createPool( 
129:         "Projet Test", 
130:         "Description", 
131:         TOKEN_1000, 
132:         30 days, 
133:         "Europe", 
134:         false, 
135:         "Technology", 
136:         "QmTest" 
137:       ); 
138:       await loanPool.connect(borrower).activatePool(0); 
139:        
140:       // Investir 100% 
141:       await loanPool.connect(lender1).invest(0, TOKEN_1000); 
142:        
143:       const pool = await loanPool.getPoolDetails(0); 
144:       expect(pool.status).to.equal(3); // PoolStatus.FUNDED -> ONGOING 
145:     }); 
146:      
147:     it("Devrait permettre le remboursement par l'emprunteur", async function () { 
148:       // Créer, financer à 100% 
149:       await loanPool.connect(borrower).createPool( 
150:         "Projet Test", 
151:         "Description", 
152:         TOKEN_100, 
153:         30 days, 
154:         "Europe", 
155:         false, 
156:         "Technology", 
157:         "QmTest" 
158:       ); 
159:       await loanPool.connect(borrower).activatePool(0); 
160:       await loanPool.connect(lender1).invest(0, TOKEN_100); 
161:        
162:       // Rembourser 
163:       const repaymentAmount = TOKEN_105; // 100 + 5% d'intérêt 
164:       await stablecoin.mint(borrower.address, TOKEN_105); 
165:       await stablecoin.connect(borrower).approve(await loanPool.getAddress(), TOKEN_105); 
166:        
167:       await expect( 
168:         loanPool.connect(borrower).repay(0, TOKEN_105) 
169:       ).to.emit(loanPool, "RepaymentMade"); 
170:     }); 
171:      
172:     it("Devrait déclencher un défaut après expiration", async function () { 
173:       await loanPool.connect(borrower).createPool( 
174:         "Projet Test", 
175:         "Description", 
176:         TOKEN_100, 
177:         7 days, // Court pour test 
178:         "Europe", 
179:         false, 
180:         "Technology", 
181:         "QmTest" 
182:       ); 
183:       await loanPool.connect(borrower).activatePool(0); 
184:       await loanPool.connect(lender1).invest(0, TOKEN_100); 
185:        
186:       // Avancer le temps (durée + période de grâce) 
187:       await time.increase(40 days); 
188:        
189:       await expect( 
190:         loanPool.connect(lender1).triggerDefault(0) 
191:       ).to.emit(loanPool, "DefaultTriggered"); 
192:     }); 
193:   }); 
194:    
195:   describe("Fonctionnalités Avancées", function () { 
196:     it("Devrait calculer un taux dynamique", async function () { 
197:       await loanPool.connect(borrower).createPool( 
198:         "Projet Test", 
199:         "Description", 
200:         TOKEN_1000, 
201:         30 days, 
202:         "Europe", 
203:         false, 
204:         "Technology", 
205:         "QmTest" 
206:       ); 
207:       await loanPool.connect(borrower).activatePool(0); 
208:        
209:       const rate = await loanPool.getDynamicRate(0); 
210:       expect(rate).to.be.gt(0); 
211:     }); 
212:      
213:     it("Devrait appliquer une offre spéciale", async function () { 
214:       // Créer une offre 
215:       await specialOfferManager.createOffer( 
216:         0, // FLASH 
217:         "Offre Test", 
218:         "Description", 
219:         200, // 2% bonus 
220:         7 days, 
221:         TOKEN_1000, 
222:         [0] // Pool 0 éligible 
223:       ); 
224:        
225:       // Créer et activer pool 
226:       await loanPool.connect(borrower).createPool( 
227:         "Projet Test", 
228:         "Description", 
229:         TOKEN_1000, 
230:         30 days, 
231:         "Europe", 
232:         false, 
233:         "Technology", 
234:         "QmTest" 
235:       ); 
236:       await loanPool.connect(borrower).activatePool(0); 
237:        
238:       // Appliquer offre 
239:       await loanPool.applySpecialOffer(0, 0); 
240:        
241:       const pool = await loanPool.getPoolDetails(0); 
242:       expect(pool.hasSpecialOffer).to.be.true; 
243:     }); 
244:   }); 
245:    
246:   describe("Sécurité et Contrôles d'Accès", function () { 
247:     it("Devrait rejeter les investissements non autorisés", async function () { 
248:       await loanPool.connect(borrower).createPool( 
249:         "Projet Test", 
250:         "Description", 
251:         TOKEN_1000, 
252:         30 days, 
253:         "Europe", 
254:         false, 
255:         "Technology", 
256:         "QmTest" 
257:       ); 
258:        
259:       // Pool pas encore activé 
260:       await expect( 
261:         loanPool.connect(lender1).invest(0, TOKEN_100) 
262:       ).to.be.revertedWith("Pool not active"); 
263:     }); 
264:      
265:     it("Devrait rejeter les créations non autorisées", async function () { 
266:       // lender1 n'est pas autorisé à créer 
267:       await expect( 
268:         loanPool.connect(lender1).createPool( 
269:           "Projet Test", 
270:           "Description", 
271:           TOKEN_1000, 
272:           30 days, 
273:           "Europe", 
274:           false, 
275:           "Technology", 
276:           "QmTest" 
277:         ) 
278:       ).to.be.revertedWith("Not authorized to create pools"); 
279:     }); 
280:      
281:     it("Devrait activer/désactiver le mode pause", async function () { 
282:       await loanPool.setEmergencyPause(true); 
283:        
284:       await loanPool.connect(borrower).createPool( 
285:         "Projet Test", 
286:         "Description", 
287:         TOKEN_1000, 
288:         30 days, 
289:         "Europe", 
290:         false, 
291:         "Technology", 
292:         "QmTest" 
293:       ); 
294:        
295:       await expect( 
296:         loanPool.connect(borrower).activatePool(0) 
297:       ).to.be.revertedWith("Protocol paused"); 
298:     }); 
299:   }); 
300: }); 
------------------------------------------------------------------------------ 
 
TEST !test_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // test-security-v2.js 
2: const { expect } = require("chai"); 
3: const { ethers } = require("hardhat"); 
4: describe("Contrats de Sécurité V2", function() { 
5:   let accessController, kycRegistry, emergencyExecutor; 
6:   let owner, admin, user, auditor; 
7:    
8:   before(async function() { 
9:     [owner, admin, user, auditor] = await ethers.getSigners(); 
10:      
11:     // Déploiement des contrats 
12:     const AccessControllerV2 = await ethers.getContractFactory("AccessControllerV2"); 
13:     accessController = await AccessControllerV2.deploy(); 
14:      
15:     const KYCRegistryV2 = await ethers.getContractFactory("KYCRegistryV2"); 
16:     kycRegistry = await KYCRegistryV2.deploy(accessController.address); 
17:      
18:     const EmergencyExecutorV2 = await ethers.getContractFactory("EmergencyExecutorV2"); 
19:     emergencyExecutor = await EmergencyExecutorV2.deploy(accessController.address); 
20:   }); 
21:    
22:   describe("1. AccessControllerV2", function() { 
23:     it("1.1 Devrait initialiser les rôles système", async function() { 
24:       await accessController.initializeRoles(); 
25:        
26:       // Vérifier que le SUPER_ADMIN existe 
27:       const superAdminRole = await accessController.SUPER_ADMIN(); 
28:       expect(await accessController.hasRole(superAdminRole, owner.address)).to.be.true; 
29:     }); 
30:      
31:     it("1.2 Devrait configurer un nouveau rôle", async function() { 
32:       const NEW_ROLE = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("NEW_ROLE")); 
33:        
34:       await accessController.connect(owner).configureRole( 
35:         NEW_ROLE, 
36:         "New Role", 
37:         "Test role description", 
38:         5, 
39:         1, 
40:         false, 
41:         5000 
42:       ); 
43:        
44:       const config = await accessController.roleConfigs(NEW_ROLE); 
45:       expect(config.name).to.equal("New Role"); 
46:     }); 
47:      
48:     it("1.3 Devrait enregistrer un contrat", async function() { 
49:       await accessController.connect(owner).registerContract( 
50:         kycRegistry.address, 
51:         "KYCRegistry", 
52:         "1.0.0", 
53:         "ipfs://config" 
54:       ); 
55:        
56:       const contractInfo = await accessController.getContractInfo(kycRegistry.address); 
57:       expect(contractInfo.name).to.equal("KYCRegistry"); 
58:     }); 
59:   }); 
60:    
61:   describe("2. KYCRegistryV2", function() { 
62:     it("2.1 Devrait vérifier un utilisateur KYC", async function() { 
63:       // Simuler une signature 
64:       const message = ethers.utils.solidityKeccak256( 
65:         ["address", "string", "string", "string", "string"], 
66:         [user.address, "USER123", "ipfs://hash", "FR", "KYC_VERIFICATION"] 
67:       ); 
68:        
69:       const signature = await user.signMessage(ethers.utils.arrayify(message)); 
70:        
71:       await kycRegistry.connect(admin).verifyBasicKYC( 
72:         user.address, 
73:         "USER123", 
74:         "ipfs://hash", 
75:         "FR", 
76:         signature 
77:       ); 
78:        
79:       const isVerified = await kycRegistry.isVerified(user.address); 
80:       expect(isVerified).to.be.true; 
81:     }); 
82:      
83:     it("2.2 Devrait vérifier l'éligibilité", async function() { 
84:       const [eligible, reason] = await kycRegistry.checkEligibility( 
85:         user.address, 
86:         ethers.utils.parseEther("1000"), 
87:         "LOAN_CREATION" 
88:       ); 
89:        
90:       expect(eligible).to.be.true; 
91:     }); 
92:      
93:     it("2.3 Devrait détecter un pays blacklisté", async function() { 
94:       const message = ethers.utils.solidityKeccak256( 
95:         ["address", "string", "string", "string", "string"], 
96:         [auditor.address, "USER124", "ipfs://hash", "KP", "KYC_VERIFICATION"] 
97:       ); 
98:        
99:       const signature = await auditor.signMessage(ethers.utils.arrayify(message)); 
100:        
101:       await expect( 
102:         kycRegistry.connect(admin).verifyBasicKYC( 
103:           auditor.address, 
104:           "USER124", 
105:           "ipfs://hash", 
106:           "KP", 
107:           signature 
108:         ) 
109:       ).to.be.revertedWith("Country blacklisted"); 
110:     }); 
111:   }); 
112:    
113:   describe("3. EmergencyExecutorV2", function() { 
114:     it("3.1 Devrait proposer une action d'urgence", async function() { 
115:       // Simuler une signature 
116:       const message = ethers.utils.solidityKeccak256( 
117:         ["string", "address", "bytes", "string", "uint256", "address", "string"], 
118:         [ 
119:           "FREEZE_USER", 
120:           user.address, 
121:           "0x", 
122:           "Test emergency", 
123:           await ethers.provider.getNetwork().then(n => n.chainId), 
124:           emergencyExecutor.address, 
125:           "EMERGENCY_PROPOSAL" 
126:         ] 
127:       ); 
128:        
129:       const signature = await admin.signMessage(ethers.utils.arrayify(message)); 
130:        
131:       const freezeCalldata = ethers.utils.defaultAbiCoder.encode( 
132:         ["address", "uint256", "string"], 
133:         [user.address, 3600, "Suspicious activity"] 
134:       ); 
135:        
136:       const actionId = await emergencyExecutor.connect(admin).proposeEmergencyAction( 
137:         "FREEZE_USER", 
138:         emergencyExecutor.address, 
139:         freezeCalldata, 
140:         "Freeze user account", 
141:         "Suspicious activity detected", 
142:         signature 
143:       ); 
144:        
145:       expect(actionId).to.equal(1); 
146:     }); 
147:      
148:     it("3.2 Devrait approuver une action d'urgence", async function() { 
149:       // Simuler une signature d'approbation 
150:       const message = ethers.utils.solidityKeccak256( 
151:         ["uint256", "uint256", "address", "string"], 
152:         [ 
153:           1, 
154:           await ethers.provider.getNetwork().then(n => n.chainId), 
155:           emergencyExecutor.address, 
156:           "EMERGENCY_APPROVAL" 
157:         ] 
158:       ); 
159:        
160:       const signature = await owner.signMessage(ethers.utils.arrayify(message)); 
161:        
162:       await emergencyExecutor.connect(owner).approveEmergencyAction(1, signature); 
163:        
164:       const action = await emergencyExecutor.getEmergencyAction(1); 
165:       expect(action.currentApprovals).to.equal(1); 
166:     }); 
167:      
168:     it("3.3 Devrait exécuter une action d'urgence après délai", async function() { 
169:       // Attendre le délai d'exécution (configuré à 10 minutes pour FREEZE_USER) 
170:       // Pour les tests, nous pourrions ajuster la configuration 
171:        
172:       // Note: Ce test nécessiterait d'ajuster la configuration ou d'attendre 
173:       // Pour cette démo, nous le marquons comme skip 
174:       this.skip(); 
175:     }); 
176:   }); 
177:    
178:   describe("4. Intégration des Contrats de Sécurité", function() { 
179:     it("4.1 Devrait gérer un scénario de sécurité complet", async function() { 
180:       // Scénario:  
181:       // 1. Utilisateur passe KYC 
182:       // 2. Action suspecte détectée 
183:       // 3. Proposition d'urgence pour geler le compte 
184:       // 4. Approbation et exécution 
185:       // 5. Vérification que le compte est gelé 
186:        
187:       // 1. KYC 
188:       const message = ethers.utils.solidityKeccak256( 
189:         ["address", "string", "string", "string", "string"], 
190:         [user.address, "USER125", "ipfs://hash", "US", "KYC_VERIFICATION"] 
191:       ); 
192:        
193:       const kycSignature = await user.signMessage(ethers.utils.arrayify(message)); 
194:        
195:       await kycRegistry.connect(admin).verifyBasicKYC( 
196:         user.address, 
197:         "USER125", 
198:         "ipfs://hash", 
199:         "US", 
200:         kycSignature 
201:       ); 
202:        
203:       // 2. Simulation d'action suspecte 
204:       // 3. Proposition d'urgence 
205:       const emergencyMessage = ethers.utils.solidityKeccak256( 
206:         ["string", "address", "bytes", "string", "uint256", "address", "string"], 
207:         [ 
208:           "FREEZE_USER", 
209:           user.address, 
210:           "0x", 
211:           "Suspicious transaction pattern", 
212:           await ethers.provider.getNetwork().then(n => n.chainId), 
213:           emergencyExecutor.address, 
214:           "EMERGENCY_PROPOSAL" 
215:         ] 
216:       ); 
217:        
218:       const emergencySignature = await admin.signMessage( 
219:         ethers.utils.arrayify(emergencyMessage) 
220:       ); 
221:        
222:       const freezeCalldata = ethers.utils.defaultAbiCoder.encode( 
223:         ["address", "uint256", "string"], 
224:         [user.address, 86400, "Suspicious transaction pattern"] 
225:       ); 
226:        
227:       const actionId = await emergencyExecutor.connect(admin).proposeEmergencyAction( 
228:         "FREEZE_USER", 
229:         emergencyExecutor.address, 
230:         freezeCalldata, 
231:         "Freeze suspicious account", 
232:         "Multiple failed transactions from new account", 
233:         emergencySignature 
234:       ); 
235:        
236:       // 4. Approbations (nécessiterait plusieurs approbateurs) 
237:       // 5. Exécution (nécessiterait l'attente du délai) 
238:        
239:       // Pour cette démo, nous vérifions seulement la proposition 
240:       expect(actionId).to.equal(2); 
241:     }); 
242:      
243:     it("4.2 Devrait respecter la chaîne d'autorisation", async function() { 
244:       // Vérifier qu'un utilisateur normal ne peut pas accéder aux fonctions admin 
245:       await expect( 
246:         accessController.connect(user).configureRole( 
247:           ethers.utils.keccak256(ethers.utils.toUtf8Bytes("TEST_ROLE")), 
248:           "Test", 
249:           "Test", 
250:           1, 
251:           1, 
252:           false, 
253:           5000 
254:         ) 
255:       ).to.be.reverted; // Doit être revert avec un message d'accès refusé 
256:     }); 
257:   }); 
258: }); 
------------------------------------------------------------------------------ 
 
TEST !test_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // test-v2-complete.js 
2: const { expect } = require("chai"); 
3: const { ethers } = require("hardhat"); 
4: describe("Système DeFi de Prêt Structuré V2", function() { 
5:   let loanPool, riskEngine, loanNFT, insuranceModule; 
6:   let bondingCurve, dynamicTranche, secondaryMarket; 
7:   let governanceDAO, guaranteeFund, notificationManager; 
8:   let reputationToken, feeDistributor; 
9:    
10:   let owner, borrower, lender, investor, insurer; 
11:   let USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"; 
12:    
13:   before(async function() { 
14:     [owner, borrower, lender, investor, insurer] = await ethers.getSigners(); 
15:      
16:     // Déploiement de tous les contrats 
17:     const AccessController = await ethers.getContractFactory("AccessController"); 
18:     const accessController = await AccessController.deploy(); 
19:      
20:     const KYCRegistry = await ethers.getContractFactory("KYCRegistry"); 
21:     const kycRegistry = await KYCRegistry.deploy(accessController.address); 
22:      
23:     const OracleAdapter = await ethers.getContractFactory("OracleAdapter"); 
24:     const oracleAdapter = await OracleAdapter.deploy(); 
25:      
26:     const RiskEngineV2 = await ethers.getContractFactory("RiskEngineV2"); 
27:     riskEngine = await RiskEngineV2.deploy(oracleAdapter.address, kycRegistry.address); 
28:      
29:     const LoanNFTV2 = await ethers.getContractFactory("LoanNFTV2"); 
30:     loanNFT = await LoanNFTV2.deploy(); 
31:      
32:     const InsuranceModuleV2 = await ethers.getContractFactory("InsuranceModuleV2"); 
33:     insuranceModule = await InsuranceModuleV2.deploy(accessController.address); 
34:      
35:     const BondingCurveV2 = await ethers.getContractFactory("BondingCurveV2"); 
36:     bondingCurve = await BondingCurveV2.deploy(); 
37:      
38:     const DynamicTranche = await ethers.getContractFactory("DynamicTranche"); 
39:     dynamicTranche = await DynamicTranche.deploy(accessController.address); 
40:      
41:     const SecondaryMarketV2 = await ethers.getContractFactory("SecondaryMarketV2"); 
42:     secondaryMarket = await SecondaryMarketV2.deploy( 
43:       loanNFT.address, 
44:       USDC, 
45:       owner.address 
46:     ); 
47:      
48:     const LoanPoolV2 = await ethers.getContractFactory("LoanPoolV2"); 
49:     loanPool = await LoanPoolV2.deploy( 
50:       riskEngine.address, 
51:       loanNFT.address, 
52:       insuranceModule.address, 
53:       bondingCurve.address, 
54:       dynamicTranche.address, 
55:       accessController.address 
56:     ); 
57:      
58:     const ReputationTokenV2 = await ethers.getContractFactory("ReputationTokenV2"); 
59:     reputationToken = await ReputationTokenV2.deploy(); 
60:      
61:     // Configuration KYC 
62:     await kycRegistry.verifyUser(borrower.address, "ipfs://Qm..."); 
63:      
64:     // Configuration des rôles 
65:     await accessController.initializeRoles(); 
66:     await accessController.grantRole(loanPool.address, "LOAN_MANAGER"); 
67:     await accessController.grantRole(riskEngine.address, "RISK_MANAGER"); 
68:     await accessController.grantRole(insuranceModule.address, "INSURANCE_MANAGER"); 
69:      
70:     // Configuration LoanNFT 
71:     await loanNFT.grantRole(await loanNFT.LOAN_MANAGER(), loanPool.address); 
72:     await loanNFT.grantRole(await loanNFT.MARKET_MANAGER(), secondaryMarket.address); 
73:      
74:     // Configuration InsuranceModule 
75:     await insuranceModule.setLoanPool(loanPool.address); 
76:   }); 
77:    
78:   describe("1. Système de Prêt V2", function() { 
79:     it("1.1 Devrait créer un prêt avec scoring de risque avancé", async function() { 
80:       const loanAmount = ethers.utils.parseEther("1.0"); 
81:       const duration = 90 * 24 * 60 * 60; 
82:        
83:       const tx = await loanPool.connect(borrower).createLoan( 
84:         loanAmount, 
85:         duration, 
86:         ethers.constants.AddressZero, 
87:         ethers.utils.parseEther("1.5"), 
88:         "0x" 
89:       ); 
90:        
91:       const receipt = await tx.wait(); 
92:       const event = receipt.events?.find(e => e.event === "LoanCreated"); 
93:        
94:       expect(event).to.not.be.undefined; 
95:       expect(event.args.loanId).to.equal(1); 
96:       expect(event.args.borrower).to.equal(borrower.address); 
97:     }); 
98:      
99:     it("1.2 Devrait calculer dynamiquement la tranche", async function() { 
100:       // Test avec différents montants et scores de risque 
101:       // À implémenter 
102:     }); 
103:      
104:     it("1.3 Devrait offrir une assurance automatique", async function() { 
105:       // Vérifier que l'assurance est proposée pour les prêts éligibles 
106:       // À implémenter 
107:     }); 
108:   }); 
109:    
110:   describe("2. Courbe de Liaison V2", function() { 
111:     it("2.1 Devrait calculer les taux d'intérêt selon différents modèles", async function() { 
112:       const amount = ethers.utils.parseEther("1.0"); 
113:       const riskScore = 500; 
114:       const activeLoans = 10; 
115:       const totalLiquidity = ethers.utils.parseEther("100"); 
116:        
117:       const [trancheId, interestRate] = await bondingCurve.calculateTerms( 
118:         amount, 
119:         riskScore, 
120:         activeLoans, 
121:         totalLiquidity 
122:       ); 
123:        
124:       expect(trancheId).to.be.a('number'); 
125:       expect(interestRate).to.be.gt(0); 
126:     }); 
127:      
128:     it("2.2 Devrait ajuster dynamiquement les paramètres", async function() { 
129:       // Test des ajustements basés sur les données historiques 
130:       // À implémenter 
131:     }); 
132:   }); 
133:    
134:   describe("3. Assurance V2", function() { 
135:     it("3.1 Devrait vérifier l'éligibilité à l'assurance", async function() { 
136:       const loanId = 1; 
137:       const riskScore = 400; 
138:       const loanAmount = ethers.utils.parseEther("1.0"); 
139:        
140:       const [eligible, premium, coverage] = await insuranceModule.checkEligibility( 
141:         loanId, 
142:         riskScore, 
143:         loanAmount 
144:       ); 
145:        
146:       expect(eligible).to.be.a('boolean'); 
147:       if (eligible) { 
148:         expect(premium).to.be.gt(0); 
149:         expect(coverage).to.be.gt(0); 
150:       } 
151:     }); 
152:      
153:     it("3.2 Devrait permettre l'enregistrement d'assureurs", async function() { 
154:       const capitalAmount = ethers.utils.parseEther("10000"); 
155:        
156:       // Note: Nécessite un token ERC20 pour les tests 
157:       // À implémenter avec un mock token 
158:     }); 
159:   }); 
160:    
161:   describe("4. NFT de Prêts V2", function() { 
162:     it("4.1 Devrait mint un NFT pour un nouveau prêt", async function() { 
163:       const tx = await loanNFT.mint( 
164:         borrower.address, 
165:         1, 
166:         ethers.utils.parseEther("1.0"), 
167:         500, // interestRate 
168:         90 days, 
169:         600, // riskScore 
170:         1,   // trancheId 
171:         ethers.constants.AddressZero, 
172:         "ipfs://metadata" 
173:       ); 
174:        
175:       await tx.wait(); 
176:        
177:       const owner = await loanNFT.ownerOf(1); 
178:       expect(owner).to.equal(borrower.address); 
179:     }); 
180:      
181:     it("4.2 Devrait calculer la valeur actuelle du prêt", async function() { 
182:       const currentValue = await loanNFT.calculateCurrentValue(1); 
183:       expect(currentValue).to.be.gt(0); 
184:     }); 
185:   }); 
186:    
187:   describe("5. Marché Secondaire V2", function() { 
188:     it("5.1 Devrait lister un NFT à prix fixe", async function() { 
189:       // Le propriétaire doit approuver d'abord 
190:       await loanNFT.connect(borrower).approve(secondaryMarket.address, 1); 
191:        
192:       const price = ethers.utils.parseUnits("1.1", 6); // 1.1 USDC 
193:       const tx = await secondaryMarket.connect(borrower).listFixedPrice( 
194:         1, 
195:         price, 
196:         30 // 30 jours 
197:       ); 
198:        
199:       await tx.wait(); 
200:        
201:       const listing = await secondaryMarket.listings(1); 
202:       expect(listing.isActive).to.be.true; 
203:       expect(listing.seller).to.equal(borrower.address); 
204:     }); 
205:      
206:     it("5.2 Devrait permettre l'achat d'un NFT listé", async function() { 
207:       // Nécessite des USDC pour l'acheteur 
208:       // À implémenter avec un mock USDC 
209:     }); 
210:   }); 
211:    
212:   describe("6. Gouvernance V2", function() { 
213:     it("6.1 Devrait créer une proposition améliorée", async function() { 
214:       // Test de création de proposition avec réputation 
215:       // À implémenter 
216:     }); 
217:      
218:     it("6.2 Devrait permettre le vote avec poids de réputation", async function() { 
219:       // Test du vote combinant tokens et réputation 
220:       // À implémenter 
221:     }); 
222:   }); 
223:    
224:   describe("7. Fonds de Garantie V2", function() { 
225:     it("7.1 Devrait permettre le dépôt dans différents tiers", async function() { 
226:       // Test des dépôts avec différents niveaux de risque 
227:       // À implémenter 
228:     }); 
229:      
230:     it("7.2 Devrait couvrir les pertes depuis le fonds", async function() { 
231:       // Test de la couverture des pertes 
232:       // À implémenter 
233:     }); 
234:   }); 
235:    
236:   describe("8. Notifications V2", function() { 
237:     it("8.1 Devrait envoyer des notifications pour les événements importants", async function() { 
238:       // Test de l'envoi de notifications 
239:       // À implémenter 
240:     }); 
241:      
242:     it("8.2 Devrait respecter les préférences utilisateur", async function() { 
243:       // Test des préférences de notification 
244:       // À implémenter 
245:     }); 
246:   }); 
247:    
248:   describe("9. Réputation V2", function() { 
249:     it("9.1 Devrait accorder de la réputation pour les bonnes actions", async function() { 
250:       // Test de l'attribution de réputation 
251:       // À implémenter 
252:     }); 
253:      
254:     it("9.2 Devrait appliquer la dégradation (decay) de la réputation", async function() { 
255:       // Test de la dégradation dans le temps 
256:       // À implémenter 
257:     }); 
258:   }); 
259:    
260:   describe("10. Distribution de Frais V2", function() { 
261:     it("10.1 Devrait accumuler et distribuer les frais", async function() { 
262:       // Test de la distribution de frais 
263:       // À implémenter 
264:     }); 
265:      
266:     it("10.2 Devrait distribuer les récompenses de performance", async function() { 
267:       // Test des récompenses de performance 
268:       // À implémenter 
269:     }); 
270:   }); 
271:    
272:   describe("Intégration Complète", function() { 
273:     it("Devrait exécuter un flux complet de prêt avec toutes les fonctionnalités", async function() { 
274:       // Test d'intégration complet 
275:       // 1. Création de prêt avec scoring 
276:       // 2. Mint du NFT 
277:       // 3. Proposition d'assurance 
278:       // 4. Listing sur le marché secondaire 
279:       // 5. Achat sur le marché secondaire 
280:       // 6. Remboursement du prêt 
281:       // 7. Distribution des récompenses 
282:       // 8. Mise à jour de la réputation 
283:       // 9. Envoi de notifications 
284:       // 10. Distribution des frais 
285:        
286:       // À implémenter 
287:     }); 
288:   }); 
289: }); 
------------------------------------------------------------------------------ 
 
TEST !test_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: test/ 
2: ├── LoanPool.test.js           # ✅ PRINCIPAL - Tests complets 
3: ├── RiskEngine.test.js         # À FAIRE - Tests RiskEngine 
4: ├── CriteriaFilter.test.js     # À FAIRE - Tests filtrage 
5: ├── SpecialOfferManager.test.js # À FAIRE - Tests offres 
6: ├── integration/               # Tests d'intégration 
7: │   └── FullFlow.test.js 
8: └── mocks/                     # Contrats mock 
9:     ├── MockERC20.sol 
10:     └── MockOracle.sol 
------------------------------------------------------------------------------ 
 
TEST !test_count! | !filepath! 
Size: !filesize! bytes | Type: !fileext! | Modified: !filemodified! 
------------------------------------------------------------------------------ 
1: // test/mocks/MockERC20.test.js 
2: const { expect } = require("chai"); 
3: const { ethers } = require("hardhat"); 
4: describe("MockERC20", function () { 
5:   let mockToken; 
6:   let owner, user1, user2; 
7:    
8:   beforeEach(async function () { 
9:     [owner, user1, user2] = await ethers.getSigners(); 
10:      
11:     const MockERC20 = await ethers.getContractFactory("MockERC20"); 
12:     mockToken = await MockERC20.deploy("Mock USDC", "mUSDC", 6); 
13:   }); 
14:    
15:   describe("Déploiement", function () { 
16:     it("Devrait avoir le bon nom et symbole", async function () { 
17:       expect(await mockToken.name()).to.equal("Mock USDC"); 
18:       expect(await mockToken.symbol()).to.equal("mUSDC"); 
19:       expect(await mockToken.decimals()).to.equal(6); 
20:     }); 
21:      
22:     it("Devrait mint des tokens initiaux au owner", async function () { 
23:       const balance = await mockToken.balanceOf(owner.address); 
24:       expect(balance).to.equal(1000000 * 10 ** 6); 
25:     }); 
26:   }); 
27:    
28:   describe("Fonctions Mint/Burn", function () { 
29:     it("Devrait permettre au owner de mint", async function () { 
30:       await mockToken.mint(user1.address, 1000 * 10 ** 6); 
31:       expect(await mockToken.balanceOf(user1.address)).to.equal(1000 * 10 ** 6); 
32:     }); 
33:      
34:     it("Ne devrait pas permettre aux non-owners de mint", async function () { 
35:       await expect( 
36:         mockToken.connect(user1).mint(user2.address, 1000 * 10 ** 6) 
37:       ).to.be.revertedWith("MockERC20: Only owner can mint"); 
38:     }); 
39:      
40:     it("Devrait permettre au owner de burn", async function () { 
41:       // D'abord mint 
42:       await mockToken.mint(user1.address, 1000 * 10 ** 6); 
43:        
44:       // Puis burn 
45:       await mockToken.burn(user1.address, 500 * 10 ** 6); 
46:       expect(await mockToken.balanceOf(user1.address)).to.equal(500 * 10 ** 6); 
47:     }); 
48:   }); 
49:    
50:   describe("Batch Mint", function () { 
51:     it("Devrait mint en batch", async function () { 
52:       const recipients = [user1.address, user2.address]; 
53:       const amounts = [1000 * 10 ** 6, 2000 * 10 ** 6]; 
54:        
55:       await mockToken.batchMint(recipients, amounts); 
56:        
57:       expect(await mockToken.balanceOf(user1.address)).to.equal(1000 * 10 ** 6); 
58:       expect(await mockToken.balanceOf(user2.address)).to.equal(2000 * 10 ** 6); 
59:     }); 
60:      
61:     it("Ne devrait pas mint en batch avec des tableaux de tailles différentes", async function () { 
62:       const recipients = [user1.address, user2.address]; 
63:       const amounts = [1000 * 10 ** 6]; 
64:        
65:       await expect( 
66:         mockToken.batchMint(recipients, amounts) 
67:       ).to.be.revertedWith("MockERC20: Arrays length mismatch"); 
68:     }); 
69:   }); 
70:    
71:   describe("Transfert de propriété", function () { 
72:     it("Devrait transférer la propriété", async function () { 
73:       await mockToken.transferOwnership(user1.address); 
74:       expect(await mockToken.owner()).to.equal(user1.address); 
75:     }); 
76:      
77:     it("Le nouveau owner devrait pouvoir mint", async function () { 
78:       await mockToken.transferOwnership(user1.address); 
79:       await mockToken.connect(user1).mint(user2.address, 1000 * 10 ** 6); 
80:       expect(await mockToken.balanceOf(user2.address)).to.equal(1000 * 10 ** 6); 
81:     }); 
82:   }); 
83: }); 
------------------------------------------------------------------------------ 
 
[PROJECT FILE STRUCTURE] 
============================================================================== 
Listing all project files... 
 
CONTRACTS: 
D:\structured-lending-protocol-clean\contracts\access
D:\structured-lending-protocol-clean\contracts\core
D:\structured-lending-protocol-clean\contracts\governance
D:\structured-lending-protocol-clean\contracts\infrastructure
D:\structured-lending-protocol-clean\contracts\insurance
D:\structured-lending-protocol-clean\contracts\interfaces
D:\structured-lending-protocol-clean\contracts\mocks
D:\structured-lending-protocol-clean\contracts\nft-market
D:\structured-lending-protocol-clean\contracts\PoolSyncTest.sol
D:\structured-lending-protocol-clean\contracts\security
D:\structured-lending-protocol-clean\contracts\test.sol
D:\structured-lending-protocol-clean\contracts\utils
D:\structured-lending-protocol-clean\contracts\core\BondingCurve.sol
D:\structured-lending-protocol-clean\contracts\core\DynamicTranche.sol
D:\structured-lending-protocol-clean\contracts\core\LoanPool.sol
D:\structured-lending-protocol-clean\contracts\core\RiskEngine.sol
D:\structured-lending-protocol-clean\contracts\governance\GovernanceDAO.sol
D:\structured-lending-protocol-clean\contracts\governance\ReputationToken.sol
D:\structured-lending-protocol-clean\contracts\infrastructure\FeeDistributor.sol
D:\structured-lending-protocol-clean\contracts\infrastructure\NotificationManager.sol
D:\structured-lending-protocol-clean\contracts\infrastructure\OracleAdapter.sol
D:\structured-lending-protocol-clean\contracts\insurance\DecentralizedGuaranteeFund.sol
D:\structured-lending-protocol-clean\contracts\insurance\InsuranceModule.sol
D:\structured-lending-protocol-clean\contracts\interfaces\ICriteriaFilter.sol
D:\structured-lending-protocol-clean\contracts\interfaces\IInsuranceModule.sol
D:\structured-lending-protocol-clean\contracts\interfaces\ILoanPool.sol
D:\structured-lending-protocol-clean\contracts\interfaces\IRiskEngine.sol
D:\structured-lending-protocol-clean\contracts\interfaces\ISpecialOfferManager.sol
D:\structured-lending-protocol-clean\contracts\interfaces\IStructuredLending.sol
D:\structured-lending-protocol-clean\contracts\mocks\MockERC20.sol
D:\structured-lending-protocol-clean\contracts\nft-market\LoanNFT.sol
D:\structured-lending-protocol-clean\contracts\nft-market\SecondaryMarket.sol
D:\structured-lending-protocol-clean\contracts\security\AccessController.sol
D:\structured-lending-protocol-clean\contracts\security\EmergencyExecutor.sol
D:\structured-lending-protocol-clean\contracts\security\KYCRegistry.sol
D:\structured-lending-protocol-clean\contracts\security\RegulatoryReporting.sol
D:\structured-lending-protocol-clean\contracts\utils\CriteriaFilter.sol
D:\structured-lending-protocol-clean\contracts\utils\SpecialOfferManager.sol.backup
 
SCRIPTS: 
D:\structured-lending-protocol-clean\scripts\Commandes d'Exécution.sh
D:\structured-lending-protocol-clean\scripts\Phase 1 - Environnement de Développement.bat
D:\structured-lending-protocol-clean\scripts\seed-testnet.js
D:\structured-lending-protocol-clean\scripts\Sortie attendue du script _seed-testnet.js_.txt
 
TESTS: 
D:\structured-lending-protocol-clean\test\LoanPool.test.js
D:\structured-lending-protocol-clean\test\mocks
D:\structured-lending-protocol-clean\test\Structure des tests.txt
D:\structured-lending-protocol-clean\test\test-security-v2.js
D:\structured-lending-protocol-clean\test\test-v2-complete.js
D:\structured-lending-protocol-clean\test\Tests Exhaustifs
D:\structured-lending-protocol-clean\test\mocks\MockERC20.test.js
 
CONFIG FILES: 
package-lock.json
package.json
 
 
[SUMMARY] 
============================================================================== 
Total contract files: 27 
Total script files: 4 
Total test files: 5 
Total code files: 36 
 
Generated: 06/01/2026 18:22:45,87 
============================================================================== 
