PROJECT: Structured Lending Protocol 
GITHUB: poolsyncdefi-ui/structured-lending-protocol-clean 
DATE: 03/01/2026 TIME: 14:02:49,12 
 
GIT INFO: 
Branch: main 
Commit: 516c1ea 
 
=== CONTRACT FILES === 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\PoolSyncTest.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract PoolSyncTest {
    string public name = "PoolSync";
    uint256 public version = 1;
    
    function getName() public view returns (string memory) {
        return name;
    }
    
    function getVersion() public view returns (uint256) {
        return version;
    }
}
--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\test.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TestContract {
    function createOffer() public pure returns (uint256) {
        return 1;
    }
    
    function callCreateOffer() public pure returns (uint256) {
        return createOffer();
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\core\BondingCurve.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title BondingCurve - Courbe de liaison pour prix dynamique des jetons
 * @notice Implémente une courbe de liaison pour ajuster le prix des jetons de pool
 */
contract BondingCurve is Ownable {
        
    struct CurveParameters {
        uint256 basePrice;           // Prix de base
        uint256 slope;               // Pente de la courbe
        uint256 exponentialFactor;   // Facteur exponentiel
        uint256 maxPriceMultiplier;  // Multiplicateur max
        uint256 liquiditySensitivity; // Sensibilité à la liquidité
    }
    
    // Paramètres par défaut
    CurveParameters public params;
    
    // Données par pool
    struct PoolCurveData {
        uint256 initialPrice;
        uint256 totalSupply;
        uint256 currentPrice;
        uint256 lastUpdate;
        uint256 volume24h;
    }
    
    mapping(uint256 => PoolCurveData) public poolCurves;
    
    // Événements
    event PriceUpdated(uint256 indexed poolId, uint256 oldPrice, uint256 newPrice);
    event CurveParametersUpdated(uint256 timestamp);
    
    constructor() Ownable(msg.sender) {
        // Paramètres par défaut
        params = CurveParameters({
            basePrice: 1 * 10**18,       // 1.0 stablecoin
            slope: 100,                  // 0.01% par token
            exponentialFactor: 2,        // Courbe quadratique
            maxPriceMultiplier: 200,     // 2x max
            liquiditySensitivity: 50     // 0.5% de sensibilité
        });
    }
    
    /**
     * @notice Calcule le prix d'achat pour des tokens
     */
    function calculateBuyPrice(
        uint256 poolId,
        uint256 tokenAmount,
        uint256 currentSupply
    ) external view returns (uint256 totalCost, uint256 averagePrice) {
        PoolCurveData storage curve = poolCurves[poolId];
        
        if (curve.totalSupply == 0) {
            // Premier achat
            totalCost = tokenAmount * params.basePrice;
            averagePrice = params.basePrice;
        } else {
            // Calcul basé sur la courbe
            totalCost = _calculateIntegral(
                curve.totalSupply,
                curve.totalSupply + tokenAmount,
                currentSupply
            );
            averagePrice = totalCost / tokenAmount;
        }
        
        return (totalCost, averagePrice);
    }
    
    /**
     * @notice Calcule le prix de vente pour des tokens
     */
    function calculateSellPrice(
        uint256 poolId,
        uint256 tokenAmount,
        uint256 currentSupply
    ) external view returns (uint256 totalReturn, uint256 averagePrice) {
        require(tokenAmount <= poolCurves[poolId].totalSupply, "Insufficient supply");
        
        totalReturn = _calculateIntegral(
            poolCurves[poolId].totalSupply - tokenAmount,
            poolCurves[poolId].totalSupply,
            currentSupply
        );
        
        averagePrice = totalReturn / tokenAmount;
        return (totalReturn, averagePrice);
    }
    
    /**
     * @notice Met à jour le prix après un achat/vente
     */
    function updatePriceAfterTrade(
        uint256 poolId,
        uint256 tokenAmount,
        bool isBuy,
        uint256 currentSupply
    ) external returns (uint256 newPrice) {
        PoolCurveData storage curve = poolCurves[poolId];
        
        uint256 oldPrice = curve.currentPrice;
        
        if (isBuy) {
            curve.totalSupply += tokenAmount;
        } else {
            curve.totalSupply -= tokenAmount;
        }
        
        // Mise à jour du prix courant
        newPrice = _calculateSpotPrice(curve.totalSupply, currentSupply);
        curve.currentPrice = newPrice;
        curve.lastUpdate = block.timestamp;
        
        // Mise à jour du volume 24h
        curve.volume24h += tokenAmount * newPrice;
        
        emit PriceUpdated(poolId, oldPrice, newPrice);
        
        return newPrice;
    }
    
    /**
     * @notice Initialise la courbe pour un nouveau pool
     */
    function initializePoolCurve(uint256 poolId, uint256 initialSupply) external onlyOwner {
        require(poolCurves[poolId].totalSupply == 0, "Already initialized");
        
        poolCurves[poolId] = PoolCurveData({
            initialPrice: params.basePrice,
            totalSupply: initialSupply,
            currentPrice: params.basePrice,
            lastUpdate: block.timestamp,
            volume24h: 0
        });
    }
    
    /**
     * @notice Réinitialise le volume 24h (à appeler périodiquement)
     */
    function reset24hVolume(uint256 poolId) external onlyOwner {
        poolCurves[poolId].volume24h = 0;
    }
    
    // ============ FONCTIONS INTERNES ============
    
    function _calculateSpotPrice(uint256 supply, uint256 currentSupply) internal view returns (uint256) {
        if (supply == 0) return params.basePrice;
        
        // Formule: price = basePrice * (1 + slope * supply^exponentialFactor)
        uint256 supplyFactor = supply ** params.exponentialFactor;
        uint256 priceIncrease = params.basePrice * params.slope * supplyFactor / (10**18);
        
        // Ajustement par liquidité
        uint256 liquidityAdjustment = 1;
        if (currentSupply > 0) {
            uint256 utilization = supply * 100 / currentSupply;
            if (utilization > 80) {
                liquidityAdjustment = 120; // +20% si utilisation élevée
            } else if (utilization < 20) {
                liquidityAdjustment = 80;  // -20% si utilisation faible
            }
        }
        
        uint256 price = params.basePrice + priceIncrease;
        price = price * liquidityAdjustment / 100;
        
        // Limite maximale
        uint256 maxPrice = params.basePrice * params.maxPriceMultiplier / 100;
        if (price > maxPrice) price = maxPrice;
        
        return price;
    }
    
    function _calculateIntegral(
        uint256 fromSupply,
        uint256 toSupply,
        uint256 currentSupply
    ) internal view returns (uint256) {
        // Intégrale approximative de la fonction de prix
        uint256 total = 0;
        uint256 step = (toSupply - fromSupply) / 100; // 100 steps pour précision
        
        if (step == 0) step = 1;
        
        for (uint256 s = fromSupply; s < toSupply; s += step) {
            uint256 price = _calculateSpotPrice(s, currentSupply);
            total += price * step;
        }
        
        return total;
    }
    
    // ============ FONCTIONS ADMIN ============
    
    function updateCurveParameters(
        uint256 basePrice,
        uint256 slope,
        uint256 exponentialFactor,
        uint256 maxPriceMultiplier,
        uint256 liquiditySensitivity
    ) external onlyOwner {
        require(basePrice > 0, "Base price must be positive");
        require(slope <= 1000, "Slope too high"); // Max 10%
        require(exponentialFactor <= 3, "Exponential factor too high");
        require(maxPriceMultiplier <= 500, "Max multiplier too high"); // Max 5x
        
        params = CurveParameters({
            basePrice: basePrice,
            slope: slope,
            exponentialFactor: exponentialFactor,
            maxPriceMultiplier: maxPriceMultiplier,
            liquiditySensitivity: liquiditySensitivity
        });
        
        emit CurveParametersUpdated(block.timestamp);
    }
    
    function getPoolCurveData(uint256 poolId) external view returns (PoolCurveData memory) {
        return poolCurves[poolId];
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\core\DynamicTranche.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title DynamicTranche - Gestion dynamique des tranches de risque
 * @notice Crée et gère des tranches avec différents niveaux de risque/rendement
 */
contract DynamicTranche is ERC20, Ownable {
        
    enum TrancheType {
        SENIOR,     // Risque faible, rendement faible
        MEZZANINE,  // Risque moyen, rendement moyen
        JUNIOR      // Risque élevé, rendement élevé
    }
    
    struct Tranche {
        TrancheType trancheType;
        string name;
        uint256 targetAllocation;   // Allocation cible en %
        uint256 currentAllocation;  // Allocation actuelle
        uint256 minRiskScore;       // Score risque minimum
        uint256 maxRiskScore;       // Score risque maximum
        uint256 yieldMultiplier;    // Multiplicateur de rendement
        uint256 lossAbsorption;     // % d'absorption des pertes
        address trancheToken;       // Token de la tranche
        bool isActive;
    }
    
    // Tranches disponibles
    mapping(uint256 => Tranche) public tranches;
    uint256 public trancheCount;
    
    // Pool associé
    uint256 public poolId;
    address public loanPool;
    
    // Événements
    event TrancheCreated(uint256 indexed trancheId, TrancheType trancheType, string name);
    event InvestmentAllocated(uint256 indexed trancheId, uint256 amount);
    event ReturnsDistributed(uint256 indexed trancheId, uint256 amount);
    event LossesAbsorbed(uint256 indexed trancheId, uint256 amount);
    
	constructor(
		uint256 _poolId,
		address _loanPool,
		string memory name,
		string memory symbol
	) 
		ERC20(name, symbol) 
		Ownable(msg.sender) 
	{
		poolId = _poolId;
		loanPool = _loanPool;
		_createDefaultTranches();
	}
    
    /**
     * @notice Crée les tranches par défaut
     */
    function _createDefaultTranches() internal {
        // Tranche Senior (60%)
        _createTranche(
            TrancheType.SENIOR,
            "Senior Tranche",
            6000,   // 60%
            1,      // Risque 1-3
            3,
            80,     // 0.8x rendement
            10      // 10% absorption pertes
        );
        
        // Tranche Mezzanine (30%)
        _createTranche(
            TrancheType.MEZZANINE,
            "Mezzanine Tranche",
            3000,   // 30%
            4,      // Risque 4-6
            6,
            120,    // 1.2x rendement
            30      // 30% absorption pertes
        );
        
        // Tranche Junior (10%)
        _createTranche(
            TrancheType.JUNIOR,
            "Junior Tranche",
            1000,   // 10%
            7,      // Risque 7-10
            10,
            200,    // 2.0x rendement
            60      // 60% absorption pertes
        );
    }
    
    /**
     * @notice Crée une nouvelle tranche
     */
    function _createTranche(
        TrancheType trancheType,
        string memory name,
        uint256 targetAllocation,
        uint256 minRiskScore,
        uint256 maxRiskScore,
        uint256 yieldMultiplier,
        uint256 lossAbsorption
    ) internal {
        uint256 trancheId = trancheCount++;
        
        // Création du token de tranche
        string memory tokenSymbol = string(abi.encodePacked("TRANCHE", Strings.toString(trancheId)));
        address trancheToken = address(new TrancheToken(name, tokenSymbol));
        
        tranches[trancheId] = Tranche({
            trancheType: trancheType,
            name: name,
            targetAllocation: targetAllocation,
            currentAllocation: 0,
            minRiskScore: minRiskScore,
            maxRiskScore: maxRiskScore,
            yieldMultiplier: yieldMultiplier,
            lossAbsorption: lossAbsorption,
            trancheToken: trancheToken,
            isActive: true
        });
        
        emit TrancheCreated(trancheId, trancheType, name);
    }
    
    /**
     * @notice Alloue un investissement aux tranches
     */
    function allocateInvestment(uint256 amount, uint256 riskScore) external onlyOwner returns (uint256[] memory) {
        require(amount > 0, "Amount must be positive");
        
        uint256[] memory allocations = new uint256[](trancheCount);
        uint256 remaining = amount;
        
        // Allocation basée sur les allocations cibles et le risque
        for (uint256 i = 0; i < trancheCount; i++) {
            if (!tranches[i].isActive) continue;
            
            // Vérifier si la tranche accepte ce niveau de risque
            if (riskScore >= tranches[i].minRiskScore && riskScore <= tranches[i].maxRiskScore) {
                uint256 allocation = amount * tranches[i].targetAllocation / 10000;
                
                // Ajustement dynamique basé sur l'allocation actuelle
                if (tranches[i].currentAllocation > tranches[i].targetAllocation * 110 / 100) {
                    // Sur-allocation, réduire
                    allocation = allocation * 80 / 100;
                }
                
                allocations[i] = allocation;
                tranches[i].currentAllocation += allocation;
                remaining -= allocation;
                
                emit InvestmentAllocated(i, allocation);
            }
        }
        
        // Redistribuer le reste
        if (remaining > 0) {
            for (uint256 i = 0; i < trancheCount && remaining > 0; i++) {
                if (allocations[i] > 0) {
                    uint256 extra = remaining * allocations[i] / amount;
                    allocations[i] += extra;
                    tranches[i].currentAllocation += extra;
                    remaining -= extra;
                }
            }
        }
        
        return allocations;
    }
    
    /**
     * @notice Distribue les rendements aux tranches
     */
    function distributeReturns(uint256 totalReturns) external onlyOwner {
        require(totalReturns > 0, "No returns to distribute");
        
        for (uint256 i = 0; i < trancheCount; i++) {
            if (!tranches[i].isActive || tranches[i].currentAllocation == 0) continue;
            
            // Calcul de la part de la tranche
            uint256 trancheShare = totalReturns * tranches[i].currentAllocation / 10000;
            
            // Application du multiplicateur de rendement
            uint256 adjustedReturns = trancheShare * tranches[i].yieldMultiplier / 100;
            
            // Distribution aux détenteurs de tokens
            IERC20(tranches[i].trancheToken).transfer(msg.sender, adjustedReturns);
            
            emit ReturnsDistributed(i, adjustedReturns);
        }
    }
    
    /**
     * @notice Absorbe les pertes selon l'ordre des tranches
     */
    function absorbLosses(uint256 totalLosses) external onlyOwner returns (uint256 absorbed) {
        require(totalLosses > 0, "No losses to absorb");
        
        uint256 remainingLosses = totalLosses;
        
        // Absorption dans l'ordre inverse (Junior d'abord)
        for (uint256 i = trancheCount; i > 0; i--) {
            uint256 trancheId = i - 1;
            Tranche storage tranche = tranches[trancheId];
            
            if (!tranche.isActive || tranche.currentAllocation == 0) continue;
            
            // Calcul de la capacité d'absorption
            uint256 absorptionCapacity = tranche.currentAllocation * tranche.lossAbsorption / 100;
            uint256 toAbsorb = remainingLosses < absorptionCapacity ? remainingLosses : absorptionCapacity;
            
            if (toAbsorb > 0) {
                tranche.currentAllocation -= toAbsorb;
                remainingLosses -= toAbsorb;
                absorbed += toAbsorb;
                
                // Burn des tokens proportionnellement
                uint256 burnAmount = toAbsorb * IERC20(tranche.trancheToken).totalSupply() / tranche.currentAllocation;
                IERC20(tranche.trancheToken).transferFrom(msg.sender, address(this), burnAmount);
                
                emit LossesAbsorbed(trancheId, toAbsorb);
            }
            
            if (remainingLosses == 0) break;
        }
        
        return absorbed;
    }
    
    /**
     * @notice Récupère les détails de toutes les tranches
     */
    function getAllTranches() external view returns (Tranche[] memory) {
        Tranche[] memory result = new Tranche[](trancheCount);
        
        for (uint256 i = 0; i < trancheCount; i++) {
            result[i] = tranches[i];
        }
        
        return result;
    }
    
    /**
     * @notice Vérifie si un score de risque est éligible pour une tranche
     */
    function isRiskEligible(uint256 trancheId, uint256 riskScore) external view returns (bool) {
        Tranche storage tranche = tranches[trancheId];
        return riskScore >= tranche.minRiskScore && riskScore <= tranche.maxRiskScore;
    }
}

// Token pour tranche individuelle
contract TrancheToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        // Mint initial de 1 million de tokens
        _mint(msg.sender, 1000000 * 10**18);
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\core\LoanPool.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Imports nécessaires
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

// Interfaces du protocole
import "../interfaces/IRiskEngine.sol";
import "../interfaces/ICriteriaFilter.sol";
import "../interfaces/ISpecialOfferManager.sol";
import "../interfaces/IInsuranceModule.sol";

/**
 * @title LoanPool - Contrat principal du protocole de prêt participatif
 * @notice Gère le cycle de vie complet d'un pool de prêt avec fonctionnalités avancées
 * @dev Implémente les mécanismes de taux dynamique, filtrage et intégration assurance
 */
contract LoanPool is ERC20, Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;

    // ============ STRUCTURES ET ÉNUMÉRATIONS ============

    /**
     * @notice État du pool de prêt
     */
    enum PoolStatus {
        CREATION,      // En configuration par l'emprunteur
        ACTIVE,        // Ouvert aux investissements
        FUNDED,        // Montant cible atteint, fonds transférés
        ONGOING,       // Prêt en cours de remboursement
        COMPLETED,     // Remboursement intégral effectué
        DEFAULTED,     // Défaut de paiement
        LIQUIDATED,    // Pool liquidé après défaut
        CANCELLED      // Annulé avant financement
    }

    /**
     * @notice Structure principale d'un pool de prêt
     */
    struct PoolData {
        // Identifiants
        uint256 poolId;
        address borrower;
        string projectName;
        string projectDescription;
        string projectIpfsHash; // Documents légaux sur IPFS
        
        // Paramètres financiers
        uint256 targetAmount;
        uint256 collectedAmount;
        uint256 baseInterestRate;     // en points de base (ex: 500 = 5%)
        uint256 dynamicInterestRate;  // taux actuel après ajustements
        uint256 repaymentAmount;      // montant total à rembourser
        uint256 amountRepaid;         // montant déjà remboursé
        uint256 duration;             // durée en jours
        uint256 fundingDeadline;      // date limite de financement
        uint256 startDate;            // date de début du prêt
        uint256 completionDate;       // date de fin du prêt
        
        // Critères du projet
        string region;
        bool isEcological;
        string activityDomain;
        uint256 riskScore;            // 1-10 (calculé par RiskEngine)
        
        // Gestion des jetons
        uint256 tokenPrice;           // prix par jeton (en stablecoin)
        uint256 totalTokens;          // nombre total de jetons
        uint256 soldTokens;           // jetons déjà vendus
        
        // Assurance
        uint256 insuranceCoverage;    // montant couvert par assurance
        uint256 insurancePoolId;      // ID du pool d'assurance
        address insuranceModule;      // adresse du module d'assurance
        
        // Offres spéciales
        bool hasSpecialOffer;
        uint256 specialOfferId;
        uint256 specialOfferEndTime;
        uint256 specialOfferBonus;    // bonus de taux en points de base
        
        // Statut
        PoolStatus status;
        uint256 createdAt;
        uint256 lastRateUpdate;
    }

    /**
     * @notice Structure pour les investisseurs
     */
    struct Investor {
        address investorAddress;
        uint256 tokenAmount;
        uint256 investmentAmount;
        uint256 claimedReturns;
        uint256 investmentTime;
    }

    // ============ ÉVÉNEMENTS ============

    event PoolCreated(
        uint256 indexed poolId,
        address indexed borrower,
        uint256 targetAmount,
        uint256 baseInterestRate
    );
    
    event InvestmentMade(
        uint256 indexed poolId,
        address indexed investor,
        uint256 amount,
        uint256 tokensReceived,
        uint256 dynamicRate
    );
    
    event PoolFunded(
        uint256 indexed poolId,
        uint256 totalCollected,
        uint256 fundedDate
    );
    
    event RepaymentMade(
        uint256 indexed poolId,
        uint256 amount,
        uint256 remainingBalance
    );
    
    event PoolCompleted(
        uint256 indexed poolId,
        uint256 totalReturnsDistributed
    );
    
    event DefaultTriggered(
        uint256 indexed poolId,
        uint256 defaultAmount,
        address triggeredBy
    );
    
    event DynamicRateUpdated(
        uint256 indexed poolId,
        uint256 oldRate,
        uint256 newRate
    );

    // ============ ÉTAT DU CONTRAT ============

    // Stablecoin utilisé (USDC, DAI, etc.)
    IERC20 public immutable stablecoin;
    
    // Modules externes
    IRiskEngine public riskEngine;
    ICriteriaFilter public criteriaFilter;
    ISpecialOfferManager public specialOfferManager;
    
    // Données des pools
    mapping(uint256 => PoolData) public pools;
    mapping(uint256 => Investor[]) public poolInvestors;
    mapping(uint256 => mapping(address => uint256)) public investorIndex;
    
    // Compteurs
    uint256 public nextPoolId;
    uint256 public totalPoolsCreated;
    uint256 public totalVolume;
    
    // Paramètres du protocole
    uint256 public protocolFee = 50; // 0.5% en points de base
    address public feeCollector;
    uint256 public minInvestment = 100 * 10**18; // 100 stablecoins
    uint256 public maxInvestment = 100000 * 10**18; // 100,000 stablecoins
    
    // Sécurité
    bool public emergencyPause;
    mapping(address => bool) public authorizedCreators;

    // ============ MODIFICATEURS ============

    modifier onlyBorrower(uint256 poolId) {
        require(pools[poolId].borrower == msg.sender, "Not the borrower");
        _;
    }

    modifier onlyActive(uint256 poolId) {
        require(pools[poolId].status == PoolStatus.ACTIVE, "Pool not active");
        _;
    }

    modifier onlyFunded(uint256 poolId) {
        require(pools[poolId].status == PoolStatus.FUNDED, "Pool not funded");
        _;
    }

    modifier onlyOngoing(uint256 poolId) {
        require(pools[poolId].status == PoolStatus.ONGOING, "Pool not ongoing");
        _;
    }

    modifier notPaused() {
        require(!emergencyPause, "Protocol paused");
        _;
    }

    // ============ CONSTRUCTEUR ============

    /**
     * @notice Initialise le contrat LoanPool
     * @param _stablecoin Adresse du token stable utilisé (USDC, DAI)
     * @param _riskEngine Adresse du RiskEngine
     * @param _feeCollector Adresse qui reçoit les frais du protocole
     */
    constructor(
		address _stablecoin,
		address _riskEngine,
		address _feeCollector
	) 
		ERC20("PoolSync Loan Token", "PSLT") 
		Ownable(msg.sender)
	{
		require(_stablecoin != address(0), "Invalid stablecoin address");
		require(_riskEngine != address(0), "Invalid risk engine address");
		require(_feeCollector != address(0), "Invalid fee collector");
    
		stablecoin = IERC20(_stablecoin);
		riskEngine = IRiskEngine(_riskEngine);
		feeCollector = _feeCollector;
    
		// Le déployeur est autorisé à créer des pools initialement
		authorizedCreators[msg.sender] = true;
	}

    // ============ FONCTIONS PUBLIQUES - CYCLE DE VIE ============

    /**
     * @notice Crée un nouveau pool de prêt
     * @dev Seuls les créateurs autorisés peuvent créer des pools
     */
    function createPool(
        string memory _projectName,
        string memory _projectDescription,
        uint256 _targetAmount,
        uint256 _duration,
        string memory _region,
        bool _isEcological,
        string memory _activityDomain,
        string memory _ipfsHash
    ) external notPaused returns (uint256) {
        require(authorizedCreators[msg.sender], "Not authorized to create pools");
        require(_targetAmount >= 1000 * 10**18, "Target amount too low");
        require(_targetAmount <= 1000000 * 10**18, "Target amount too high");
        require(_duration >= 30 days && _duration <= 365 days, "Invalid duration");
        
        uint256 poolId = nextPoolId++;
        
        // Calcul du taux de base par le RiskEngine
        uint256 baseRate = riskEngine.calculateBaseRate(
            msg.sender,
            _targetAmount,
            _duration,
            _isEcological,
            _activityDomain
        );
        
        // Calcul du score de risque
        uint256 riskScore = riskEngine.calculateRiskScore(
            msg.sender,
            _targetAmount,
            _duration,
            _region,
            _isEcological,
            _activityDomain
        );
        
        // Initialisation des données du pool
        pools[poolId] = PoolData({
            poolId: poolId,
            borrower: msg.sender,
            projectName: _projectName,
            projectDescription: _projectDescription,
            projectIpfsHash: _ipfsHash,
            targetAmount: _targetAmount,
            collectedAmount: 0,
            baseInterestRate: baseRate,
            dynamicInterestRate: baseRate,
            repaymentAmount: _targetAmount + (_targetAmount * baseRate / 10000),
            amountRepaid: 0,
            duration: _duration,
            fundingDeadline: block.timestamp + 30 days, // 30 jours pour lever les fonds
            startDate: 0,
            completionDate: 0,
            region: _region,
            isEcological: _isEcological,
            activityDomain: _activityDomain,
            riskScore: riskScore,
            tokenPrice: _targetAmount / 10000, // 10,000 tokens par défaut
            totalTokens: 10000,
            soldTokens: 0,
            insuranceCoverage: 0,
            insurancePoolId: 0,
            insuranceModule: address(0),
            hasSpecialOffer: false,
            specialOfferId: 0,
            specialOfferEndTime: 0,
            specialOfferBonus: 0,
            status: PoolStatus.CREATION,
            createdAt: block.timestamp,
            lastRateUpdate: block.timestamp
        });
        
        totalPoolsCreated++;
        
        emit PoolCreated(poolId, msg.sender, _targetAmount, baseRate);
        
        return poolId;
    }

    /**
     * @notice Active un pool pour le financement
     * @dev Doit être appelé par l'emprunteur après validation
     */
    function activatePool(uint256 poolId) external onlyBorrower(poolId) {
        PoolData storage pool = pools[poolId];
        require(pool.status == PoolStatus.CREATION, "Pool not in creation");
        require(block.timestamp <= pool.createdAt + 7 days, "Activation period expired");
        
        // Vérification finale par le RiskEngine
        require(riskEngine.validatePool(poolId), "Pool validation failed");
        
        pool.status = PoolStatus.ACTIVE;
        pool.lastRateUpdate = block.timestamp;
        
        // Vérification des offres spéciales actives
        _checkSpecialOffers(poolId);
    }

    /**
     * @notice Investit dans un pool actif
     * @dev Le taux d'intérêt est mis à jour dynamiquement avant l'investissement
     */
    function invest(uint256 poolId, uint256 amount) external nonReentrant notPaused onlyActive(poolId) {
        PoolData storage pool = pools[poolId];
        
        require(amount >= minInvestment, "Investment below minimum");
        require(amount <= maxInvestment, "Investment above maximum");
        require(block.timestamp <= pool.fundingDeadline, "Funding period ended");
        require(pool.collectedAmount + amount <= pool.targetAmount, "Exceeds target amount");
        
        // Mise à jour du taux dynamique
        _updateDynamicRate(poolId);
        
        // Calcul des tokens à allouer
        uint256 tokensToMint = (amount * 10**18) / pool.tokenPrice;
        require(tokensToMint > 0, "Token amount too small");
        
        // Transfert des fonds
        stablecoin.safeTransferFrom(msg.sender, address(this), amount);
        
        // Mise à jour des compteurs
        pool.collectedAmount += amount;
        pool.soldTokens += tokensToMint;
        
        // Enregistrement de l'investisseur
        uint256 investorIndexId = poolInvestors[poolId].length;
        poolInvestors[poolId].push(Investor({
            investorAddress: msg.sender,
            tokenAmount: tokensToMint,
            investmentAmount: amount,
            claimedReturns: 0,
            investmentTime: block.timestamp
        }));
        investorIndex[poolId][msg.sender] = investorIndexId;
        
        // Mint des tokens de pool
        _mint(msg.sender, tokensToMint);
        
        // Application des frais de protocole
        uint256 fee = amount * protocolFee / 10000;
        if (fee > 0) {
            stablecoin.safeTransfer(feeCollector, fee);
        }
        
        emit InvestmentMade(poolId, msg.sender, amount, tokensToMint, pool.dynamicInterestRate);
        
        // Vérification si le pool est entièrement financé
        if (pool.collectedAmount >= pool.targetAmount) {
            _finalizeFunding(poolId);
        }
    }

    /**
     * @notice Finalise le financement et transfère les fonds à l'emprunteur
     * @dev Appelé automatiquement lorsque le montant cible est atteint
     */
    function _finalizeFunding(uint256 poolId) internal {
        PoolData storage pool = pools[poolId];
        
        pool.status = PoolStatus.FUNDED;
        pool.startDate = block.timestamp;
        
        // Calcul du montant net après frais
        uint256 totalFees = pool.collectedAmount * protocolFee / 10000;
        uint256 netAmount = pool.collectedAmount - totalFees;
        
        // Transfert à l'emprunteur
        stablecoin.safeTransfer(pool.borrower, netAmount);
        
        // Démarrage de la période de remboursement
        pool.status = PoolStatus.ONGOING;
        
        totalVolume += pool.collectedAmount;
        
        emit PoolFunded(poolId, pool.collectedAmount, block.timestamp);
    }

    /**
     * @notice Permet à l'emprunteur d'effectuer un remboursement
     */
    function repay(uint256 poolId, uint256 amount) external nonReentrant onlyBorrower(poolId) onlyOngoing(poolId) {
        PoolData storage pool = pools[poolId];
        
        require(amount > 0, "Repayment amount must be positive");
        require(pool.amountRepaid + amount <= pool.repaymentAmount, "Overpayment");
        
        // Transfert des fonds de remboursement
        stablecoin.safeTransferFrom(msg.sender, address(this), amount);
        
        pool.amountRepaid += amount;
        
        // Distribution des intérêts aux investisseurs
        _distributeReturns(poolId, amount);
        
        emit RepaymentMade(poolId, amount, pool.repaymentAmount - pool.amountRepaid);
        
        // Vérification si le prêt est entièrement remboursé
        if (pool.amountRepaid >= pool.repaymentAmount) {
            _completePool(poolId);
        }
    }

    /**
     * @notice Distribution des rendements aux investisseurs
     */
    function _distributeReturns(uint256 poolId, uint256 repaymentAmount) internal {
        PoolData storage pool = pools[poolId];
        Investor[] storage investors = poolInvestors[poolId];
        
        // Calcul de la part des intérêts dans ce remboursement
        uint256 principalPortion = repaymentAmount * pool.targetAmount / pool.repaymentAmount;
        uint256 interestPortion = repaymentAmount - principalPortion;
        
        if (interestPortion == 0) return;
        
        // Distribution proportionnelle aux tokens détenus
        for (uint256 i = 0; i < investors.length; i++) {
            Investor storage investor = investors[i];
            
            // Calcul de la part de l'investisseur dans les intérêts
            uint256 investorShare = interestPortion * investor.tokenAmount / pool.soldTokens;
            
            if (investorShare > 0) {
                investor.claimedReturns += investorShare;
                
                // Transfert des intérêts à l'investisseur
                stablecoin.safeTransfer(investor.investorAddress, investorShare);
            }
        }
    }

    /**
     * @notice Marque le pool comme complété
     */
    function _completePool(uint256 poolId) internal {
        PoolData storage pool = pools[poolId];
        
        pool.status = PoolStatus.COMPLETED;
        pool.completionDate = block.timestamp;
        
        // Brûlage des tokens restants
        _burn(address(this), balanceOf(address(this)));
        
        emit PoolCompleted(poolId, pool.amountRepaid - pool.targetAmount);
    }

    /**
     * @notice Déclenche un défaut de paiement
     * @dev Peut être appelé après expiration de la période de grâce
     */
    function triggerDefault(uint256 poolId) external onlyOngoing(poolId) {
        PoolData storage pool = pools[poolId];
        
        require(block.timestamp > pool.startDate + pool.duration + 30 days, "Grace period not expired");
        require(pool.amountRepaid < pool.repaymentAmount, "Loan already repaid");
        
        pool.status = PoolStatus.DEFAULTED;
        
        // Déclenchement de la procédure d'assurance si existante
        if (pool.insuranceModule != address(0)) {
            IInsuranceModule(pool.insuranceModule).fileClaim(poolId, pool.repaymentAmount - pool.amountRepaid);
        }
        
        emit DefaultTriggered(poolId, pool.repaymentAmount - pool.amountRepaid, msg.sender);
    }

    // ============ FONCTIONS DE TAUX DYNAMIQUE ============

    /**
     * @notice Met à jour le taux d'intérêt dynamique du pool
     */
    function _updateDynamicRate(uint256 poolId) internal {
        PoolData storage pool = pools[poolId];
        
        // Vérification de la fréquence de mise à jour (max 1 fois par heure)
        if (block.timestamp < pool.lastRateUpdate + 1 hours) {
            return;
        }
        
        uint256 oldRate = pool.dynamicInterestRate;
        uint256 newRate = _calculateDynamicRate(poolId);
        
        if (newRate != oldRate) {
            pool.dynamicInterestRate = newRate;
            pool.lastRateUpdate = block.timestamp;
            
            emit DynamicRateUpdated(poolId, oldRate, newRate);
        }
    }

    /**
     * @notice Calcule le taux d'intérêt dynamique
     */
    function _calculateDynamicRate(uint256 poolId) internal view returns (uint256) {
        PoolData storage pool = pools[poolId];
        
        uint256 rate = pool.baseInterestRate;
        
        // 1. Facteur d'attrait (taux de remplissage)
        uint256 fillRate = (pool.soldTokens * 10000) / pool.totalTokens; // en points de base
        
        if (fillRate > 8000) { // > 80%
            // Très populaire - réduction de taux
            rate = rate * 80 / 100; // -20%
        } else if (fillRate < 3000) { // < 30%
            // Peu populaire - augmentation de taux
            rate = rate * 130 / 100; // +30%
        }
        
        // 2. Facteur temporel
        uint256 timeElapsed = block.timestamp - pool.createdAt;
        uint256 fundingPeriod = pool.fundingDeadline - pool.createdAt;
        
        if (timeElapsed > fundingPeriod / 2) {
            // Après la moitié de la période de financement
            rate = rate * 110 / 100; // +10%
        }
        
        // 3. Facteur offre spéciale
        if (pool.hasSpecialOffer && block.timestamp <= pool.specialOfferEndTime) {
            rate = rate + pool.specialOfferBonus;
        }
        
        // 4. Ajustement par le RiskEngine
        rate = riskEngine.adjustRateForMarketConditions(poolId, rate);
        
        // 5. Limites de sécurité
        uint256 minRate = pool.baseInterestRate * 50 / 100; // -50% minimum
        uint256 maxRate = pool.baseInterestRate * 200 / 100; // +100% maximum
        
        if (rate < minRate) rate = minRate;
        if (rate > maxRate) rate = maxRate;
        
        return rate;
    }

    /**
     * @notice Récupère le taux dynamique actuel (vue)
     */
    function getDynamicRate(uint256 poolId) external view returns (uint256) {
        require(pools[poolId].status != PoolStatus.CREATION, "Pool not active");
        return _calculateDynamicRate(poolId);
    }

    // ============ FONCTIONS D'OFFRES SPÉCIALES ============

    /**
     * @notice Vérifie et applique les offres spéciales disponibles
     */
    function _checkSpecialOffers(uint256 poolId) internal {
        if (address(specialOfferManager) != address(0)) {
            (bool hasOffer, uint256 offerId, uint256 bonus, uint256 endTime) = 
                specialOfferManager.getActiveOfferForPool(poolId);
            
            if (hasOffer) {
                PoolData storage pool = pools[poolId];
                pool.hasSpecialOffer = true;
                pool.specialOfferId = offerId;
                pool.specialOfferBonus = bonus;
                pool.specialOfferEndTime = endTime;
                
                // Mise à jour immédiate du taux
                _updateDynamicRate(poolId);
            }
        }
    }

    /**
     * @notice Applique une offre spéciale manuellement
     */
    function applySpecialOffer(uint256 poolId, uint256 offerId) external onlyActive(poolId) {
        require(address(specialOfferManager) != address(0), "Special offer manager not set");
        require(msg.sender == address(specialOfferManager) || msg.sender == owner(), "Not authorized");
        
        PoolData storage pool = pools[poolId];
        
        pool.hasSpecialOffer = true;
        pool.specialOfferId = offerId;
        (pool.specialOfferBonus, pool.specialOfferEndTime) = specialOfferManager.getOfferDetails(offerId);
        
        _updateDynamicRate(poolId);
    }

    // ============ FONCTIONS D'ASSURANCE ============

    /**
     * @notice Souscrit une assurance pour le pool
     */
    function subscribeInsurance(
        uint256 poolId,
        address insuranceModule,
        uint256 coverageAmount,
        uint256 insurancePoolId
    ) external onlyBorrower(poolId) onlyActive(poolId) {
        require(insuranceModule != address(0), "Invalid insurance module");
        require(coverageAmount <= pools[poolId].targetAmount, "Coverage exceeds loan amount");
        
        PoolData storage pool = pools[poolId];
        pool.insuranceModule = insuranceModule;
        pool.insuranceCoverage = coverageAmount;
        pool.insurancePoolId = insurancePoolId;
        
        // Appel au module d'assurance pour souscrire
        IInsuranceModule(insuranceModule).subscribeCoverage(
            poolId,
            coverageAmount,
            insurancePoolId
        );
    }

    // ============ FONCTIONS ADMINISTRATIVES ============

    /**
     * @notice Configure les modules externes
     */
    function setExternalModules(
        address _riskEngine,
        address _criteriaFilter,
        address _specialOfferManager
    ) external onlyOwner {
        if (_riskEngine != address(0)) {
            riskEngine = IRiskEngine(_riskEngine);
        }
        if (_criteriaFilter != address(0)) {
            criteriaFilter = ICriteriaFilter(_criteriaFilter);
        }
        if (_specialOfferManager != address(0)) {
            specialOfferManager = ISpecialOfferManager(_specialOfferManager);
        }
    }

    /**
     * @notice Active/désactive le mode pause d'urgence
     */
    function setEmergencyPause(bool paused) external onlyOwner {
        emergencyPause = paused;
    }

    /**
     * @notice Autorise un nouveau créateur de pools
     */
    function authorizeCreator(address creator, bool authorized) external onlyOwner {
        authorizedCreators[creator] = authorized;
    }

    /**
     * @notice Met à jour les paramètres du protocole
     */
    function updateProtocolParameters(
        uint256 _protocolFee,
        uint256 _minInvestment,
        uint256 _maxInvestment,
        address _feeCollector
    ) external onlyOwner {
        require(_protocolFee <= 200, "Protocol fee too high"); // Max 2%
        require(_minInvestment > 0, "Min investment must be positive");
        require(_minInvestment < _maxInvestment, "Min must be less than max");
        require(_feeCollector != address(0), "Invalid fee collector");
        
        protocolFee = _protocolFee;
        minInvestment = _minInvestment;
        maxInvestment = _maxInvestment;
        feeCollector = _feeCollector;
    }

    // ============ FONCTIONS DE REQUÊTE ============

    /**
     * @notice Récupère les détails complets d'un pool
     */
    function getPoolDetails(uint256 poolId) external view returns (PoolData memory) {
        return pools[poolId];
    }

    /**
     * @notice Récupère la liste des investisseurs d'un pool
     */
    function getPoolInvestors(uint256 poolId) external view returns (Investor[] memory) {
        return poolInvestors[poolId];
    }

    /**
     * @notice Récupère les pools correspondant aux critères
     */
    function getFilteredPools(
        string[] memory regions,
        bool ecologicalOnly,
        string[] memory domains,
        uint256 minRate,
        uint256 maxRisk
    ) external view returns (uint256[] memory) {
        require(address(criteriaFilter) != address(0), "Criteria filter not set");
        
        return criteriaFilter.filterPools(
            regions,
            ecologicalOnly,
            domains,
            minRate,
            maxRisk
        );
    }

    /**
     * @notice Calcule les rendements potentiels pour un investissement
     */
    function calculatePotentialReturns(
        uint256 poolId,
        uint256 investmentAmount
    ) external view returns (uint256 estimatedReturns, uint256 tokensToReceive) {
        PoolData storage pool = pools[poolId];
        require(pool.status == PoolStatus.ACTIVE, "Pool not active");
        
        tokensToReceive = (investmentAmount * 10**18) / pool.tokenPrice;
        uint256 poolShare = (tokensToReceive * 10000) / pool.totalTokens;
        
        // Estimation basée sur le taux dynamique actuel
        uint256 totalInterest = pool.targetAmount * pool.dynamicInterestRate / 10000;
        estimatedReturns = totalInterest * poolShare / 10000;
        
        return (estimatedReturns, tokensToReceive);
    }

    // ============ FONCTIONS DE SECOURS ============

    /**
     * @notice Permet aux investisseurs de récupérer leurs fonds si le pool est annulé
     */
    function withdrawIfCancelled(uint256 poolId) external nonReentrant {
        PoolData storage pool = pools[poolId];
        require(pool.status == PoolStatus.CANCELLED, "Pool not cancelled");
        
        uint256 index = investorIndex[poolId][msg.sender];
        require(index < poolInvestors[poolId].length, "Not an investor");
        
        Investor storage investor = poolInvestors[poolId][index];
        require(investor.investmentAmount > 0, "Already withdrawn");
        
        // Transfert du capital investi
        uint256 refundAmount = investor.investmentAmount;
        investor.investmentAmount = 0;
        
        // Brûlage des tokens
        _burn(msg.sender, investor.tokenAmount);
        
        stablecoin.safeTransfer(msg.sender, refundAmount);
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\core\RiskEngine.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * @title RiskEngine - Moteur de calcul des risques et taux dynamiques
 * @notice Calcule les scores de risque et ajuste les taux en temps réel
 */
contract RiskEngine is Ownable {
    
    struct RiskParameters {
        uint256 baseRateMultiplier;      // Multiplicateur de taux de base
        uint256 ecologicalBonus;          // Bonus pour projets écologiques
        uint256 regionRiskModifier;       // Modificateur par région
        uint256 sectorRiskModifier;       // Modificateur par secteur
        uint256 amountRiskModifier;       // Modificateur par montant
        uint256 durationRiskModifier;     // Modificateur par durée
    }
    
    struct MarketConditions {
        uint256 overallDemand;           // Demande globale (0-100)
        uint256 sectorDemand;            // Demande par secteur (0-100)
        uint256 defaultRate;             // Taux de défaut historique
        uint256 lastUpdate;
    }
    
    // Données de risque par emprunteur
    struct BorrowerProfile {
        uint256 creditScore;             // Score de crédit (1-1000)
        uint256 totalBorrowed;           // Montant total emprunté
        uint256 activeLoans;             // Prêts actifs
        uint256 defaultCount;            // Nombre de défauts
        uint256 reputationScore;         // Score de réputation (1-100)
    }
    
    // Mappings
    mapping(address => BorrowerProfile) public borrowerProfiles;
    mapping(string => uint256) public regionRiskScores;      // Ex: "Europe" = 300
    mapping(string => uint256) public sectorRiskScores;      // Ex: "Renewable" = 250
    mapping(string => MarketConditions) public sectorConditions;
    
    // Oracles Chainlink
    AggregatorV3Interface internal creditScoreOracle;
    AggregatorV3Interface internal marketDataOracle;
    
    // Paramètres configurables
    RiskParameters public riskParams;
    uint256 public constant BASIS_POINTS = 10000;
    uint256 public minBaseRate = 300;    // 3% minimum
    uint256 public maxBaseRate = 1500;   // 15% maximum
    
    // Événements
    event RiskScoreCalculated(address indexed borrower, uint256 score);
    event BaseRateCalculated(uint256 poolId, uint256 rate);
    event MarketConditionsUpdated(uint256 timestamp);
    
	constructor(address _creditOracle, address _marketOracle) Ownable(msg.sender) {
		creditScoreOracle = AggregatorV3Interface(_creditOracle);
		marketDataOracle = AggregatorV3Interface(_marketOracle);
    
		// Initialisation des paramètres par défaut
		riskParams = RiskParameters({
			baseRateMultiplier: 10000,   // 1.0x
			ecologicalBonus: 200,        // -2% pour projets écologiques
			regionRiskModifier: 5000,    // 50% de poids
			sectorRiskModifier: 3000,    // 30% de poids
			amountRiskModifier: 1000,    // 10% de poids
			durationRiskModifier: 1000   // 10% de poids
		});
    
		// Initialisation des scores de région
		regionRiskScores["Europe"] = 300;
		regionRiskScores["North America"] = 350;
		regionRiskScores["Asia"] = 450;
		regionRiskScores["Africa"] = 600;
		regionRiskScores["South America"] = 550;
    
		// Initialisation des scores de secteur
		sectorRiskScores["Renewable Energy"] = 250;
		sectorRiskScores["Technology"] = 350;
		sectorRiskScores["Agriculture"] = 400;
		sectorRiskScores["Real Estate"] = 450;
		sectorRiskScores["Manufacturing"] = 500;
	}
    
    /**
     * @notice Calcule le taux de base pour un prêt
     */
    function calculateBaseRate(
        address borrower,
        uint256 amount,
        uint256 duration,
        bool isEcological,
        string calldata activityDomain
    ) external returns (uint256) {
        // 1. Score de crédit de l'emprunteur
        uint256 creditScore = _getCreditScore(borrower);
        
        // 2. Score de risque du projet
        uint256 projectRisk = _calculateProjectRisk(
            amount,
            duration,
            isEcological,
            activityDomain
        );
        
        // 3. Taux de base = Base + Risque projet - Score crédit
        uint256 baseRate = 500; // 5% de base
        
        // Ajustement par risque projet
        baseRate = baseRate * projectRisk / BASIS_POINTS;
        
        // Ajustement par score de crédit
        if (creditScore > 700) {
            baseRate = baseRate * 80 / 100; // -20% pour bon crédit
        } else if (creditScore < 400) {
            baseRate = baseRate * 130 / 100; // +30% pour mauvais crédit
        }
        
        // Bonus écologique
        if (isEcological) {
            baseRate = baseRate - riskParams.ecologicalBonus;
            if (baseRate < minBaseRate) baseRate = minBaseRate;
        }
        
        // Ajustement aux conditions de marché
        baseRate = _adjustForMarketConditions(baseRate, activityDomain);
        
        // Limites
        if (baseRate < minBaseRate) baseRate = minBaseRate;
        if (baseRate > maxBaseRate) baseRate = maxBaseRate;
        
        return baseRate;
    }
    
    /**
     * @notice Calcule le score de risque (1-10)
     */
    function calculateRiskScore(
        address borrower,
        uint256 amount,
        uint256 duration,
        string calldata region,
        bool isEcological,
        string calldata activityDomain
    ) external returns (uint256) {
        uint256 score = 5; // Score moyen de départ
        
        // Facteur région (30%)
        uint256 regionScore = regionRiskScores[region];
        if (regionScore == 0) regionScore = 500; // Défaut
        score = score * 70 / 100 + (regionScore / 100) * 30 / 100;
        
        // Facteur secteur (25%)
        uint256 sectorScore = sectorRiskScores[activityDomain];
        if (sectorScore == 0) sectorScore = 500;
        score = score * 75 / 100 + (sectorScore / 100) * 25 / 100;
        
        // Facteur montant (20%)
        if (amount > 500000 * 10**18) {
            score = score + 2; // Gros montant = risque +2
        } else if (amount < 10000 * 10**18) {
            score = score - 1; // Petit montant = risque -1
        }
        
        // Facteur durée (15%)
        if (duration > 180 days) {
            score = score + 1; // Longue durée = risque +1
        }
        
        // Bonus écologique (-10%)
        if (isEcological) {
            score = score - 1;
        }
        
        // Score de crédit emprunteur (10%)
        uint256 creditScore = _getCreditScore(borrower);
        if (creditScore < 400) {
            score = score + 2;
        } else if (creditScore > 700) {
            score = score - 1;
        }
        
        // Limites 1-10
        if (score < 1) score = 1;
        if (score > 10) score = 10;
        
        emit RiskScoreCalculated(borrower, score);
        return score;
    }
    
    /**
     * @notice Valide un pool de prêt
     */
    function validatePool(uint256 poolId) external view returns (bool) {
        // Pour l'instant, validation simple
        // À étendre avec des règles métier complexes
        return true;
    }
    
    /**
     * @notice Ajuste le taux selon les conditions de marché
     */
    function adjustRateForMarketConditions(
        uint256 poolId,
        uint256 currentRate
    ) external view returns (uint256) {
        // Récupération des conditions de marché
        MarketConditions memory conditions = sectorConditions["global"];
        
        // Ajustement selon la demande
        if (conditions.overallDemand > 80) {
            // Forte demande = réduction de taux
            return currentRate * 90 / 100; // -10%
        } else if (conditions.overallDemand < 30) {
            // Faible demande = augmentation de taux
            return currentRate * 115 / 100; // +15%
        }
        
        return currentRate;
    }
    
    // ============ FONCTIONS INTERNES ============
    
    function _calculateProjectRisk(
        uint256 amount,
        uint256 duration,
        bool isEcological,
        string memory activityDomain
    ) internal view returns (uint256) {
        uint256 risk = BASIS_POINTS; // 1.0x de base
        
        // Risque montant (échelle logarithmique)
        if (amount > 1000000 * 10**18) risk = risk * 120 / 100;
        else if (amount > 100000 * 10**18) risk = risk * 110 / 100;
        
        // Risque durée
        if (duration > 365 days) risk = risk * 115 / 100;
        else if (duration > 180 days) risk = risk * 105 / 100;
        
        // Risque secteur
        uint256 sectorRisk = sectorRiskScores[activityDomain];
        if (sectorRisk > 0) {
            risk = risk * sectorRisk / BASIS_POINTS;
        }
        
        // Réduction risque écologique
        if (isEcological) {
            risk = risk * 90 / 100; // -10%
        }
        
        return risk;
    }
    
    function _getCreditScore(address borrower) internal returns (uint256) {
        // D'abord, vérifier si on a un profil local
        if (borrowerProfiles[borrower].creditScore > 0) {
            return borrowerProfiles[borrower].creditScore;
        }
        
        // Sinon, requête à l'oracle Chainlink
        try creditScoreOracle.latestRoundData() returns (
            uint80 /* roundId */,
            int256 score,
            uint256 /* startedAt */,
            uint256 /* updatedAt */,
            uint80 /* answeredInRound */
        ) {
            uint256 oracleScore = uint256(score);
            if (oracleScore > 0 && oracleScore <= 1000) {
                borrowerProfiles[borrower].creditScore = oracleScore;
                return oracleScore;
            }
        } catch {
            // Fallback: score par défaut
        }
        
        return 500; // Score moyen par défaut
    }
    
    function _adjustForMarketConditions(uint256 rate, string memory sector) internal view returns (uint256) {
        MarketConditions memory conditions = sectorConditions[sector];
        if (conditions.overallDemand == 0) {
            conditions = sectorConditions["global"];
        }
        
        if (conditions.overallDemand > 80) {
            return rate * 90 / 100; // -10% si forte demande
        } else if (conditions.overallDemand < 30) {
            return rate * 115 / 100; // +15% si faible demande
        }
        
        return rate;
    }
    
    // ============ FONCTIONS ADMIN ============
    
    function updateRiskParameters(
        uint256 baseRateMultiplier,
        uint256 ecologicalBonus,
        uint256 regionRiskModifier,
        uint256 sectorRiskModifier,
        uint256 amountRiskModifier,
        uint256 durationRiskModifier
    ) external onlyOwner {
        riskParams = RiskParameters({
            baseRateMultiplier: baseRateMultiplier,
            ecologicalBonus: ecologicalBonus,
            regionRiskModifier: regionRiskModifier,
            sectorRiskModifier: sectorRiskModifier,
            amountRiskModifier: amountRiskModifier,
            durationRiskModifier: durationRiskModifier
        });
    }
    
    function updateRegionRisk(string calldata region, uint256 score) external onlyOwner {
        require(score > 0 && score <= 1000, "Invalid score");
        regionRiskScores[region] = score;
    }
    
    function updateSectorRisk(string calldata sector, uint256 score) external onlyOwner {
        require(score > 0 && score <= 1000, "Invalid score");
        sectorRiskScores[sector] = score;
    }
    
    function updateMarketConditions(
        string calldata sector,
        uint256 overallDemand,
        uint256 sectorDemand,
        uint256 defaultRate
    ) external onlyOwner {
        sectorConditions[sector] = MarketConditions({
            overallDemand: overallDemand,
            sectorDemand: sectorDemand,
            defaultRate: defaultRate,
            lastUpdate: block.timestamp
        });
        
        emit MarketConditionsUpdated(block.timestamp);
    }
    
    function setCreditOracle(address oracle) external onlyOwner {
        creditScoreOracle = AggregatorV3Interface(oracle);
    }
    
    function setMarketOracle(address oracle) external onlyOwner {
        marketDataOracle = AggregatorV3Interface(oracle);
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\governance\GovernanceDAO.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/governance/Governor.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
import "./ReputationToken.sol";

contract GovernanceDAO is 
    Governor, 
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl,
    AccessControl
{
    // Structure de proposition enrichie
    struct EnhancedProposal {
        uint256 proposalId;
        address proposer;
        string title;
        string description;
        ProposalCategory category;
        uint256 createdTime;
        uint256 votingEndTime;
        ProposalStatus status;
        bytes[] calldatas;
        address[] targets;
        uint256 forVotes;
        uint256 againstVotes;
        uint256 abstainVotes;
        uint256 executionTime;
        string ipfsMetadata;
    }
    
    // Catégories de propositions
    enum ProposalCategory {
        PARAMETER_CHANGE,     // Changement de paramètres
        TREASURY_MANAGEMENT,  // Gestion de trésorerie
        CONTRACT_UPGRADE,     // Mise à jour de contrat
        EMERGENCY_ACTION,     // Action d'urgence
        COMMUNITY_GRANT,      // Subvention communautaire
        RISK_MANAGEMENT,      // Gestion des risques
        INSURANCE_POLICY,     // Politique d'assurance
        FEE_STRUCTURE         // Structure de frais
    }
    
    // Statuts étendus
    enum ProposalStatus {
        PENDING,
        ACTIVE,
        CANCELED,
        DEFEATED,
        SUCCEEDED,
        QUEUED,
        EXECUTED,
        EXPIRED
    }
    
    // Structures de délégation
    struct Delegation {
        address delegatee;
        uint256 amount;
        uint256 timestamp;
    }
    
    // Variables d'état
    mapping(uint256 => EnhancedProposal) public enhancedProposals;
    mapping(address => Delegation[]) public delegationHistory;
    mapping(address => uint256) public reputationScores;
    
    uint256 public proposalCount;
    uint256 public minimumReputation = 100;
    uint256 public proposalDeposit = 100 * 1e18; // 100 tokens
    
    // Token de réputation
    ReputationToken public reputationToken;
    
    // Événements
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed proposer,
        string title,
        ProposalCategory category,
        uint256 timestamp
    );
    
    event VoteCast(
        uint256 indexed proposalId,
        address indexed voter,
        uint256 votes,
        uint256 reputationWeight,
        string support,
        uint256 timestamp
    );
    
    event ProposalExecuted(
        uint256 indexed proposalId,
        address indexed executor,
        uint256 timestamp
    );
    
    event ReputationAwarded(
        address indexed user,
        uint256 amount,
        string reason,
        uint256 timestamp
    );
    
    constructor(
        ERC20Votes _token,
        TimelockController _timelock,
        address _reputationToken
    )
        Governor("StructuredLendingGovernor")
        GovernorSettings(1, 50400, 0) // 1 block voting delay, 1 week voting period, 0 proposal threshold
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(4) // 4% quorum
        GovernorTimelockControl(_timelock)
    {
        reputationToken = ReputationToken(_reputationToken);
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }
    
    // Création de proposition améliorée
    function proposeEnhanced(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description,
        string memory title,
        ProposalCategory category,
        string memory ipfsMetadata	
    ) public returns (uint256) {
        require(
            reputationToken.balanceOf(msg.sender) >= minimumReputation,
            "Insufficient reputation"
        );
        
        // Dépôt de garantie
        IERC20 governanceToken = IERC20(address(token()));
        require(
            governanceToken.transferFrom(msg.sender, address(this), proposalDeposit),
            "Deposit failed"
        );
        
        // Création de la proposition
        uint256 proposalId = propose(targets, values, calldatas, description);
        
        // Enregistrement des métadonnées enrichies
        enhancedProposals[proposalId] = EnhancedProposal({
            proposalId: proposalId,
            proposer: msg.sender,
            title: title,
            description: description,
            category: category,
            createdTime: block.timestamp,
            votingEndTime: block.timestamp + votingPeriod(),
            status: ProposalStatus.ACTIVE,
            calldatas: calldatas,
            targets: targets,
            forVotes: 0,
            againstVotes: 0,
            abstainVotes: 0,
            executionTime: 0,
            ipfsMetadata: ipfsMetadata
        });
        
        proposalCount++;
        
        // Attribution de réputation pour la création de proposition
        reputationToken.mint(msg.sender, 10); // 10 points de réputation
        
        emit ProposalCreated(proposalId, msg.sender, title, category, block.timestamp);
        emit ReputationAwarded(msg.sender, 10, "Proposal creation", block.timestamp);
        
        return proposalId;
    }
    
    // Vote avec poids de réputation
    function castVoteWithReasonAndReputation(
        uint256 proposalId,
        uint8 support,
        string memory reason
    ) public returns (uint256) {
        // Vérifier que la proposition est active
        require(state(proposalId) == ProposalState.Active, "Voting not active");
        
        // Calcul du poids du vote (tokens + réputation)
        uint256 tokenWeight = getVotes(msg.sender, proposalId);
        uint256 reputationWeight = reputationToken.balanceOf(msg.sender);
        uint256 totalWeight = tokenWeight + (reputationWeight / 10); // Réputation compte pour 1/10
        
        // Enregistrement du vote
        _castVote(proposalId, msg.sender, support, reason);
        
        // Mise à jour des compteurs dans enhancedProposals
        EnhancedProposal storage proposal = enhancedProposals[proposalId];
        if (support == 0) {
            proposal.againstVotes += totalWeight;
        } else if (support == 1) {
            proposal.forVotes += totalWeight;
        } else if (support == 2) {
            proposal.abstainVotes += totalWeight;
        }
        
        // Attribution de réputation pour la participation
        reputationToken.mint(msg.sender, 1);
        
        emit VoteCast(
            proposalId,
            msg.sender,
            totalWeight,
            reputationWeight,
            support == 1 ? "FOR" : support == 0 ? "AGAINST" : "ABSTAIN",
            block.timestamp
        );
        
        emit ReputationAwarded(msg.sender, 1, "Voting participation", block.timestamp);
        
        return totalWeight;
    }
    
    // Exécution de proposition
    function executeEnhanced(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) public payable returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);
        
        // Vérifier que la proposition a réussie
        require(state(proposalId) == ProposalState.Succeeded, "Proposal not succeeded");
        
        // Exécution
        _execute(proposalId, targets, values, calldatas, descriptionHash);
        
        // Mise à jour du statut
        EnhancedProposal storage proposal = enhancedProposals[proposalId];
        proposal.status = ProposalStatus.EXECUTED;
        proposal.executionTime = block.timestamp;
        
        // Remboursement du dépôt au proposant
        IERC20 governanceToken = IERC20(address(token()));
        governanceToken.transfer(proposal.proposer, proposalDeposit);
        
        // Attribution de réputation supplémentaire pour l'exécution réussie
        reputationToken.mint(proposal.proposer, 50);
        
        emit ProposalExecuted(proposalId, msg.sender, block.timestamp);
        emit ReputationAwarded(proposal.proposer, 50, "Successful proposal execution", block.timestamp);
        
        return proposalId;
    }
    
    // Délégation de votes avec historique
    function delegateWithRecord(address delegatee) public {
        uint256 currentVotes = getVotes(msg.sender, block.number);
        
        // Délégation standard
        reputationToken.delegate(delegatee);
        
        // Enregistrement historique
        delegationHistory[msg.sender].push(Delegation({
            delegatee: delegatee,
            amount: currentVotes,
            timestamp: block.timestamp
        }));
        
        // Attribution de réputation pour la délégation
        reputationToken.mint(msg.sender, 2);
        emit ReputationAwarded(msg.sender, 2, "Vote delegation", block.timestamp);
    }
    
    // Création de proposition rapide pour les paramètres
    function proposeParameterChange(
        address targetContract,
        string memory functionSignature,
        bytes memory newValue,
        string memory title,
        string memory description
    ) external returns (uint256) {
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodePacked(
            bytes4(keccak256(bytes(functionSignature))),
            newValue
        );
        
        address[] memory targets = new address[](1);
        targets[0] = targetContract;
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0;
        
        return proposeEnhanced(
            targets,
            values,
            calldatas,
            description,
            title,
            ProposalCategory.PARAMETER_CHANGE,
            ""
        );
    }
    
    // Proposition de subvention communautaire
    function proposeCommunityGrant(
        address recipient,
        uint256 amount,
        string memory title,
        string memory description,
        string memory justification
    ) external returns (uint256) {
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSignature(
            "transfer(address,uint256)",
            recipient,
            amount
        );
        
        address[] memory targets = new address[](1);
        targets[0] = address(token()); // Trésorerie en tokens de gouvernance
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0;
        
        string memory ipfsMetadata = string(abi.encodePacked(
            "{\"recipient\":\"",
            _addressToString(recipient),
            "\",\"amount\":",
            _toString(amount),
            ",\"justification\":\"",
            justification,
            "\"}"
        ));
        
        return proposeEnhanced(
            targets,
            values,
            calldatas,
            description,
            title,
            ProposalCategory.COMMUNITY_GRANT,
            ipfsMetadata
        );
    }
    
    // Proposition d'action d'urgence
    function proposeEmergencyAction(
        address targetContract,
        bytes memory emergencyCalldata,
        string memory title,
        string memory emergencyDescription
    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) {
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = emergencyCalldata;
        
        address[] memory targets = new address[](1);
        targets[0] = targetContract;
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0;
        
        return proposeEnhanced(
            targets,
            values,
            emergencyDescription,
            title,
            ProposalCategory.EMERGENCY_ACTION,
            "{\"emergency\":true}"
        );
    }
    
    // Getters pour les propositions enrichies
    function getEnhancedProposal(uint256 proposalId) external view returns (
        address proposer,
        string memory title,
        ProposalCategory category,
        ProposalStatus status,
        uint256 forVotes,
        uint256 againstVotes,
        uint256 abstainVotes,
        uint256 createdTime,
        uint256 votingEndTime
    ) {
        EnhancedProposal memory proposal = enhancedProposals[proposalId];
        return (
            proposal.proposer,
            proposal.title,
            proposal.category,
            proposal.status,
            proposal.forVotes,
            proposal.againstVotes,
            proposal.abstainVotes,
            proposal.createdTime,
            proposal.votingEndTime
        );
    }
    
    function getProposalsByCategory(ProposalCategory category) external view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](proposalCount);
        uint256 count = 0;
        
        for (uint256 i = 0; i < proposalCount; i++) {
            if (enhancedProposals[i].category == category) {
                result[count] = i;
                count++;
            }
        }
        
        // Redimensionner le tableau
        uint256[] memory finalResult = new uint256[](count);
        for (uint256 j = 0; j < count; j++) {
            finalResult[j] = result[j];
        }
        
        return finalResult;
    }
    
    function getVotingPowerWithReputation(address account) external view returns (uint256) {
        uint256 tokenPower = getVotes(account, block.number);
        uint256 reputationPower = reputationToken.balanceOf(account) / 10;
        return tokenPower + reputationPower;
    }
    
    // Configuration des paramètres
    function setMinimumReputation(uint256 newMinimum) external onlyRole(DEFAULT_ADMIN_ROLE) {
        minimumReputation = newMinimum;
    }
    
    function setProposalDeposit(uint256 newDeposit) external onlyRole(DEFAULT_ADMIN_ROLE) {
        proposalDeposit = newDeposit;
    }
    
    // Fonctions utilitaires
    function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) return "0";
        
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return string(buffer);
    }
    
    function _addressToString(address addr) internal pure returns (string memory) {
        bytes32 value = bytes32(uint256(uint160(addr)));
        bytes memory alphabet = "0123456789abcdef";
        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
        
        for (uint256 i = 0; i < 20; i++) {
            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        
        return string(str);
    }
    
    // Overrides nécessaires
    function votingDelay() public view override(GovernorSettings) returns (uint256) {
        return super.votingDelay();
    }
    
    function votingPeriod() public view override(GovernorSettings) returns (uint256) {
        return super.votingPeriod();
    }
    
    function quorum(uint256 blockNumber) 
        public 
        view 
        override(GovernorVotesQuorumFraction) 
        returns (uint256) 
    {
        return super.quorum(blockNumber);
    }
    
    function state(uint256 proposalId) 
        public 
        view 
        override(GovernorTimelockControl) 
        returns (ProposalState) 
    {
        return super.state(proposalId);
    }
    
    function proposalThreshold() 
        public 
        view 
        override(GovernorSettings) 
        returns (uint256) 
    {
        return super.proposalThreshold();
    }
    
    function _execute(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(GovernorTimelockControl) {
        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);
    }
    
    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(GovernorTimelockControl) returns (uint256) {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }
    
    function _executor() internal view override(GovernorTimelockControl) returns (address) {
        return super._executor();
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
	function _executeOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash) 
		internal override(GovernorTimelockControl) {
		super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);
	}

	function _queueOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash) 
		internal override(GovernorTimelockControl) returns (uint48) {
		return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);
	}

	function proposalNeedsQueuing(uint256 proposalId) public view override returns (bool) {
		return super.proposalNeedsQueuing(proposalId);
	}
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\governance\ReputationToken.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract ReputationToken is ERC20Votes, AccessControl {
    // Structure de réputation
    struct ReputationScore {
        uint256 totalScore;
        uint256 lastUpdate;
        uint256[] categoryScores;
        uint256 decayRate;
    }
    
    // Catégories de réputation
    enum ReputationCategory {
        LOAN_REPAYMENT,
        GOVERNANCE_PARTICIPATION,
        INSURANCE_PERFORMANCE,
        COMMUNITY_CONTRIBUTION,
        SYSTEM_SECURITY
    }
    
    // Événements de réputation
    struct ReputationEvent {
        address user;
        ReputationCategory category;
        uint256 points;
        string reason;
        uint256 timestamp;
    }
    
    // Variables d'état
    mapping(address => ReputationScore) public reputationScores;
    mapping(address => ReputationEvent[]) public reputationHistory;
    mapping(address => uint256) public lastActivity;
    
    uint256 public baseDecayRate = 100; // 1% par mois
    uint256 public maxReputationPerUser = 10000 * 1e18;
    uint256 public minReputationForBenefits = 100 * 1e18;
    
    // Contrats autorisés à accorder de la réputation
    mapping(address => bool) public reputationGranters;
    
    // Événements
    event ReputationMinted(
        address indexed user,
        ReputationCategory category,
        uint256 amount,
        string reason,
        uint256 timestamp
    );
    
    event ReputationBurned(
        address indexed user,
        uint256 amount,
        string reason,
        uint256 timestamp
    );
    
    event ReputationTransferred(
        address indexed from,
        address indexed to,
        uint256 amount,
        uint256 timestamp
    );
    
    // Rôles
    bytes32 public constant REPUTATION_MINTER = keccak256("REPUTATION_MINTER");
    bytes32 public constant REPUTATION_BURNER = keccak256("REPUTATION_BURNER");
    
    constructor()
		ERC20("StructuredLendingReputation", "SLR")
		ERC20Permit("StructuredLendingReputation")
		ERC20Votes()
	{
		_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(REPUTATION_MINTER, msg.sender);
        _grantRole(REPUTATION_BURNER, msg.sender);
    }
    
    // Attribution de réputation
    function mintReputation(
        address to,
        uint256 amount,
        ReputationCategory category,
        string memory reason
    ) external onlyRole(REPUTATION_MINTER) {
        require(to != address(0), "Invalid address");
        require(amount > 0, "Amount must be > 0");
        
        // Vérifier la limite par utilisateur
        uint256 newTotal = balanceOf(to) + amount;
        require(newTotal <= maxReputationPerUser, "Exceeds max reputation");
        
        // Mint des tokens
        _mint(to, amount);
        
        // Mise à jour du score de réputation
        _updateReputationScore(to, category, amount);
        
        // Enregistrement dans l'historique
        reputationHistory[to].push(ReputationEvent({
            user: to,
            category: category,
            points: amount,
            reason: reason,
            timestamp: block.timestamp
        }));
        
        // Mise à jour de la dernière activité
        lastActivity[to] = block.timestamp;
        
        emit ReputationMinted(to, category, amount, reason, block.timestamp);
    }
    
    // Retrait de réputation (pour pénalités)
    function burnReputation(
        address from,
        uint256 amount,
        string memory reason
    ) external onlyRole(REPUTATION_BURNER) {
        require(balanceOf(from) >= amount, "Insufficient reputation");
        
        // Burn des tokens
        _burn(from, amount);
        
        // Mise à jour du score (diminution générale)
        ReputationScore storage score = reputationScores[from];
        score.totalScore = score.totalScore > amount ? score.totalScore - amount : 0;
        score.lastUpdate = block.timestamp;
        
        emit ReputationBurned(from, amount, reason, block.timestamp);
    }
    
    // Transfert de réputation avec restrictions
    function transferReputation(
        address to,
        uint256 amount
    ) external returns (bool) {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be > 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient reputation");
        
        // Vérifier que le destinataire ne dépasse pas la limite
        uint256 recipientBalance = balanceOf(to);
        require(recipientBalance + amount <= maxReputationPerUser, "Recipient exceeds max");
        
        // Vérifier que l'expéditeur garde un minimum
        uint256 senderNewBalance = balanceOf(msg.sender) - amount;
        require(senderNewBalance >= minReputationForBenefits, "Below minimum for benefits");
        
        // Transfert standard
        bool success = transfer(to, amount);
        
        if (success) {
            // Mise à jour des scores
            _updateTransferReputation(msg.sender, to, amount);
            
            emit ReputationTransferred(msg.sender, to, amount, block.timestamp);
        }
        
        return success;
    }
    
    // Application de la dégradation (décay) de la réputation
    function applyDecay(address user) external {
        ReputationScore storage score = reputationScores[user];
        
        uint256 timeSinceUpdate = block.timestamp - score.lastUpdate;
        if (timeSinceUpdate < 30 days) {
            return; // Pas encore de dégradation
        }
        
        // Calcul de la dégradation
        uint256 monthsPassed = timeSinceUpdate / 30 days;
        uint256 decayAmount = (score.totalScore * baseDecayRate * monthsPassed) / 10000;
        
        if (decayAmount > 0) {
            // Ajuster le score
            score.totalScore = score.totalScore > decayAmount ? 
                score.totalScore - decayAmount : 0;
            
            // Ajuster le solde du token
            uint256 tokenBalance = balanceOf(user);
            if (tokenBalance > decayAmount) {
                _burn(user, decayAmount);
            } else if (tokenBalance > 0) {
                _burn(user, tokenBalance);
            }
            
            // Enregistrement de l'événement
            reputationHistory[user].push(ReputationEvent({
                user: user,
                category: ReputationCategory.SYSTEM_SECURITY,
                points: decayAmount,
                reason: "Monthly reputation decay",
                timestamp: block.timestamp
            }));
        }
        
        score.lastUpdate = block.timestamp;
    }
    
    // Calcul du score de réputation pondéré
    function calculateWeightedScore(address user) public view returns (uint256) {
        ReputationScore memory score = reputationScores[user];
        
        if (score.totalScore == 0) {
            return 0;
        }
        
        // Appliquer la dégradation dans le calcul
        uint256 timeSinceUpdate = block.timestamp - score.lastUpdate;
        uint256 monthsPassed = timeSinceUpdate / 30 days;
        
        if (monthsPassed > 0) {
            uint256 decayAmount = (score.totalScore * baseDecayRate * monthsPassed) / 10000;
            if (decayAmount < score.totalScore) {
                return score.totalScore - decayAmount;
            }
        }
        
        return score.totalScore;
    }
    
    // Vérification des avantages basés sur la réputation
    function hasGovernanceVotingRights(address user) public view returns (bool) {
        return calculateWeightedScore(user) >= minReputationForBenefits;
    }
    
    function hasPremiumFeaturesAccess(address user) public view returns (bool) {
        return calculateWeightedScore(user) >= minReputationForBenefits * 2;
    }
    
    function hasEarlyAccessFeatures(address user) public view returns (bool) {
        return calculateWeightedScore(user) >= minReputationForBenefits * 5;
    }
    
    // Récupération de l'historique de réputation
    function getReputationHistory(address user, uint256 limit) 
        public 
        view 
        returns (ReputationEvent[] memory) 
    {
        ReputationEvent[] storage history = reputationHistory[user];
        
        if (limit == 0 || limit > history.length) {
            limit = history.length;
        }
        
        ReputationEvent[] memory result = new ReputationEvent[](limit);
        
        for (uint256 i = 0; i < limit; i++) {
            result[i] = history[history.length - 1 - i]; // Inverser pour avoir les plus récents en premier
        }
        
        return result;
    }
    
    // Statistiques de réputation
    function getReputationStats(address user) public view returns (
        uint256 totalScore,
        uint256 weightedScore,
        uint256 lastUpdate,
        uint256 categoryCount,
        bool hasVotingRights,
        bool hasPremiumAccess,
        bool hasEarlyAccess
    ) {
        ReputationScore memory score = reputationScores[user];
        
        return (
            score.totalScore,
            calculateWeightedScore(user),
            score.lastUpdate,
            score.categoryScores.length,
            hasGovernanceVotingRights(user),
            hasPremiumFeaturesAccess(user),
            hasEarlyAccessFeatures(user)
        );
    }
    
    // Fonctions internes
    function _updateReputationScore(
        address user,
        ReputationCategory category,
        uint256 amount
    ) private {
        ReputationScore storage score = reputationScores[user];
        
        // Initialiser si nécessaire
        if (score.categoryScores.length == 0) {
            score.categoryScores = new uint256[](5); // 5 catégories
            score.decayRate = baseDecayRate;
        }
        
        // Mettre à jour le score total
        score.totalScore += amount;
        
        // Mettre à jour la catégorie spécifique
        if (uint256(category) < score.categoryScores.length) {
            score.categoryScores[uint256(category)] += amount;
        }
        
        score.lastUpdate = block.timestamp;
        
        // Ajuster le taux de dégradation basé sur l'activité
        if (amount > 100 * 1e18) { // Grande attribution
            score.decayRate = score.decayRate * 90 / 100; // Réduire la dégradation de 10%
        }
    }
    
    function _updateTransferReputation(
        address from,
        address to,
        uint256 amount
    ) private {
        // L'expéditeur perd proportionnellement de chaque catégorie
        ReputationScore storage fromScore = reputationScores[from];
        ReputationScore storage toScore = reputationScores[to];
        
        if (fromScore.totalScore > 0) {
            // Calculer la proportion à transférer de chaque catégorie
            uint256 transferRatio = (amount * 1e18) / fromScore.totalScore;
            
            for (uint256 i = 0; i < fromScore.categoryScores.length; i++) {
                uint256 categoryTransfer = (fromScore.categoryScores[i] * transferRatio) / 1e18;
                
                fromScore.categoryScores[i] -= categoryTransfer;
                
                // Initialiser la catégorie du destinataire si nécessaire
                if (toScore.categoryScores.length == 0) {
                    toScore.categoryScores = new uint256[](5);
                }
                toScore.categoryScores[i] += categoryTransfer;
            }
            
            fromScore.totalScore -= amount;
            toScore.totalScore += amount;
            
            fromScore.lastUpdate = block.timestamp;
            toScore.lastUpdate = block.timestamp;
        } else {
            // Si l'expéditeur n'a pas de score détaillé, simplement ajouter au destinataire
            toScore.totalScore += amount;
            toScore.lastUpdate = block.timestamp;
        }
    }
    
    // Configuration
    function setBaseDecayRate(uint256 newRate) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newRate <= 1000, "Rate too high"); // Max 10%
        baseDecayRate = newRate;
    }
    
    function setMaxReputationPerUser(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) {
        maxReputationPerUser = newMax;
    }
    
    function setMinReputationForBenefits(uint256 newMin) external onlyRole(DEFAULT_ADMIN_ROLE) {
        minReputationForBenefits = newMin;
    }
    
    // Autoriser un contrat à accorder de la réputation
    function addReputationGranter(address granter) external onlyRole(DEFAULT_ADMIN_ROLE) {
        reputationGranters[granter] = true;
        _grantRole(REPUTATION_MINTER, granter);
    }
    
    // Override des fonctions de transfert standard pour ajouter des restrictions
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(balanceOf(msg.sender) - amount >= minReputationForBenefits, 
            "Transfer would go below minimum");
        
        return super.transfer(to, amount);
    }
    
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public override returns (bool) {
        require(balanceOf(from) - amount >= minReputationForBenefits,
            "Transfer would leave sender below minimum");
        
        return super.transferFrom(from, to, amount);
    }
    
    // Getters
    function getCategoryScore(address user, ReputationCategory category) 
        external 
        view 
        returns (uint256) 
    {
        ReputationScore memory score = reputationScores[user];
        
        if (uint256(category) < score.categoryScores.length) {
            return score.categoryScores[uint256(category)];
        }
        
        return 0;
    }
    
    function getReputationLevel(address user) external view returns (string memory) {
        uint256 score = calculateWeightedScore(user);
        
        if (score >= 5000 * 1e18) return "Legendary";
        if (score >= 2000 * 1e18) return "Expert";
        if (score >= 1000 * 1e18) return "Advanced";
        if (score >= 500 * 1e18) return "Intermediate";
        if (score >= 100 * 1e18) return "Beginner";
        
        return "Newcomer";
    }
	
	function mint(address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
		_mint(to, amount);
	}
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\infrastructure\FeeDistributor.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract FeeDistributor is ReentrancyGuard, AccessControl {
    // Structure de distribution
    struct DistributionPool {
        address recipient;
        uint256 sharePercentage;
        string description;
        bool isActive;
    }
    
    // Structure de frais accumulés
    struct AccruedFees {
        address token;
        uint256 amount;
        uint256 lastDistribution;
    }
    
    // Structure de récompense de performance
    struct PerformanceReward {
        address recipient;
        uint256 rewardAmount;
        uint256 timestamp;
        string performanceMetric;
    }
    
    // Variables d'état
    DistributionPool[] public distributionPools;
    mapping(address => AccruedFees) public accruedFees;
    mapping(address => PerformanceReward[]) public performanceRewards;
    
    uint256 public totalDistributed;
    uint256 public distributionInterval = 7 days;
    uint256 public lastDistributionTime;
    
    address public feeToken;
    
    // Événements
    event FeesAccrued(
        address indexed token,
        uint256 amount,
        address indexed source,
        uint256 timestamp
    );
    
    event DistributionExecuted(
        uint256 distributionId,
        uint256 totalAmount,
        uint256 timestamp
    );
    
    event PoolAdded(
        uint256 poolId,
        address recipient,
        uint256 sharePercentage,
        string description
    );
    
    event PerformanceRewardDistributed(
        address indexed recipient,
        uint256 amount,
        string metric,
        uint256 timestamp
    );
    
    // Rôles
    bytes32 public constant FEE_COLLECTOR = keccak256("FEE_COLLECTOR");
    bytes32 public constant DISTRIBUTOR = keccak256("DISTRIBUTOR");
    
    constructor(address _feeToken) {
        feeToken = _feeToken;
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(FEE_COLLECTOR, msg.sender);
        _grantRole(DISTRIBUTOR, msg.sender);
        
        // Initialisation des pools par défaut
        _initializeDefaultPools();
        
        lastDistributionTime = block.timestamp;
    }
    
    // Initialisation des pools par défaut
    function _initializeDefaultPools() private {
        // Pool 1: Trésorerie du protocole
        distributionPools.push(DistributionPool({
            recipient: msg.sender,
            sharePercentage: 4000, // 40%
            description: "Protocol Treasury",
            isActive: true
        }));
        
        // Pool 2: Récompenses des stakers
        distributionPools.push(DistributionPool({
            recipient: address(0), // À définir
            sharePercentage: 3000, // 30%
            description: "Staker Rewards",
            isActive: true
        }));
        
        // Pool 3: Fonds de développement
        distributionPools.push(DistributionPool({
            recipient: address(0), // À définir
            sharePercentage: 1500, // 15%
            description: "Development Fund",
            isActive: true
        }));
        
        // Pool 4: Fonds d'assurance
        distributionPools.push(DistributionPool({
            recipient: address(0), // À définir
            sharePercentage: 1000, // 10%
            description: "Insurance Fund",
            isActive: true
        }));
        
        // Pool 5: Réserve d'urgence
        distributionPools.push(DistributionPool({
            recipient: address(0), // À définir
            sharePercentage: 500, // 5%
            description: "Emergency Reserve",
            isActive: true
        }));
    }
    
    // Accumulation de frais
    function accrueFees(uint256 amount, address source) external onlyRole(FEE_COLLECTOR) {
        require(amount > 0, "Amount must be > 0");
        
        // Transfert des tokens
        IERC20 token = IERC20(feeToken);
        require(
            token.transferFrom(msg.sender, address(this), amount),
            "Transfer failed"
        );
        
        // Mise à jour des frais accumulés
        AccruedFees storage fees = accruedFees[feeToken];
        fees.token = feeToken;
        fees.amount += amount;
        
        emit FeesAccrued(feeToken, amount, source, block.timestamp);
    }
    
    // Distribution des frais
    function distributeFees() external nonReentrant onlyRole(DISTRIBUTOR) {
        require(
            block.timestamp >= lastDistributionTime + distributionInterval,
            "Too soon for distribution"
        );
        
        AccruedFees storage fees = accruedFees[feeToken];
        require(fees.amount > 0, "No fees to distribute");
        
        uint256 distributionId = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            fees.amount
        )));
        
        uint256 remainingAmount = fees.amount;
        
        // Distribution aux pools actifs
        for (uint256 i = 0; i < distributionPools.length; i++) {
            if (distributionPools[i].isActive && distributionPools[i].recipient != address(0)) {
                uint256 poolShare = (fees.amount * distributionPools[i].sharePercentage) / 10000;
                
                if (poolShare > 0 && poolShare <= remainingAmount) {
                    IERC20 token = IERC20(feeToken);
                    token.transfer(distributionPools[i].recipient, poolShare);
                    
                    remainingAmount -= poolShare;
                }
            }
        }
        
        // Mise à jour des totaux
        totalDistributed += fees.amount;
        fees.amount = 0;
        fees.lastDistribution = block.timestamp;
        lastDistributionTime = block.timestamp;
        
        emit DistributionExecuted(distributionId, totalDistributed, block.timestamp);
    }
    
    // Distribution de récompenses de performance
    function distributePerformanceReward(
        address recipient,
        uint256 amount,
        string memory performanceMetric
    ) external onlyRole(DISTRIBUTOR) nonReentrant {
        require(recipient != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be > 0");
        
        IERC20 token = IERC20(feeToken);
        require(
            token.balanceOf(address(this)) >= amount,
            "Insufficient balance"
        );
        
        token.transfer(recipient, amount);
        
        // Enregistrement de la récompense
        performanceRewards[recipient].push(PerformanceReward({
            recipient: recipient,
            rewardAmount: amount,
            timestamp: block.timestamp,
            performanceMetric: performanceMetric
        }));
        
        emit PerformanceRewardDistributed(
            recipient,
            amount,
            performanceMetric,
            block.timestamp
        );
    }
    
    // Ajout d'un nouveau pool de distribution
    function addDistributionPool(
        address recipient,
        uint256 sharePercentage,
        string memory description
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(recipient != address(0), "Invalid recipient");
        require(sharePercentage > 0 && sharePercentage <= 10000, "Invalid share");
        
        // Vérifier que le total des parts ne dépasse pas 100%
        uint256 totalShares = sharePercentage;
        for (uint256 i = 0; i < distributionPools.length; i++) {
            if (distributionPools[i].isActive) {
                totalShares += distributionPools[i].sharePercentage;
            }
        }
        
        require(totalShares <= 10000, "Total shares exceed 100%");
        
        uint256 poolId = distributionPools.length;
        
        distributionPools.push(DistributionPool({
            recipient: recipient,
            sharePercentage: sharePercentage,
            description: description,
            isActive: true
        }));
        
        emit PoolAdded(poolId, recipient, sharePercentage, description);
    }
    
    // Mise à jour d'un pool existant
    function updateDistributionPool(
        uint256 poolId,
        address newRecipient,
        uint256 newSharePercentage,
        bool isActive
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(poolId < distributionPools.length, "Invalid pool ID");
        
        DistributionPool storage pool = distributionPools[poolId];
        
        if (newRecipient != address(0)) {
            pool.recipient = newRecipient;
        }
        
        if (newSharePercentage > 0) {
            // Vérifier que le nouveau total ne dépasse pas 100%
            uint256 totalShares = newSharePercentage;
            for (uint256 i = 0; i < distributionPools.length; i++) {
                if (i != poolId && distributionPools[i].isActive) {
                    totalShares += distributionPools[i].sharePercentage;
                }
            }
            
            require(totalShares <= 10000, "Total shares exceed 100%");
            pool.sharePercentage = newSharePercentage;
        }
        
        pool.isActive = isActive;
    }
    
    // Distribution manuelle (en cas d'urgence)
    function emergencyDistribution(
        address recipient,
        uint256 amount
    ) external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant {
        require(recipient != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be > 0");
        
        IERC20 token = IERC20(feeToken);
        require(
            token.balanceOf(address(this)) >= amount,
            "Insufficient balance"
        );
        
        token.transfer(recipient, amount);
        
        // Ajuster les frais accumulés
        AccruedFees storage fees = accruedFees[feeToken];
        if (fees.amount >= amount) {
            fees.amount -= amount;
        } else {
            fees.amount = 0;
        }
    }
    
    // Calcul des prochaines distributions
    function calculateNextDistribution() external view returns (
        uint256 nextDistributionTime,
        uint256 estimatedAmount,
        DistributionPool[] memory activePools
    ) {
        nextDistributionTime = lastDistributionTime + distributionInterval;
        
        AccruedFees memory fees = accruedFees[feeToken];
        estimatedAmount = fees.amount;
        
        // Compter les pools actifs
        uint256 activeCount = 0;
        for (uint256 i = 0; i < distributionPools.length; i++) {
            if (distributionPools[i].isActive && distributionPools[i].recipient != address(0)) {
                activeCount++;
            }
        }
        
        // Collecter les pools actifs
        activePools = new DistributionPool[](activeCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < distributionPools.length; i++) {
            if (distributionPools[i].isActive && distributionPools[i].recipient != address(0)) {
                activePools[index] = distributionPools[i];
                index++;
            }
        }
        
        return (nextDistributionTime, estimatedAmount, activePools);
    }
    
    // Récupération des statistiques de distribution
    function getDistributionStats() external view returns (
        uint256 totalAccrued,
        uint256 totalDistributedAmount,
        uint256 pendingDistribution,
        uint256 poolCount,
        uint256 activePoolCount
    ) {
        AccruedFees memory fees = accruedFees[feeToken];
        
        uint256 activeCount = 0;
        for (uint256 i = 0; i < distributionPools.length; i++) {
            if (distributionPools[i].isActive) {
                activeCount++;
            }
        }
        
        return (
            fees.amount,
            totalDistributed,
            fees.amount,
            distributionPools.length,
            activeCount
        );
    }
    
    // Récupération des récompenses de performance d'un utilisateur
    function getUserPerformanceRewards(address user) 
        external 
        view 
        returns (PerformanceReward[] memory) 
    {
        return performanceRewards[user];
    }
    
    // Configuration
    function setDistributionInterval(uint256 newInterval) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newInterval >= 1 days, "Interval too short");
        require(newInterval <= 30 days, "Interval too long");
        
        distributionInterval = newInterval;
    }
    
    function setFeeToken(address newFeeToken) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newFeeToken != address(0), "Invalid token");
        feeToken = newFeeToken;
    }
    
    // Récupération des pools de distribution
    function getAllPools() external view returns (DistributionPool[] memory) {
        return distributionPools;
    }
    
    // Fonction pour calculer la part d'un pool
    function calculatePoolShare(uint256 poolId, uint256 totalAmount) 
        external 
        view 
        returns (uint256) 
    {
        require(poolId < distributionPools.length, "Invalid pool ID");
        
        DistributionPool memory pool = distributionPools[poolId];
        if (!pool.isActive) {
            return 0;
        }
        
        return (totalAmount * pool.sharePercentage) / 10000;
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\infrastructure\NotificationManager.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";

contract NotificationManager is AccessControl {
    // Types de notifications
    enum NotificationType {
        LOAN_CREATED,
        LOAN_REPAYMENT_DUE,
        LOAN_DEFAULT,
        INSURANCE_CLAIM,
        GOVERNANCE_PROPOSAL,
        MARKET_LISTING,
        PRICE_ALERT,
        SYSTEM_UPDATE,
        SECURITY_ALERT
    }
    
    // Priorités
    enum Priority {
        LOW,
        MEDIUM,
        HIGH,
        CRITICAL
    }
    
    // Structure de notification
    struct Notification {
        uint256 notificationId;
        address recipient;
        NotificationType notificationType;
        Priority priority;
        string title;
        string message;
        bytes data;
        uint256 timestamp;
        bool isRead;
        bool isArchived;
    }
    
    // Préférences utilisateur
    struct UserPreferences {
        bool emailNotifications;
        bool pushNotifications;
        bool smsNotifications;
        uint256[] subscribedTypes;
        uint256 quietHoursStart;
        uint256 quietHoursEnd;
    }
    
    // Variables d'état
    mapping(address => Notification[]) public userNotifications;
    mapping(address => UserPreferences) public userPreferences;
    mapping(uint256 => address) public notificationSenders;
    
    uint256 public notificationCount;
    uint256 public maxNotificationsPerUser = 1000;
    
    // Contrats autorisés à envoyer des notifications
    mapping(address => bool) public authorizedSenders;
    
    // Événements
    event NotificationSent(
        uint256 indexed notificationId,
        address indexed recipient,
        NotificationType notificationType,
        Priority priority,
        uint256 timestamp
    );
    
    event NotificationRead(
        uint256 indexed notificationId,
        address indexed recipient,
        uint256 readTime
    );
    
    event PreferencesUpdated(
        address indexed user,
        bool emailNotifications,
        bool pushNotifications,
        uint256 timestamp
    );
    
    // Rôles
    bytes32 public constant NOTIFICATION_SENDER = keccak256("NOTIFICATION_SENDER");
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(NOTIFICATION_SENDER, msg.sender);
    }
    
    // Envoi de notification par un contrat autorisé
    function sendNotification(
        address recipient,
        NotificationType notificationType,
        Priority priority,
        string memory title,
        string memory message,
        bytes memory data
    ) public onlyRole(NOTIFICATION_SENDER) returns (uint256) {
        require(recipient != address(0), "Invalid recipient");
        
        // Vérifier les préférences utilisateur
        UserPreferences memory prefs = userPreferences[recipient];
        if (!_shouldSendNotification(recipient, notificationType, prefs)) {
            return 0;
        }
        
        // Créer la notification
        uint256 notificationId = ++notificationCount;
        
        Notification memory newNotification = Notification({
            notificationId: notificationId,
            recipient: recipient,
            notificationType: notificationType,
            priority: priority,
            title: title,
            message: message,
            data: data,
            timestamp: block.timestamp,
            isRead: false,
            isArchived: false
        });
        
        // Ajouter à la liste de l'utilisateur
        userNotifications[recipient].push(newNotification);
        
        // Gérer la limite de notifications
        _manageNotificationLimit(recipient);
        
        // Enregistrer l'expéditeur
        notificationSenders[notificationId] = msg.sender;
        
        emit NotificationSent(
            notificationId,
            recipient,
            notificationType,
            priority,
            block.timestamp
        );
        
        return notificationId;
    }
    
    // Envoi de notification groupée
    function sendBulkNotification(
        address[] memory recipients,
        NotificationType notificationType,
        Priority priority,
        string memory title,
        string memory message
    ) external onlyRole(NOTIFICATION_SENDER) returns (uint256[] memory) {
        require(recipients.length <= 100, "Too many recipients");
        
        uint256[] memory notificationIds = new uint256[](recipients.length);
        
        for (uint256 i = 0; i < recipients.length; i++) {
            notificationIds[i] = sendNotification(
                recipients[i],
                notificationType,
                priority,
                title,
                message,
                ""
            );
        }
        
        return notificationIds;
    }
    
    // Marquer une notification comme lue
    function markAsRead(uint256 notificationId) external {
        Notification[] storage notifications = userNotifications[msg.sender];
        
        for (uint256 i = 0; i < notifications.length; i++) {
            if (notifications[i].notificationId == notificationId) {
                require(!notifications[i].isRead, "Already read");
                
                notifications[i].isRead = true;
                
                emit NotificationRead(notificationId, msg.sender, block.timestamp);
                return;
            }
        }
        
        revert("Notification not found");
    }
    
    // Marquer toutes les notifications comme lues
    function markAllAsRead() external {
        Notification[] storage notifications = userNotifications[msg.sender];
        uint256 markedCount = 0;
        
        for (uint256 i = 0; i < notifications.length; i++) {
            if (!notifications[i].isRead) {
                notifications[i].isRead = true;
                markedCount++;
                
                emit NotificationRead(
                    notifications[i].notificationId,
                    msg.sender,
                    block.timestamp
                );
            }
        }
    }
    
    // Archiver une notification
    function archiveNotification(uint256 notificationId) external {
        Notification[] storage notifications = userNotifications[msg.sender];
        
        for (uint256 i = 0; i < notifications.length; i++) {
            if (notifications[i].notificationId == notificationId) {
                notifications[i].isArchived = true;
                return;
            }
        }
        
        revert("Notification not found");
    }
    
    // Mettre à jour les préférences
    function updatePreferences(
        bool emailNotifications,
        bool pushNotifications,
        bool smsNotifications,
        uint256[] memory subscribedTypes,
        uint256 quietHoursStart,
        uint256 quietHoursEnd
    ) external {
        userPreferences[msg.sender] = UserPreferences({
            emailNotifications: emailNotifications,
            pushNotifications: pushNotifications,
            smsNotifications: smsNotifications,
            subscribedTypes: subscribedTypes,
            quietHoursStart: quietHoursStart,
            quietHoursEnd: quietHoursEnd
        });
        
        emit PreferencesUpdated(
            msg.sender,
            emailNotifications,
            pushNotifications,
            block.timestamp
        );
    }
    
    // Récupérer les notifications non lues
    function getUnreadNotifications() external view returns (Notification[] memory) {
        Notification[] storage allNotifications = userNotifications[msg.sender];
        uint256 unreadCount = 0;
        
        // Compter les notifications non lues
        for (uint256 i = 0; i < allNotifications.length; i++) {
            if (!allNotifications[i].isRead && !allNotifications[i].isArchived) {
                unreadCount++;
            }
        }
        
        // Collecter les notifications non lues
        Notification[] memory unread = new Notification[](unreadCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < allNotifications.length; i++) {
            if (!allNotifications[i].isRead && !allNotifications[i].isArchived) {
                unread[index] = allNotifications[i];
                index++;
            }
        }
        
        return unread;
    }
    
    // Récupérer les notifications par type
    function getNotificationsByType(NotificationType notificationType) 
        external 
        view 
        returns (Notification[] memory) 
    {
        Notification[] storage allNotifications = userNotifications[msg.sender];
        uint256 matchingCount = 0;
        
        // Compter les notifications correspondantes
        for (uint256 i = 0; i < allNotifications.length; i++) {
            if (allNotifications[i].notificationType == notificationType && 
                !allNotifications[i].isArchived) {
                matchingCount++;
            }
        }
        
        // Collecter les notifications
        Notification[] memory matching = new Notification[](matchingCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < allNotifications.length; i++) {
            if (allNotifications[i].notificationType == notificationType && 
                !allNotifications[i].isArchived) {
                matching[index] = allNotifications[i];
                index++;
            }
        }
        
        return matching;
    }
    
    // Récupérer les notifications par priorité
    function getNotificationsByPriority(Priority priority) 
        external 
        view 
        returns (Notification[] memory) 
    {
        Notification[] storage allNotifications = userNotifications[msg.sender];
        uint256 matchingCount = 0;
        
        // Compter les notifications correspondantes
        for (uint256 i = 0; i < allNotifications.length; i++) {
            if (allNotifications[i].priority == priority && 
                !allNotifications[i].isArchived) {
                matchingCount++;
            }
        }
        
        // Collecter les notifications
        Notification[] memory matching = new Notification[](matchingCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < allNotifications.length; i++) {
            if (allNotifications[i].priority == priority && 
                !allNotifications[i].isArchived) {
                matching[index] = allNotifications[i];
                index++;
            }
        }
        
        return matching;
    }
    
    // Supprimer les notifications archivées
    function cleanupArchived() external {
        Notification[] storage notifications = userNotifications[msg.sender];
        uint256 newLength = 0;
        
        // Déplacer les notifications non archivées au début du tableau
        for (uint256 i = 0; i < notifications.length; i++) {
            if (!notifications[i].isArchived) {
                notifications[newLength] = notifications[i];
                newLength++;
            }
        }
        
        // Réduire la taille du tableau
        while (notifications.length > newLength) {
            notifications.pop();
        }
    }
    
    // Fonctions internes
    function _shouldSendNotification(
        address recipient,
        NotificationType notificationType,
        UserPreferences memory prefs
    ) private view returns (bool) {
        // Vérifier les heures silencieuses
        uint256 currentHour = (block.timestamp / 3600) % 24;
        if (currentHour >= prefs.quietHoursStart && currentHour < prefs.quietHoursEnd) {
            return false;
        }
        
        // Vérifier les types abonnés
        bool isSubscribed = false;
        for (uint256 i = 0; i < prefs.subscribedTypes.length; i++) {
            if (prefs.subscribedTypes[i] == uint256(notificationType)) {
                isSubscribed = true;
                break;
            }
        }
        
        if (prefs.subscribedTypes.length > 0 && !isSubscribed) {
            return false;
        }
        
        return true;
    }
    
    function _manageNotificationLimit(address user) private {
        Notification[] storage notifications = userNotifications[user];
        
        if (notifications.length > maxNotificationsPerUser) {
            // Supprimer les plus anciennes notifications archivées
            uint256 toRemove = notifications.length - maxNotificationsPerUser;
            uint256 removed = 0;
            uint256 i = 0;
            
            while (removed < toRemove && i < notifications.length) {
                if (notifications[i].isArchived) {
                    // Déplacer les éléments suivants
                    for (uint256 j = i; j < notifications.length - 1; j++) {
                        notifications[j] = notifications[j + 1];
                    }
                    notifications.pop();
                    removed++;
                } else {
                    i++;
                }
            }
            
            // Si toujours au-dessus de la limite, supprimer les plus anciennes non archivées
            if (notifications.length > maxNotificationsPerUser) {
                uint256 remainingToRemove = notifications.length - maxNotificationsPerUser;
                for (uint256 k = 0; k < remainingToRemove; k++) {
                    // Déplacer tous les éléments d'une position
                    for (uint256 l = 0; l < notifications.length - 1; l++) {
                        notifications[l] = notifications[l + 1];
                    }
                    notifications.pop();
                }
            }
        }
    }
    
    // Autoriser un contrat à envoyer des notifications
    function authorizeSender(address sender) external onlyRole(DEFAULT_ADMIN_ROLE) {
        authorizedSenders[sender] = true;
        _grantRole(NOTIFICATION_SENDER, sender);
    }
    
    // Révoquer l'autorisation d'un expéditeur
    function revokeSender(address sender) external onlyRole(DEFAULT_ADMIN_ROLE) {
        authorizedSenders[sender] = false;
        _revokeRole(NOTIFICATION_SENDER, sender);
    }
    
    // Getters
    function getNotificationCount(address user) external view returns (uint256) {
        return userNotifications[user].length;
    }
    
    function getUnreadCount(address user) external view returns (uint256) {
        uint256 count = 0;
        Notification[] storage notifications = userNotifications[user];
        
        for (uint256 i = 0; i < notifications.length; i++) {
            if (!notifications[i].isRead && !notifications[i].isArchived) {
                count++;
            }
        }
        
        return count;
    }
    
    function getUserPreferences(address user) external view returns (
        bool emailNotifications,
        bool pushNotifications,
        bool smsNotifications,
        uint256[] memory subscribedTypes
    ) {
        UserPreferences memory prefs = userPreferences[user];
        return (
            prefs.emailNotifications,
            prefs.pushNotifications,
            prefs.smsNotifications,
            prefs.subscribedTypes
        );
    }
    
    // Templates de notifications prédéfinis
    function sendLoanCreatedNotification(
        address borrower,
        uint256 loanId,
        uint256 amount
    ) external onlyRole(NOTIFICATION_SENDER) returns (uint256) {
        string memory title = "Loan Created Successfully";
        string memory message = string(abi.encodePacked(
            "Your loan #",
            _toString(loanId),
            " for ",
            _toString(amount / 1e18),
            " tokens has been created and is now active."
        ));
        
        bytes memory data = abi.encode(loanId, amount);
        
        return sendNotification(
            borrower,
            NotificationType.LOAN_CREATED,
            Priority.MEDIUM,
            title,
            message,
            data
        );
    }
    
    function sendRepaymentDueNotification(
        address borrower,
        uint256 loanId,
        uint256 dueAmount,
        uint256 dueDate
    ) external onlyRole(NOTIFICATION_SENDER) returns (uint256) {
        string memory title = "Loan Repayment Due";
        string memory message = string(abi.encodePacked(
            "Reminder: Payment for loan #",
            _toString(loanId),
            " of ",
            _toString(dueAmount / 1e18),
            " tokens is due on ",
            _timestampToString(dueDate)
        ));
        
        bytes memory data = abi.encode(loanId, dueAmount, dueDate);
        
        return sendNotification(
            borrower,
            NotificationType.LOAN_REPAYMENT_DUE,
            Priority.HIGH,
            title,
            message,
            data
        );
    }
    
    function sendGovernanceProposalNotification(
        address voter,
        uint256 proposalId,
        string memory proposalTitle
    ) external onlyRole(NOTIFICATION_SENDER) returns (uint256) {
        string memory title = "New Governance Proposal";
        string memory message = string(abi.encodePacked(
            "A new proposal #",
            _toString(proposalId),
            ": ",
            proposalTitle,
            " is available for voting."
        ));
        
        bytes memory data = abi.encode(proposalId);
        
        return sendNotification(
            voter,
            NotificationType.GOVERNANCE_PROPOSAL,
            Priority.MEDIUM,
            title,
            message,
            data
        );
    }
    
    // Fonctions utilitaires
    function _toString(uint256 value) private pure returns (string memory) {
        if (value == 0) return "0";
        
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return string(buffer);
    }
    
    function _timestampToString(uint256 timestamp) private pure returns (string memory) {
        // Conversion simplifiée de timestamp en date
        // En production, utiliser une bibliothèque plus complète
        return string(abi.encodePacked(
            _toString((timestamp / 86400) % 30 + 1), // Jour
            "/",
            _toString((timestamp / 2592000) % 12 + 1), // Mois
            "/",
            _toString(1970 + timestamp / 31536000) // Année
        ));
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\infrastructure\OracleAdapter.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

contract OracleAdapter {
    // Sources d'oracle
    struct OracleSource {
        address aggregator;
        uint256 weight;
        bool isActive;
    }
    
    // Données des oracles
    mapping(address => OracleSource[]) public priceOracles;
    mapping(string => address) public oracleFeeds;
    
    // Paramètres
    uint256 public minimumSources = 2;
    uint256 public deviationThreshold = 5; // 5%
    
    // Événements
    event PriceUpdated(
        address indexed token,
        uint256 price,
        uint256 timestamp,
        uint256 sourceCount
    );
    
    event OracleAdded(
        address indexed token,
        address aggregator,
        uint256 weight
    );
    
    constructor() {
        // Initialisation avec des sources par défaut
        _initializeDefaultOracles();
    }
    
    // Initialisation des oracles par défaut
    function _initializeDefaultOracles() private {
        // ETH/USD
        _addOracleSource(
            address(0), // Native token
            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419, // Chainlink ETH/USD
            1000
        );
        
        // BTC/USD
        _addOracleSource(
            0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC
            0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c, // Chainlink BTC/USD
            1000
        );
        
        // USDC/USD
        _addOracleSource(
            0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, // USDC
            0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6, // Chainlink USDC/USD
            1000
        );
    }
    
    // Ajouter une source d'oracle
    function addOracleSource(
        address token,
        address aggregator,
        uint256 weight
    ) external {
        require(weight > 0 && weight <= 1000, "Invalid weight");
        
        _addOracleSource(token, aggregator, weight);
        
        emit OracleAdded(token, aggregator, weight);
    }
    
    function _addOracleSource(
        address token,
        address aggregator,
        uint256 weight
    ) private {
        priceOracles[token].push(OracleSource({
            aggregator: aggregator,
            weight: weight,
            isActive: true
        }));
        
        // Mapper le nom du feed
        string memory feedName = _getFeedName(token, aggregator);
        oracleFeeds[feedName] = aggregator;
    }
    
    // Obtenir le prix d'un token
    function getPrice(address token) public view returns (uint256) {
        OracleSource[] storage sources = priceOracles[token];
        require(sources.length >= minimumSources, "Insufficient sources");
        
        uint256[] memory prices = new uint256[](sources.length);
        uint256[] memory timestamps = new uint256[](sources.length);
        uint256 totalWeight = 0;
        uint256 activeCount = 0;
        
        // Collecter les prix de toutes les sources actives
        for (uint256 i = 0; i < sources.length; i++) {
            if (!sources[i].isActive) continue;
            
            try AggregatorV3Interface(sources[i].aggregator).latestRoundData()
                returns (uint80, int256 price, uint256, uint256 timestamp, uint80)
            {
                if (price <= 0) continue;
                
                prices[activeCount] = uint256(price);
                timestamps[activeCount] = timestamp;
                totalWeight += sources[i].weight;
                activeCount++;
            } catch {
                continue;
            }
        }
        
        require(activeCount >= minimumSources, "Not enough valid sources");
        
        // Vérifier les déviations
        _checkDeviations(prices, activeCount);
        
        // Calculer le prix médian pondéré
        return _calculateWeightedMedian(prices, sources, activeCount, totalWeight);
    }
    
    // Obtenir la valeur en USD
    function getValueInUSD(address token, uint256 amount) external view returns (uint256) {
        if (token == address(0)) {
            // Token natif (ETH)
            uint256 price = getPrice(address(0));
            return (amount * price) / 1e18;
        } else {
            uint256 price = getPrice(token);
            // Supposer 18 décimales pour les tokens ERC20
            return (amount * price) / 1e18;
        }
    }
    
    // Obtenir l'indice de volatilité
    function getVolatilityIndex() external view returns (uint256) {
        // Simuler un indice de volatilité
        // En production, intégrer avec des oracles de volatilité
        return 4500; // 45% en base 10000
    }
    
    // Obtenir l'indice de liquidité
    function getLiquidityIndex() external view returns (uint256) {
        // Simuler un indice de liquidité
        return 7500; // 75%
    }
    
    // Obtenir le taux de défaut
    function getDefaultRate() external view returns (uint256) {
        // Simuler un taux de défaut
        return 250; // 2.5%
    }
    
    // Obtenir le taux d'intérêt
    function getInterestRate() external view returns (uint256) {
        // Simuler le taux d'intérêt
        return 350; // 3.5%
    }
    
    // Vérifier les déviations entre les sources
    function _checkDeviations(uint256[] memory prices, uint256 count) private pure {
        if (count < 2) return;
        
        uint256 sum = 0;
        for (uint256 i = 0; i < count; i++) {
            sum += prices[i];
        }
        uint256 average = sum / count;
        
        for (uint256 i = 0; i < count; i++) {
            uint256 deviation = (prices[i] > average ? 
                prices[i] - average : average - prices[i]) * 10000 / average;
            
            require(deviation <= 500, "Excessive deviation"); // 5%
        }
    }
    
    // Calculer la médiane pondérée
    function _calculateWeightedMedian(
        uint256[] memory prices,
        OracleSource[] storage sources,
        uint256 count,
        uint256 totalWeight
    ) private view returns (uint256) {
        // Tri des prix (algorithme de tri à bulles simple)
        for (uint256 i = 0; i < count - 1; i++) {
            for (uint256 j = 0; j < count - i - 1; j++) {
                if (prices[j] > prices[j + 1]) {
                    (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);
                }
            }
        }
        
        // Trouver la médiane pondérée
        uint256 halfWeight = totalWeight / 2;
        uint256 cumulativeWeight = 0;
        
        for (uint256 i = 0; i < count; i++) {
            cumulativeWeight += _getWeightForPrice(sources, prices[i]);
            
            if (cumulativeWeight >= halfWeight) {
                return prices[i];
            }
        }
        
        return prices[count - 1];
    }
    
    // Obtenir le poids pour un prix donné
    function _getWeightForPrice(
        OracleSource[] storage sources,
        uint256 price
    ) private view returns (uint256) {
        // Pour simplifier, retourner un poids moyen
        // En production, mapper le prix à la source appropriée
        uint256 totalWeight = 0;
        uint256 count = 0;
        
        for (uint256 i = 0; i < sources.length; i++) {
            if (sources[i].isActive) {
                totalWeight += sources[i].weight;
                count++;
            }
        }
        
        return count > 0 ? totalWeight / count : 1000;
    }
    
    // Générer un nom de feed
    function _getFeedName(address token, address aggregator) private pure returns (string memory) {
        return string(abi.encodePacked(
            _addressToString(token),
            "-",
            _addressToString(aggregator)
        ));
    }
    
    // Convertir une adresse en string
    function _addressToString(address addr) private pure returns (string memory) {
        bytes32 value = bytes32(uint256(uint160(addr)));
        bytes memory alphabet = "0123456789abcdef";
        bytes memory str = new bytes(42);
        str[0] = '0';
        str[1] = 'x';
        
        for (uint256 i = 0; i < 20; i++) {
            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        
        return string(str);
    }
    
    // Getters
    function getOracleCount(address token) external view returns (uint256) {
        return priceOracles[token].length;
    }
    
    function getOracleDetails(address token, uint256 index) external view returns (
        address aggregator,
        uint256 weight,
        bool isActive
    ) {
        require(index < priceOracles[token].length, "Invalid index");
        
        OracleSource memory source = priceOracles[token][index];
        return (source.aggregator, source.weight, source.isActive);
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\insurance\DecentralizedGuaranteeFund.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract DecentralizedGuaranteeFund is ReentrancyGuard, AccessControl {
    // Structures de données
    struct FundTier {
        uint256 tierId;
        string name;
        uint256 minDeposit;
        uint256 maxDeposit;
        uint256 targetAPY;
        uint256 riskLevel; // 0-1000
        uint256 allocationPercentage;
        bool isActive;
    }
    
    struct InvestorPosition {
        address investor;
        uint256 tierId;
        uint256 depositedAmount;
        uint256 shares;
        uint256 entryTime;
        uint256 lastClaimTime;
        uint256 claimedRewards;
        uint256 lockedUntil;
    }
    
    struct LossCoverage {
        uint256 coverageId;
        uint256 loanId;
        uint256 lossAmount;
        uint256 coveredAmount;
        uint256 coverageTime;
        address[] coveringInvestors;
        uint256[] coveringAmounts;
    }
    
    // Variables d'état
    FundTier[] public fundTiers;
    mapping(address => InvestorPosition[]) public investorPositions;
    mapping(uint256 => LossCoverage) public lossCoverages;
    
    uint256 public totalFundAssets;
    uint256 public totalCoveredLosses;
    uint256 public totalInvestorRewards;
    uint256 public coverageReserveRatio = 2000; // 20%
    uint256 public minLockupPeriod = 30 days;
    
    address public loanPool;
    IERC20 public fundToken;
    
    // Événements
    event TierCreated(
        uint256 indexed tierId,
        string name,
        uint256 minDeposit,
        uint256 targetAPY,
        uint256 riskLevel
    );
    
    event DepositMade(
        address indexed investor,
        uint256 indexed tierId,
        uint256 amount,
        uint256 shares,
        uint256 lockedUntil
    );
    
    event LossCovered(
        uint256 indexed coverageId,
        uint256 indexed loanId,
        uint256 lossAmount,
        uint256 coveredAmount,
        uint256 timestamp
    );
    
    event RewardClaimed(
        address indexed investor,
        uint256 amount,
        uint256 timestamp
    );
    
    event WithdrawalMade(
        address indexed investor,
        uint256 tierId,
        uint256 amount,
        uint256 timestamp
    );
    
    // Rôles
    bytes32 public constant FUND_MANAGER = keccak256("FUND_MANAGER");
    bytes32 public constant RISK_MANAGER = keccak256("RISK_MANAGER");
    
    constructor(address _loanPool, address _fundToken) {
        loanPool = _loanPool;
        fundToken = IERC20(_fundToken);
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(FUND_MANAGER, msg.sender);
        _grantRole(RISK_MANAGER, msg.sender);
        
        // Initialisation des tiers par défaut
        _initializeTiers();
    }
    
    // Initialisation des tiers
    function _initializeTiers() private {
        // Tier 1: Bas risque, faible rendement
        fundTiers.push(FundTier({
            tierId: 0,
            name: "Conservative",
            minDeposit: 1000 * 1e18,
            maxDeposit: 100000 * 1e18,
            targetAPY: 500, // 5%
            riskLevel: 200,
            allocationPercentage: 4000, // 40%
            isActive: true
        }));
        
        // Tier 2: Risque moyen, rendement moyen
        fundTiers.push(FundTier({
            tierId: 1,
            name: "Balanced",
            minDeposit: 5000 * 1e18,
            maxDeposit: 500000 * 1e18,
            targetAPY: 1000, // 10%
            riskLevel: 500,
            allocationPercentage: 3000, // 30%
            isActive: true
        }));
        
        // Tier 3: Haut risque, haut rendement
        fundTiers.push(FundTier({
            tierId: 2,
            name: "Growth",
            minDeposit: 10000 * 1e18,
            maxDeposit: 1000000 * 1e18,
            targetAPY: 1500, // 15%
            riskLevel: 800,
            allocationPercentage: 2000, // 20%
            isActive: true
        }));
        
        // Tier 4: Très haut risque, très haut rendement
        fundTiers.push(FundTier({
            tierId: 3,
            name: "Aggressive",
            minDeposit: 50000 * 1e18,
            maxDeposit: 5000000 * 1e18,
            targetAPY: 2500, // 25%
            riskLevel: 950,
            allocationPercentage: 1000, // 10%
            isActive: true
        }));
    }
    
    // Dépôt dans le fonds
    function deposit(uint256 tierId, uint256 amount) external nonReentrant {
        require(tierId < fundTiers.length, "Invalid tier");
        require(fundTiers[tierId].isActive, "Tier inactive");
        
        FundTier memory tier = fundTiers[tierId];
        require(amount >= tier.minDeposit, "Below minimum");
        require(amount <= tier.maxDeposit, "Above maximum");
        
        // Vérifier les allocations disponibles
        uint256 tierAssets = _getTierAssets(tierId);
        uint256 maxTierAllocation = (totalFundAssets * tier.allocationPercentage) / 10000;
        
        require(
            tierAssets + amount <= maxTierAllocation,
            "Tier allocation exceeded"
        );
        
        // Transfert des tokens
        require(
            fundToken.transferFrom(msg.sender, address(this), amount),
            "Transfer failed"
        );
        
        // Calcul des parts
        uint256 shares = _calculateShares(amount, tierId);
        
        // Création de la position
        investorPositions[msg.sender].push(InvestorPosition({
            investor: msg.sender,
            tierId: tierId,
            depositedAmount: amount,
            shares: shares,
            entryTime: block.timestamp,
            lastClaimTime: block.timestamp,
            claimedRewards: 0,
            lockedUntil: block.timestamp + minLockupPeriod
        }));
        
        // Mise à jour des totaux
        totalFundAssets += amount;
        
        emit DepositMade(
            msg.sender,
            tierId,
            amount,
            shares,
            block.timestamp + minLockupPeriod
        );
    }
    
    // Couverture d'une perte
    function coverLoss(
        uint256 loanId,
        uint256 lossAmount,
        uint256 trancheId
    ) external onlyRole(RISK_MANAGER) nonReentrant returns (uint256) {
        require(lossAmount > 0, "Invalid loss amount");
        require(lossAmount <= _getCoverableAmount(), "Insufficient coverage capacity");
        
        // Détermination du montant à couvrir
        uint256 coveredAmount = (lossAmount * coverageReserveRatio) / 10000;
        
        // Allocation de la couverture par tier
        (uint256[] memory tierAllocations, address[][] memory coveringInvestors) = 
            _allocateCoverage(coveredAmount, trancheId);
        
        // Création de l'enregistrement de couverture
        uint256 coverageId = _createCoverageRecord(
            loanId,
            lossAmount,
            coveredAmount,
            coveringInvestors,
            tierAllocations
        );
        
        // Déduction des montants des positions des investisseurs
        _deductFromInvestors(coveringInvestors, tierAllocations);
        
        // Mise à jour des totaux
        totalCoveredLosses += coveredAmount;
        totalFundAssets -= coveredAmount;
        
        emit LossCovered(coverageId, loanId, lossAmount, coveredAmount, block.timestamp);
        
        return coveredAmount;
    }
    
    // Réclamation des récompenses
    function claimRewards(uint256 positionIndex) external nonReentrant {
        require(positionIndex < investorPositions[msg.sender].length, "Invalid position");
        
        InvestorPosition storage position = investorPositions[msg.sender][positionIndex];
        require(block.timestamp >= position.entryTime + 7 days, "Too early to claim");
        
        // Calcul des récompenses accumulées
        uint256 rewards = _calculateAccruedRewards(position);
        require(rewards > 0, "No rewards available");
        
        // Vérifier que le fonds a suffisamment de liquidités
        require(rewards <= _getAvailableRewards(), "Insufficient reward liquidity");
        
        // Transfert des récompenses
        require(fundToken.transfer(msg.sender, rewards), "Transfer failed");
        
        // Mise à jour de la position
        position.lastClaimTime = block.timestamp;
        position.claimedRewards += rewards;
        totalInvestorRewards += rewards;
        
        emit RewardClaimed(msg.sender, rewards, block.timestamp);
    }
    
    // Retrait du capital
    function withdraw(uint256 positionIndex, uint256 amount) external nonReentrant {
        require(positionIndex < investorPositions[msg.sender].length, "Invalid position");
        
        InvestorPosition storage position = investorPositions[msg.sender][positionIndex];
        
        require(block.timestamp >= position.lockedUntil, "Still locked");
        require(amount <= position.depositedAmount, "Exceeds deposited amount");
        require(amount <= _getWithdrawableAmount(position), "Exceeds withdrawable amount");
        
        // Calcul des parts à retirer
        uint256 sharesToWithdraw = (position.shares * amount) / position.depositedAmount;
        
        // Transfert des tokens
        require(fundToken.transfer(msg.sender, amount), "Transfer failed");
        
        // Mise à jour de la position
        position.depositedAmount -= amount;
        position.shares -= sharesToWithdraw;
        totalFundAssets -= amount;
        
        // Si la position est vide, la supprimer
        if (position.depositedAmount == 0) {
            _removePosition(msg.sender, positionIndex);
        }
        
        emit WithdrawalMade(msg.sender, position.tierId, amount, block.timestamp);
    }
    
    // Création d'un nouveau tier
    function createTier(
        string memory name,
        uint256 minDeposit,
        uint256 maxDeposit,
        uint256 targetAPY,
        uint256 riskLevel,
        uint256 allocationPercentage
    ) external onlyRole(FUND_MANAGER) {
        require(allocationPercentage <= 10000, "Invalid allocation");
        
        uint256 tierId = fundTiers.length;
        
        fundTiers.push(FundTier({
            tierId: tierId,
            name: name,
            minDeposit: minDeposit,
            maxDeposit: maxDeposit,
            targetAPY: targetAPY,
            riskLevel: riskLevel,
            allocationPercentage: allocationPercentage,
            isActive: true
        }));
        
        emit TierCreated(tierId, name, minDeposit, targetAPY, riskLevel);
    }
    
    // Fonctions internes
    function _calculateShares(uint256 amount, uint256 tierId) private view returns (uint256) {
        // Les parts sont proportionnelles au dépôt ajusté par le risque du tier
        uint256 riskFactor = fundTiers[tierId].riskLevel;
        return (amount * (1000 + riskFactor)) / 1000;
    }
    
    function _getTierAssets(uint256 tierId) private view returns (uint256) {
        uint256 total = 0;
        // À implémenter: calculer le total des actifs dans ce tier
        return total;
    }
    
    function _getCoverableAmount() private view returns (uint256) {
        return (totalFundAssets * coverageReserveRatio) / 10000;
    }
    
    function _allocateCoverage(
        uint256 coveredAmount,
        uint256 trancheId
    ) private returns (uint256[] memory, address[][] memory) {
        // Logique d'allocation complexe basée sur les tiers et le risque
        // À implémenter: algorithme d'allocation optimale
        
        uint256[] memory tierAllocations = new uint256[](fundTiers.length);
        address[][] memory coveringInvestors = new address[][](fundTiers.length);
        
        // Pour l'instant, répartition proportionnelle simple
        for (uint256 i = 0; i < fundTiers.length; i++) {
            tierAllocations[i] = (coveredAmount * fundTiers[i].allocationPercentage) / 10000;
            coveringInvestors[i] = _selectInvestorsForCoverage(i, tierAllocations[i]);
        }
        
        return (tierAllocations, coveringInvestors);
    }
    
    function _createCoverageRecord(
        uint256 loanId,
        uint256 lossAmount,
        uint256 coveredAmount,
        address[][] memory coveringInvestors,
        uint256[] memory tierAllocations
    ) private returns (uint256) {
        uint256 coverageId = uint256(keccak256(abi.encodePacked(
            loanId,
            block.timestamp,
            lossAmount
        )));
        
        // Aplatir la liste des investisseurs
        address[] memory allInvestors;
        uint256[] memory allAmounts;
        
        // À implémenter: construction des listes aplaties
        
        lossCoverages[coverageId] = LossCoverage({
            coverageId: coverageId,
            loanId: loanId,
            lossAmount: lossAmount,
            coveredAmount: coveredAmount,
            coverageTime: block.timestamp,
            coveringInvestors: allInvestors,
            coveringAmounts: allAmounts
        });
        
        return coverageId;
    }
    
    function _deductFromInvestors(
        address[][] memory coveringInvestors,
        uint256[] memory tierAllocations
    ) private {
        // À implémenter: déduction des montants des positions des investisseurs
    }
    
    function _calculateAccruedRewards(InvestorPosition memory position) private view returns (uint256) {
        FundTier memory tier = fundTiers[position.tierId];
        
        uint256 timeSinceLastClaim = block.timestamp - position.lastClaimTime;
        uint256 annualReward = (position.depositedAmount * tier.targetAPY) / 10000;
        uint256 accruedReward = (annualReward * timeSinceLastClaim) / 365 days;
        
        return accruedReward;
    }
    
    function _getAvailableRewards() private view returns (uint256) {
        // Les récompenses sont payées à partir des revenus du fonds
        return fundToken.balanceOf(address(this)) - totalFundAssets;
    }
    
    function _getWithdrawableAmount(InvestorPosition memory position) private view returns (uint256) {
        // Vérifier les pertes couvertes par cette position
        uint256 coveredLosses = _getCoveredLossesForPosition(position);
        
        // Le montant retirable est le dépôt moins les pertes couvertes
        if (position.depositedAmount > coveredLosses) {
            return position.depositedAmount - coveredLosses;
        } else {
            return 0;
        }
    }
    
    function _getCoveredLossesForPosition(InvestorPosition memory position) private view returns (uint256) {
        // À implémenter: calculer les pertes couvertes par cette position
        return 0;
    }
    
    function _removePosition(address investor, uint256 positionIndex) private {
        uint256 lastIndex = investorPositions[investor].length - 1;
        
        if (positionIndex != lastIndex) {
            investorPositions[investor][positionIndex] = investorPositions[investor][lastIndex];
        }
        
        investorPositions[investor].pop();
    }
    
    function _selectInvestorsForCoverage(uint256 tierId, uint256 amount) private view returns (address[] memory) {
        // À implémenter: sélectionner les investisseurs pour la couverture
        return new address[](0);
    }
    
    // Getters
    function getInvestorPositions(address investor) external view returns (InvestorPosition[] memory) {
        return investorPositions[investor];
    }
    
    function getTierDetails(uint256 tierId) external view returns (
        string memory name,
        uint256 minDeposit,
        uint256 maxDeposit,
        uint256 targetAPY,
        uint256 riskLevel,
        uint256 allocationPercentage,
        bool isActive
    ) {
        require(tierId < fundTiers.length, "Invalid tier");
        
        FundTier memory tier = fundTiers[tierId];
        return (
            tier.name,
            tier.minDeposit,
            tier.maxDeposit,
            tier.targetAPY,
            tier.riskLevel,
            tier.allocationPercentage,
            tier.isActive
        );
    }
    
    function getFundStats() external view returns (
        uint256 totalAssets,
        uint256 coveredLosses,
        uint256 investorRewards,
        uint256 coverageCapacity,
        uint256 availableRewards
    ) {
        return (
            totalFundAssets,
            totalCoveredLosses,
            totalInvestorRewards,
            _getCoverableAmount(),
            _getAvailableRewards()
        );
    }
    
    function calculateProjectedAPY(address investor, uint256 positionIndex) external view returns (uint256) {
        require(positionIndex < investorPositions[investor].length, "Invalid position");
        
        InvestorPosition memory position = investorPositions[investor][positionIndex];
        FundTier memory tier = fundTiers[position.tierId];
        
        // APY projeté basé sur le tier, ajusté par la performance du fonds
        uint256 baseAPY = tier.targetAPY;
        uint256 performanceAdjustment = _calculatePerformanceAdjustment();
        
        return baseAPY + performanceAdjustment;
    }
    
    function _calculatePerformanceAdjustment() private view returns (uint256) {
        // À implémenter: calcul de l'ajustement basé sur la performance
        return 0;
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\insurance\InsuranceModule.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "../security/AccessController.sol";

contract InsuranceModule is ReentrancyGuard {
    // Structures de données
    struct InsurancePolicy {
        uint256 policyId;
        uint256 loanId;
        address insured;
        uint256 coverageAmount;
        uint256 premiumAmount;
        uint256 coveragePercentage;
        uint256 startTime;
        uint256 endTime;
        PolicyStatus status;
        address insurer;
        uint256 claimAmount;
        uint256 claimTime;
    }
    
    struct InsurerPool {
        address insurer;
        uint256 totalCapital;
        uint256 allocatedCapital;
        uint256 availableCapital;
        uint256 totalPremiums;
        uint256 totalClaims;
        uint256 performanceScore;
        bool isActive;
    }
    
    // Types et statuts
    enum PolicyStatus { ACTIVE, EXPIRED, CLAIMED, CANCELLED }
    enum CoverageType { FULL, PARTIAL, EXCESS_LOSS }
    
    // Variables d'état
    mapping(uint256 => InsurancePolicy) public policies;
    mapping(address => uint256[]) public userPolicies;
    mapping(address => InsurerPool) public insurerPools;
    
    uint256 public totalPolicies;
    uint256 public totalCoverage;
    uint256 public totalPremiums;
    uint256 public totalClaimsPaid;
    
    // Paramètres d'assurance
    uint256 public basePremiumRate = 200; // 2%
    uint256 public riskMultiplier = 1000; // 10x
    uint256 public minCoveragePercentage = 5000; // 50%
    uint256 public maxCoveragePercentage = 9000; // 90%
    uint256 public insurerCapitalRequirement = 10000 * 1e18; // 10,000 tokens
    
    // Contrats liés
    AccessController public accessController;
    address public loanPool;
    
    // Événements
    event PolicyCreated(
        uint256 indexed policyId,
        uint256 indexed loanId,
        address indexed insured,
        uint256 coverageAmount,
        uint256 premiumAmount,
        uint256 coveragePercentage
    );
    
    event ClaimFiled(
        uint256 indexed policyId,
        uint256 indexed loanId,
        address claimant,
        uint256 claimAmount,
        uint256 timestamp
    );
    
    event ClaimPaid(
        uint256 indexed policyId,
        address insurer,
        uint256 payoutAmount,
        uint256 timestamp
    );
    
    event InsurerRegistered(
        address indexed insurer,
        uint256 capitalDeposited,
        uint256 timestamp
    );
    
    // Modificateurs
    modifier onlyLoanPool() {
        require(msg.sender == loanPool, "Only LoanPool");
        _;
    }
    
    modifier onlyInsurer() {
        require(insurerPools[msg.sender].isActive, "Not active insurer");
        _;
    }
    
    constructor(address _accessController) {
        accessController = AccessController(_accessController);
    }
    
    // Configuration du LoanPool
    function setLoanPool(address _loanPool) external {
        require(
            accessController.hasRole(msg.sender, "ADMIN"),
            "Not authorized"
        );
        loanPool = _loanPool;
    }
    
    // Vérification d'éligibilité pour l'assurance
    function checkEligibility(
        uint256 loanId,
        uint256 riskScore,
        uint256 loanAmount
    ) public view returns (bool eligible, uint256 premium, uint256 coverage) {
        // Vérifications de base
        if (riskScore > 800) { // Risque trop élevé
            return (false, 0, 0);
        }
        
        if (loanAmount > 1000000 * 1e18) { // Montant trop élevé
            return (false, 0, 0);
        }
        
        // Calcul de la prime
        premium = _calculatePremium(riskScore, loanAmount);
        
        // Pourcentage de couverture basé sur le risque
        coverage = _calculateCoveragePercentage(riskScore);
        
        // Vérifier qu'il y a assez de capital d'assurance disponible
        uint256 requiredCapital = (loanAmount * coverage) / 10000;
        if (_getAvailableInsuranceCapital() < requiredCapital) {
            return (false, 0, 0);
        }
        
        return (true, premium, coverage);
    }
    
    // Création d'une police d'assurance
    function createPolicy(
        uint256 loanId,
        address borrower,
        uint256 loanAmount,
        uint256 riskScore,
        uint256 duration
    ) external onlyLoanPool nonReentrant returns (uint256) {
        (bool eligible, uint256 premium, uint256 coverage) = 
            checkEligibility(loanId, riskScore, loanAmount);
        
        require(eligible, "Not eligible for insurance");
        
        // Allocation à un pool d'assureurs
        address insurer = _allocateToInsurer(loanAmount, coverage, riskScore);
        require(insurer != address(0), "No insurer available");
        
        // Création de la police
        uint256 policyId = ++totalPolicies;
        uint256 coverageAmount = (loanAmount * coverage) / 10000;
        
        policies[policyId] = InsurancePolicy({
            policyId: policyId,
            loanId: loanId,
            insured: borrower,
            coverageAmount: coverageAmount,
            premiumAmount: premium,
            coveragePercentage: coverage,
            startTime: block.timestamp,
            endTime: block.timestamp + duration,
            status: PolicyStatus.ACTIVE,
            insurer: insurer,
            claimAmount: 0,
            claimTime: 0
        });
        
        userPolicies[borrower].push(policyId);
        
        // Mise à jour des statistiques
        totalCoverage += coverageAmount;
        totalPremiums += premium;
        
        // Allocation du capital de l'assureur
        insurerPools[insurer].allocatedCapital += coverageAmount;
        insurerPools[insurer].availableCapital -= coverageAmount;
        insurerPools[insurer].totalPremiums += premium;
        
        // Transfert de la prime (doit être approuvé au préalable)
        IERC20 paymentToken = IERC20(_getPaymentToken());
        require(
            paymentToken.transferFrom(borrower, address(this), premium),
            "Premium transfer failed"
        );
        
        // Distribution de la prime (80% à l'assureur, 20% à la réserve)
        uint256 insurerShare = (premium * 8000) / 10000;
        uint256 reserveShare = premium - insurerShare;
        
        paymentToken.transfer(insurer, insurerShare);
        _addToReserve(reserveShare);
        
        emit PolicyCreated(
            policyId,
            loanId,
            borrower,
            coverageAmount,
            premium,
            coverage
        );
        
        return policyId;
    }
    
    // Traitement d'une réclamation
    function processClaim(
        uint256 loanId,
        uint256 loanAmount,
        uint256 coveragePercentage
    ) external onlyLoanPool nonReentrant returns (uint256) {
        // Trouver la police correspondante
        uint256 policyId = _findPolicyForLoan(loanId);
        require(policyId > 0, "No active policy found");
        
        InsurancePolicy storage policy = policies[policyId];
        require(policy.status == PolicyStatus.ACTIVE, "Policy not active");
        require(block.timestamp <= policy.endTime, "Policy expired");
        
        // Calcul du montant de la réclamation
        uint256 claimAmount = (loanAmount * policy.coveragePercentage) / 10000;
        
        // Vérifier que l'assureur a suffisamment de capital
        require(
            insurerPools[policy.insurer].availableCapital >= claimAmount,
            "Insurer insufficient capital"
        );
        
        // Mise à jour de la police
        policy.status = PolicyStatus.CLAIMED;
        policy.claimAmount = claimAmount;
        policy.claimTime = block.timestamp;
        
        // Paiement de la réclamation
        IERC20 paymentToken = IERC20(_getPaymentToken());
        require(
            paymentToken.transferFrom(policy.insurer, msg.sender, claimAmount),
            "Claim payment failed"
        );
        
        // Mise à jour des statistiques
        totalClaimsPaid += claimAmount;
        insurerPools[policy.insurer].totalClaims += claimAmount;
        
        // Ajustement du score de performance de l'assureur
        _updateInsurerPerformance(policy.insurer, claimAmount);
        
        emit ClaimFiled(policyId, loanId, policy.insured, claimAmount, block.timestamp);
        emit ClaimPaid(policyId, policy.insurer, claimAmount, block.timestamp);
        
        return claimAmount;
    }
    
    // Enregistrement d'un nouvel assureur
    function registerAsInsurer(uint256 capitalAmount) external nonReentrant {
        require(capitalAmount >= insurerCapitalRequirement, "Insufficient capital");
        
        IERC20 paymentToken = IERC20(_getPaymentToken());
        require(
            paymentToken.transferFrom(msg.sender, address(this), capitalAmount),
            "Capital transfer failed"
        );
        
        insurerPools[msg.sender] = InsurerPool({
            insurer: msg.sender,
            totalCapital: capitalAmount,
            allocatedCapital: 0,
            availableCapital: capitalAmount,
            totalPremiums: 0,
            totalClaims: 0,
            performanceScore: 1000, // Score initial
            isActive: true
        });
        
        emit InsurerRegistered(msg.sender, capitalAmount, block.timestamp);
    }
    
    // Retrait de capital par un assureur
    function withdrawCapital(uint256 amount) external onlyInsurer nonReentrant {
        InsurerPool storage pool = insurerPools[msg.sender];
        
        require(amount <= pool.availableCapital, "Insufficient available capital");
        require(
            pool.totalCapital - amount >= insurerCapitalRequirement,
            "Below minimum requirement"
        );
        
        pool.totalCapital -= amount;
        pool.availableCapital -= amount;
        
        IERC20 paymentToken = IERC20(_getPaymentToken());
        paymentToken.transfer(msg.sender, amount);
    }
    
    // Réassurance: transfert de risque à d'autres assureurs
    function reinsurePolicy(uint256 policyId, uint256 percentage) external onlyInsurer {
        require(percentage > 0 && percentage <= 10000, "Invalid percentage");
        
        InsurancePolicy storage policy = policies[policyId];
        require(policy.insurer == msg.sender, "Not policy insurer");
        require(policy.status == PolicyStatus.ACTIVE, "Policy not active");
        
        // Trouver d'autres assureurs pour le risque
        address[] memory reinsurers = _findReinsurers(
            policy.coverageAmount,
            percentage,
            policy.insured
        );
        
        require(reinsurers.length > 0, "No reinsurers found");
        
        // Répartir le risque
        uint256 reinsuredAmount = (policy.coverageAmount * percentage) / 10000;
        uint256 perReinsurer = reinsuredAmount / reinsurers.length;
        
        for (uint256 i = 0; i < reinsurers.length; i++) {
            insurerPools[reinsurers[i]].allocatedCapital += perReinsurer;
            insurerPools[reinsurers[i]].availableCapital -= perReinsurer;
            
            // Ajuster le capital de l'assureur original
            insurerPools[msg.sender].allocatedCapital -= perReinsurer;
            insurerPools[msg.sender].availableCapital += perReinsurer;
        }
    }
    
    // Fonctions internes
    function _calculatePremium(uint256 riskScore, uint256 loanAmount) private view returns (uint256) {
        uint256 basePremium = (loanAmount * basePremiumRate) / 10000;
        
        // Ajustement basé sur le risque
        uint256 riskFactor;
        if (riskScore < 300) {
            riskFactor = 500; // 0.5x
        } else if (riskScore < 500) {
            riskFactor = 750; // 0.75x
        } else if (riskScore < 700) {
            riskFactor = 1000; // 1x
        } else {
            riskFactor = 1500; // 1.5x
        }
        
        return (basePremium * riskFactor) / 1000;
    }
    
    function _calculateCoveragePercentage(uint256 riskScore) private view returns (uint256) {
        if (riskScore < 300) {
            return maxCoveragePercentage; // 90%
        } else if (riskScore < 500) {
            return 8000; // 80%
        } else if (riskScore < 700) {
            return 7000; // 70%
        } else {
            return minCoveragePercentage; // 50%
        }
    }
    
    function _allocateToInsurer(
        uint256 loanAmount,
        uint256 coveragePercentage,
        uint256 riskScore
    ) private returns (address) {
        uint256 requiredCapital = (loanAmount * coveragePercentage) / 10000;
        
        // Trouver l'assureur avec le meilleur score et assez de capital
        address bestInsurer = address(0);
        uint256 bestScore = 0;
        
        // Note: Dans une implémentation réelle, il faudrait un mapping des assureurs
        // Pour cette démo, nous utilisons une approche simplifiée
        
        // Vérifier les assureurs enregistrés
        // À implémenter: logique de sélection basée sur le score de performance
        
        return bestInsurer != address(0) ? bestInsurer : address(this); // Fallback au contrat
    }
    
    function _getAvailableInsuranceCapital() private view returns (uint256) {
        uint256 total = 0;
        // À implémenter: sommer le capital disponible de tous les assureurs
        return total;
    }
    
    function _findPolicyForLoan(uint256 loanId) private view returns (uint256) {
        // Recherche linéaire (à optimiser pour la production)
        for (uint256 i = 1; i <= totalPolicies; i++) {
            if (policies[i].loanId == loanId && policies[i].status == PolicyStatus.ACTIVE) {
                return i;
            }
        }
        return 0;
    }
    
    function _updateInsurerPerformance(address insurer, uint256 claimAmount) private {
        InsurerPool storage pool = insurerPools[insurer];
        
        // Calcul du ratio sinistres/primes
        uint256 lossRatio = pool.totalPremiums > 0 ? 
            (pool.totalClaims * 10000) / pool.totalPremiums : 0;
        
        // Ajustement du score
        if (lossRatio < 3000) { // <30%
            pool.performanceScore = pool.performanceScore * 105 / 100;
        } else if (lossRatio > 8000) { // >80%
            pool.performanceScore = pool.performanceScore * 95 / 100;
        }
        
        if (pool.performanceScore < 500) {
            pool.isActive = false; // Désactiver les assureurs peu performants
        }
    }
    
    function _addToReserve(uint256 amount) private {
        // À implémenter: ajout à la réserve de stabilité
    }
    
    function _getPaymentToken() private view returns (address) {
        // À implémenter: récupérer le token de paiement depuis le LoanPool
        return 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC par défaut
    }
    
    function _findReinsurers(
        uint256 coverageAmount,
        uint256 percentage,
        address insured
    ) private view returns (address[] memory) {
        // À implémenter: logique de recherche de réassureurs
        return new address[](0);
    }
    
    // Getters
    function getUserPolicies(address user) external view returns (uint256[] memory) {
        return userPolicies[user];
    }
    
    function getPolicyDetails(uint256 policyId) external view returns (
        uint256 loanId,
        address insured,
        uint256 coverageAmount,
        uint256 premiumAmount,
        uint256 coveragePercentage,
        PolicyStatus status,
        address insurer
    ) {
        InsurancePolicy memory policy = policies[policyId];
        return (
            policy.loanId,
            policy.insured,
            policy.coverageAmount,
            policy.premiumAmount,
            policy.coveragePercentage,
            policy.status,
            policy.insurer
        );
    }
    
    function getInsurerStats(address insurer) external view returns (
        uint256 totalCapital,
        uint256 allocatedCapital,
        uint256 availableCapital,
        uint256 premiumsAmount,
        uint256 totalClaims,
        uint256 performanceScore,
        bool isActive
    ) {
        InsurerPool memory pool = insurerPools[insurer];
        return (
            pool.totalCapital,
            pool.allocatedCapital,
            pool.availableCapital,
            pool.premiumsAmount,
            pool.totalClaims,
            pool.performanceScore,
            pool.isActive
        );
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\interfaces\ICriteriaFilter.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ICriteriaFilter {
    function filterPools(
        string[] memory regions,
        bool ecologicalOnly,
        string[] memory domains,
        uint256 minRate,
        uint256 maxRisk
    ) external view returns (uint256[] memory);
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\interfaces\IInsuranceModule.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IInsuranceModule {
    function subscribeCoverage(
        uint256 poolId,
        uint256 coverageAmount,
        uint256 insurancePoolId
    ) external;
    
    function fileClaim(uint256 poolId, uint256 claimAmount) external;
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\interfaces\ILoanPool.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ILoanPool {
    struct PoolData {
        uint256 poolId;
        address borrower;
        string projectName;
        uint256 targetAmount;
        uint256 collectedAmount;
        uint256 baseInterestRate;
        uint256 dynamicInterestRate;
        uint256 duration;
        string region;
        bool isEcological;
        string activityDomain;
        uint256 riskScore;
        uint256 status;
        uint256 createdAt;
    }
    
    function getPoolDetails(uint256 poolId) external view returns (PoolData memory);
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\interfaces\IRiskEngine.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IRiskEngine {
    function calculateBaseRate(
        address borrower,
        uint256 amount,
        uint256 duration,
        bool isEcological,
        string calldata activityDomain
    ) external returns (uint256);
    
    function calculateRiskScore(
        address borrower,
        uint256 amount,
        uint256 duration,
        string calldata region,
        bool isEcological,
        string calldata activityDomain
    ) external returns (uint256);
    
    function validatePool(uint256 poolId) external returns (bool);
    
    function adjustRateForMarketConditions(
        uint256 poolId,
        uint256 currentRate
    ) external view returns (uint256);
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\interfaces\ISpecialOfferManager.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ISpecialOfferManager {
    function getActiveOfferForPool(uint256 poolId) external view returns (
        bool hasOffer,
        uint256 offerId,
        uint256 bonus,
        uint256 endTime
    );
    
    function getOfferDetails(uint256 offerId) external view returns (
        uint256 bonusRate,
        uint256 endTime
    );
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\interfaces\IStructuredLending.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title IStructuredLending - Interface principale du protocole de prêt
 * @notice Interface standardisée pour l'intégration
 */
interface IStructuredLending {
    
    // Structures de données
    struct PoolData {
        uint256 poolId;
        address borrower;
        string projectName;
        uint256 targetAmount;
        uint256 collectedAmount;
        uint256 baseInterestRate;
        uint256 dynamicInterestRate;
        uint256 duration;
        string region;
        bool isEcological;
        string activityDomain;
        uint256 riskScore;
        uint256 status;
        uint256 createdAt;
    }
    
    struct InvestmentInfo {
        address investor;
        uint256 amount;
        uint256 tokens;
        uint256 investmentTime;
    }
    
    // Événements
    event PoolCreated(uint256 indexed poolId, address indexed borrower);
    event InvestmentMade(uint256 indexed poolId, address indexed investor, uint256 amount);
    event RepaymentMade(uint256 indexed poolId, uint256 amount);
    event PoolCompleted(uint256 indexed poolId);
    
    // Fonctions principales
    function createPool(
        string memory projectName,
        uint256 targetAmount,
        uint256 duration,
        string memory region,
        bool isEcological,
        string memory activityDomain,
        string memory ipfsHash
    ) external returns (uint256);
    
    function invest(uint256 poolId, uint256 amount) external;
    
    function repay(uint256 poolId, uint256 amount) external;
    
    function getPoolDetails(uint256 poolId) external view returns (PoolData memory);
    
    function getPoolInvestments(uint256 poolId) external view returns (InvestmentInfo[] memory);
    
    function calculateDynamicRate(uint256 poolId) external view returns (uint256);
    
    // Fonctions d'administration
    function setProtocolFee(uint256 fee) external;
    
    function setMinMaxInvestment(uint256 min, uint256 max) external;
    
    function emergencyPause(bool paused) external;
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\mocks\MockERC20.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title MockERC20 - Token ERC20 mock pour tests
 * @notice Version simplifiée d'un stablecoin (USDC, DAI) pour tests locaux et testnet
 * @dev Inclut des fonctions spéciales pour le testing (mint, burn, etc.)
 */
contract MockERC20 is ERC20 {
    // Propriétaire du contrat (peut mint/burn)
    address public owner;
    
    // Décimals par défaut (18 comme ETH, ou 6 comme USDC)
    uint8 private _decimals;
    
    // Événements spéciaux pour tests
    event Minted(address indexed to, uint256 amount);
    event Burned(address indexed from, uint256 amount);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    /**
     * @notice Constructeur du MockERC20
     * @param name Nom du token (ex: "Mock USDC")
     * @param symbol Symbole (ex: "mUSDC")
     * @param decimals_ Nombre de décimales (6 pour USDC, 18 pour DAI)
     */
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals_
    ) ERC20(name, symbol) {
        owner = msg.sender;
        _decimals = decimals_;
        
        // Mint initial pour le déployeur
        _mint(msg.sender, 1000000 * 10 ** decimals_);
    }
    
    /**
     * @notice Retourne le nombre de décimales
     */
    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
    
    /**
     * @notice Mint de nouveaux tokens (seulement owner)
     * @dev Pour simuler des faucets ou des dépôts
     */
    function mint(address to, uint256 amount) external {
        require(msg.sender == owner, "MockERC20: Only owner can mint");
        require(to != address(0), "MockERC20: Mint to zero address");
        
        _mint(to, amount);
        emit Minted(to, amount);
    }
    
    /**
     * @notice Burn des tokens (seulement owner)
     * @dev Pour nettoyer ou simuler des frais
     */
    function burn(address from, uint256 amount) external {
        require(msg.sender == owner, "MockERC20: Only owner can burn");
        require(from != address(0), "MockERC20: Burn from zero address");
        
        _burn(from, amount);
        emit Burned(from, amount);
    }
    
    /**
     * @notice Mint avec approval automatique
     * @dev Utile pour les tests d'intégration
     */
    function mintAndApprove(address to, uint256 amount, address spender) external {
        require(msg.sender == owner, "MockERC20: Only owner");
        
        _mint(to, amount);
        _approve(to, spender, amount);
        
        emit Minted(to, amount);
    }
    
    /**
     * @notice Transfère la propriété
     */
    function transferOwnership(address newOwner) external {
        require(msg.sender == owner, "MockERC20: Only owner");
        require(newOwner != address(0), "MockERC20: New owner is zero address");
        
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
    
    /**
     * @notice Donne des tokens à plusieurs adresses
     * @dev Pour peupler plusieurs comptes de test rapidement
     */
    function batchMint(address[] calldata recipients, uint256[] calldata amounts) external {
        require(msg.sender == owner, "MockERC20: Only owner");
        require(recipients.length == amounts.length, "MockERC20: Arrays length mismatch");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), "MockERC20: Zero address in batch");
            _mint(recipients[i], amounts[i]);
            emit Minted(recipients[i], amounts[i]);
        }
    }
    
    /**
     * @notice Simule un transfert depuis une autre adresse (pour tests)
     * @dev Permet de tester les transferFrom sans avoir à faire approve
     */
    function transferFromSimulated(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        require(msg.sender == owner, "MockERC20: Only owner");
        
        _transfer(sender, recipient, amount);
        return true;
    }
    
    /**
     * @notice Augmente l'allowance sans avoir à la mettre à 0 d'abord
     * @dev Contourne le problème d'approve de certains tokens
     */
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        address owner_ = _msgSender();
        _approve(owner_, spender, allowance(owner_, spender) + addedValue);
        return true;
    }
    
    /**
     * @notice Donne des tokens avec différents décimals pour tests
     * @dev Utile pour tester la compatibilité avec différents stablecoins
     */
    function getMockTokens(
        uint8 decimalsType,
        uint256 amount
    ) external pure returns (uint256) {
        if (decimalsType == 6) {
            // USDC style: 6 decimals
            return amount * 10 ** 6;
        } else if (decimalsType == 18) {
            // DAI/ETH style: 18 decimals
            return amount * 10 ** 18;
        } else {
            revert("MockERC20: Unsupported decimals");
        }
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\nft-market\LoanNFT.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

// Début de l'implémentation manuelle de Counters
library Counters {
    struct Counter {
        uint256 _value;
    }
    
    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }
    
    function increment(Counter storage counter) internal {
        unchecked { counter._value += 1; }
    }
    
    function decrement(Counter storage counter) internal {
        uint256 value = counter._value;
        require(value > 0, "Counter: decrement overflow");
        unchecked { counter._value = value - 1; }
    }
    
    function reset(Counter storage counter) internal {
        counter._value = 0;
    }
}
// --- Fin de l'implémentation manuelle ---


contract LoanNFT is ERC721, ERC721Enumerable, ERC721URIStorage, AccessControl {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    // Rôles
    bytes32 public constant LOAN_MANAGER = keccak256("LOAN_MANAGER");
    bytes32 public constant MARKET_MANAGER = keccak256("MARKET_MANAGER");
    
    // Structure de métadonnées enrichies
    struct LoanMetadata {
        uint256 loanId;
        uint256 principalAmount;
        uint256 interestRate; // en base 10000 (1% = 100)
        uint256 duration;
        uint256 startTime;
        uint256 riskScore;
        uint256 trancheId;
        address borrower;
        address currency;
        LoanStatus status;
        uint256 remainingBalance;
        uint256 lastPaymentTime;
        uint256 totalRepaid;
        bool isSecuritized;
        string ipfsMetadata;
    }
    
    // Types de prêts
    enum LoanStatus {
        ACTIVE,
        REPAID,
        DEFAULTED,
        INSURED_PAIDOUT,
        SECURITIZED,
        CANCELLED
    }
    
    // Mapping des métadonnées
    mapping(uint256 => LoanMetadata) public loanMetadata;
    mapping(uint256 => uint256) public loanIdToTokenId;
    mapping(uint256 => uint256) public tokenIdToLoanId;
    
    // Événements
    event LoanNFTMinted(
        uint256 indexed tokenId,
        uint256 indexed loanId,
        address indexed borrower,
        uint256 amount,
        uint256 interestRate,
        uint256 duration
    );
    
    event LoanNFTUpdated(
        uint256 indexed tokenId,
        LoanStatus newStatus,
        uint256 remainingBalance,
        uint256 timestamp
    );
    
    event LoanNFTTransferred(
        uint256 indexed tokenId,
        address from,
        address to,
        uint256 salePrice,
        uint256 timestamp
    );
    
    constructor() ERC721("StructuredLoanNFT", "SLNFT") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(LOAN_MANAGER, msg.sender);
        _grantRole(MARKET_MANAGER, msg.sender);
    }
    
	function _update(address to, uint256 tokenId, address auth)
    internal
    override(ERC721Enumerable)
    returns (address)
	{
		return super._update(to, tokenId, auth);
	}

	function _increaseBalance(address account, uint256 value)
		internal
		override(ERC721Enumerable)
	{
		super._increaseBalance(account, value);
	}

	function tokenURI(uint256 tokenId)
    public
		view
		override(ERC721URIStorage)
		returns (string memory)
	{
		return super.tokenURI(tokenId);
	}

	function supportsInterface(bytes4 interfaceId) 
		public 
		view 
		override(ERC721Enumerable, ERC721URIStorage, AccessControl) 
		returns (bool) 
	{
		return super.supportsInterface(interfaceId);
	}
	
    // Mint d'un nouveau NFT pour un prêt
    function mint(
        address borrower,
        uint256 loanId,
        uint256 principalAmount,
        uint256 interestRate,
        uint256 duration,
        uint256 riskScore,
        uint256 trancheId,
        address currency,
        string memory ipfsMetadata
    ) external onlyRole(LOAN_MANAGER) returns (uint256) {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        // Mint du NFT
        _safeMint(borrower, newTokenId);
        
        // Enregistrement des métadonnées
        loanMetadata[newTokenId] = LoanMetadata({
            loanId: loanId,
            principalAmount: principalAmount,
            interestRate: interestRate,
            duration: duration,
            startTime: block.timestamp,
            riskScore: riskScore,
            trancheId: trancheId,
            borrower: borrower,
            currency: currency,
            status: LoanStatus.ACTIVE,
            remainingBalance: principalAmount,
            lastPaymentTime: block.timestamp,
            totalRepaid: 0,
            isSecuritized: false,
            ipfsMetadata: ipfsMetadata
        });
        
        // Mapping des IDs
        loanIdToTokenId[loanId] = newTokenId;
        tokenIdToLoanId[newTokenId] = loanId;
        
        // Définition de l'URI
        string memory uriString = string(abi.encodePacked(
            "https://api.loanplatform.com/nft/",
            _toString(newTokenId)
        ));
        _setTokenURI(newTokenId, uriString);
        
        emit LoanNFTMinted(
            newTokenId,
            loanId,
            borrower,
            principalAmount,
            interestRate,
            duration
        );
        
        return newTokenId;
    }
    
    // Mise à jour du statut du prêt
    function updateStatus(
        uint256 loanId,
        LoanStatus newStatus,
        uint256 remainingBalance,
        uint256 totalRepaid
    ) external onlyRole(LOAN_MANAGER) {
        uint256 tokenId = loanIdToTokenId[loanId];
        require(tokenId != 0, "NFT not found");
        
        LoanMetadata storage metadata = loanMetadata[tokenId];
        metadata.status = newStatus;
        metadata.remainingBalance = remainingBalance;
        metadata.totalRepaid = totalRepaid;
        metadata.lastPaymentTime = block.timestamp;
        
        emit LoanNFTUpdated(tokenId, newStatus, remainingBalance, block.timestamp);
    }
    
    // Marquage comme remboursé
    function markAsRepaid(uint256 loanId) external onlyRole(LOAN_MANAGER) {
        uint256 tokenId = loanIdToTokenId[loanId];
        require(tokenId != 0, "NFT not found");
        
        loanMetadata[tokenId].status = LoanStatus.REPAID;
        loanMetadata[tokenId].remainingBalance = 0;
        
        // Mise à jour de l'uriString pour refléter le statut
        _setTokenURI(tokenId, string(abi.encodePacked(
            tokenURI(tokenId),
            "?status=repaid"
        )));
    }
    
    // Marquage comme titrisé
    function markAsSecuritized(uint256 loanId) external onlyRole(MARKET_MANAGER) {
        uint256 tokenId = loanIdToTokenId[loanId];
        require(tokenId != 0, "NFT not found");
        
        loanMetadata[tokenId].isSecuritized = true;
        loanMetadata[tokenId].status = LoanStatus.SECURITIZED;
    }
    
    // Enregistrement d'un paiement
    function recordPayment(
        uint256 loanId,
        uint256 paymentAmount,
        uint256 newBalance
    ) external onlyRole(LOAN_MANAGER) {
        uint256 tokenId = loanIdToTokenId[loanId];
        require(tokenId != 0, "NFT not found");
        
        LoanMetadata storage metadata = loanMetadata[tokenId];
        metadata.totalRepaid += paymentAmount;
        metadata.remainingBalance = newBalance;
        metadata.lastPaymentTime = block.timestamp;
    }
    
    // Calcul de la valeur actuelle du prêt
    function calculateCurrentValue(uint256 tokenId) public view returns (uint256) {
        LoanMetadata memory metadata = loanMetadata[tokenId];
        
        if (metadata.status != LoanStatus.ACTIVE) {
            return metadata.remainingBalance;
        }
        
        uint256 elapsedTime = block.timestamp - metadata.startTime;
        uint256 totalTime = metadata.duration;
        
        // Calcul des intérêts accumulés (intérêts simples)
        uint256 interestAccrued = (metadata.principalAmount * metadata.interestRate * elapsedTime) /
            (365 days * 10000);
        
        return metadata.remainingBalance + interestAccrued;
    }
    
    // Vérification de l'éligibilité au marché secondaire
    function isEligibleForSecondaryMarket(uint256 tokenId) public view returns (bool) {
        LoanMetadata memory metadata = loanMetadata[tokenId];
        
        return metadata.status == LoanStatus.ACTIVE &&
            !metadata.isSecuritized &&
            block.timestamp < metadata.startTime + metadata.duration;
    }
    
    // Récupération des détails du prêt
    function getLoanDetails(uint256 tokenId) public view returns (
        uint256 loanId,
        uint256 principalAmount,
        uint256 interestRate,
        uint256 duration,
        uint256 riskScore,
        uint256 trancheId,
        address borrower,
        LoanStatus status,
        uint256 remainingBalance,
        bool isSecuritized
    ) {
        LoanMetadata memory metadata = loanMetadata[tokenId];
        return (
            metadata.loanId,
            metadata.principalAmount,
            metadata.interestRate,
            metadata.duration,
            metadata.riskScore,
            metadata.trancheId,
            metadata.borrower,
            metadata.status,
            metadata.remainingBalance,
            metadata.isSecuritized
        );
    }
    
    // Récupération des métadonnées complètes
    function getFullMetadata(uint256 tokenId) public view returns (
        LoanMetadata memory metadata,
        uint256 currentValue,
        bool eligibleForMarket
    ) {
        metadata = loanMetadata[tokenId];
        currentValue = calculateCurrentValue(tokenId);
        eligibleForMarket = isEligibleForSecondaryMarket(tokenId);
        
        return (metadata, currentValue, eligibleForMarket);
    }
    
    // Transfert avec enregistrement du prix de vente
    function transferWithRecord(
        address from,
        address to,
        uint256 tokenId,
        uint256 salePrice
    ) external onlyRole(MARKET_MANAGER) {
        address owner = ownerOf(tokenId);
		require(
			from == owner || 
			isApprovedForAll(owner, from) || 
			getApproved(tokenId) == from,
			"Not approved"
		);
        
        _transfer(from, to, tokenId);
        
        emit LoanNFTTransferred(tokenId, from, to, salePrice, block.timestamp);
    }
    
    // Batch mint pour plusieurs prêts
    function batchMint(
        address[] memory borrowers,
        uint256[] memory loanIds,
        uint256[] memory amounts,
        uint256[] memory interestRates,
        uint256[] memory durations
    ) external onlyRole(LOAN_MANAGER) returns (uint256[] memory) {
        require(
            borrowers.length == loanIds.length &&
            loanIds.length == amounts.length &&
            amounts.length == interestRates.length &&
            interestRates.length == durations.length,
            "Array length mismatch"
        );
        
        uint256[] memory tokenIds = new uint256[](borrowers.length);
        
        for (uint256 i = 0; i < borrowers.length; i++) {
            _tokenIds.increment();
            uint256 newTokenId = _tokenIds.current();
            
            _safeMint(borrowers[i], newTokenId);
            
            loanMetadata[newTokenId] = LoanMetadata({
                loanId: loanIds[i],
                principalAmount: amounts[i],
                interestRate: interestRates[i],
                duration: durations[i],
                startTime: block.timestamp,
                riskScore: 500, // Score par défaut
                trancheId: 1, // Tranche par défaut
                borrower: borrowers[i],
                currency: address(0), // ETH par défaut
                status: LoanStatus.ACTIVE,
                remainingBalance: amounts[i],
                lastPaymentTime: block.timestamp,
                totalRepaid: 0,
                isSecuritized: false,
                ipfsMetadata: ""
            });
            
            loanIdToTokenId[loanIds[i]] = newTokenId;
            tokenIdToLoanId[newTokenId] = loanIds[i];
            
            tokenIds[i] = newTokenId;
            
            emit LoanNFTMinted(
                newTokenId,
                loanIds[i],
                borrowers[i],
                amounts[i],
                interestRates[i],
                durations[i]
            );
        }
        
        return tokenIds;
    }
    
    // Override des fonctions nécessaires
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }
    
    function _burn(uint256 tokenId) internal override(ERC721URIStorage) {
        super._burn(tokenId);
    }
    
    function uri(uint256 tokenId)
        public
        view
        override(ERC721URIStorage)
        returns (string memory)
    {
        return super.uri(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721Enumerable, ERC721URIStorage, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
    
    // Fonction utilitaire pour convertir uint en string
    function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    
    // Getters
    function getTokenId(uint256 loanId) external view returns (uint256) {
        return loanIdToTokenId[loanId];
    }
    
    function getLoanId(uint256 tokenId) external view returns (uint256) {
        return tokenIdToLoanId[tokenId];
    }
    
    function getBorrowerTokens(address borrower) external view returns (uint256[] memory) {
        uint256 balance = balanceOf(borrower);
        uint256[] memory tokens = new uint256[](balance);
        
        for (uint256 i = 0; i < balance; i++) {
            tokens[i] = tokenOfOwnerByIndex(borrower, i);
        }
        
        return tokens;
    }
    
    function getTokenIdsByStatus(LoanStatus status) external view returns (uint256[] memory) {
        uint256 total = _tokenIds.current();
        uint256 count = 0;
        
        // Compter les tokens avec le statut donné
        for (uint256 i = 1; i <= total; i++) {
            if (loanMetadata[i].status == status) {
                count++;
            }
        }
        
        // Collecter les tokenIds
        uint256[] memory result = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 1; i <= total; i++) {
            if (loanMetadata[i].status == status) {
                result[index] = i;
                index++;
            }
        }
        
        return result;
    }
	
	function _increaseBalance(address account, uint128 value) 
		internal 
		override(ERC721, ERC721Enumerable) 
	{
		super._increaseBalance(account, value);
	}
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\nft-market\SecondaryMarket.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./LoanNFT.sol";

contract SecondaryMarketV2 is ReentrancyGuard {
    // Structures
    struct Listing {
        uint256 tokenId;
        address seller;
        uint256 askingPrice;
        uint256 reservePrice;
        uint256 startTime;
        uint256 endTime;
        bool isAuction;
        bool isActive;
        address highestBidder;
        uint256 highestBid;
    }
    
    struct Bid {
        address bidder;
        uint256 amount;
        uint256 timestamp;
    }
    
    // Données du marché
    mapping(uint256 => Listing) public listings;
    mapping(uint256 => Bid[]) public listingBids;
    mapping(address => uint256[]) public userListings;
    
    // Paramètres
    uint256 public platformFee = 25; // 0.25%
    address public feeRecipient;
    IERC20 public paymentToken;
    LoanNFT public loanNFT;
    
    // Événements
    event Listed(
        uint256 indexed tokenId,
        address indexed seller,
        uint256 askingPrice,
        bool isAuction,
        uint256 timestamp
    );
    
    event Purchased(
        uint256 indexed tokenId,
        address indexed seller,
        address indexed buyer,
        uint256 price,
        uint256 fee,
        uint256 timestamp
    );
    
    event BidPlaced(
        uint256 indexed tokenId,
        address indexed bidder,
        uint256 amount,
        uint256 timestamp
    );
    
    event AuctionEnded(
        uint256 indexed tokenId,
        address indexed winner,
        uint256 winningBid,
        uint256 timestamp
    );
    
    constructor(
        address _loanNFT,
        address _paymentToken,
        address _feeRecipient
    ) {
        loanNFT = LoanNFT(_loanNFT);
        paymentToken = IERC20(_paymentToken);
        feeRecipient = _feeRecipient;
    }
    
    // Liste un NFT à prix fixe
    function listFixedPrice(
        uint256 tokenId,
        uint256 price,
        uint256 durationDays
    ) external nonReentrant {
        require(loanNFT.ownerOf(tokenId) == msg.sender, "Not owner");
        require(price > 0, "Price must be > 0");
        require(durationDays <= 90, "Duration too long");
        
        // Vérifier que le prêt est éligible
        require(_isLoanEligible(tokenId), "Loan not eligible");
        
        // Créer la liste
        listings[tokenId] = Listing({
            tokenId: tokenId,
            seller: msg.sender,
            askingPrice: price,
            reservePrice: price * 80 / 100, // 80% du prix
            startTime: block.timestamp,
            endTime: block.timestamp + (durationDays * 1 days),
            isAuction: false,
            isActive: true,
            highestBidder: address(0),
            highestBid: 0
        });
        
        userListings[msg.sender].push(tokenId);
        
        // Transfert du NFT au contrat
        loanNFT.transferFrom(msg.sender, address(this), tokenId);
        
        emit Listed(tokenId, msg.sender, price, false, block.timestamp);
    }
    
    // Liste en enchère
    function listAuction(
        uint256 tokenId,
        uint256 reservePrice,
        uint256 durationDays
    ) external nonReentrant {
        require(loanNFT.ownerOf(tokenId) == msg.sender, "Not owner");
        require(reservePrice > 0, "Reserve must be > 0");
        require(durationDays <= 30, "Auction too long");
        
        require(_isLoanEligible(tokenId), "Loan not eligible");
        
        listings[tokenId] = Listing({
            tokenId: tokenId,
            seller: msg.sender,
            askingPrice: 0,
            reservePrice: reservePrice,
            startTime: block.timestamp,
            endTime: block.timestamp + (durationDays * 1 days),
            isAuction: true,
            isActive: true,
            highestBidder: address(0),
            highestBid: 0
        });
        
        userListings[msg.sender].push(tokenId);
        
        loanNFT.transferFrom(msg.sender, address(this), tokenId);
        
        emit Listed(tokenId, msg.sender, reservePrice, true, block.timestamp);
    }
    
    // Acheter à prix fixe
    function purchase(uint256 tokenId) external nonReentrant {
        Listing storage listing = listings[tokenId];
        
        require(listing.isActive, "Not active");
        require(!listing.isAuction, "Is auction");
        require(block.timestamp <= listing.endTime, "Listing expired");
        
        uint256 price = listing.askingPrice;
        uint256 fee = (price * platformFee) / 10000;
        uint256 sellerProceeds = price - fee;
        
        // Transfert du paiement
        require(
            paymentToken.transferFrom(msg.sender, address(this), price),
            "Transfer failed"
        );
        
        // Distribution
        paymentToken.transfer(listing.seller, sellerProceeds);
        paymentToken.transfer(feeRecipient, fee);
        
        // Transfert du NFT
        loanNFT.transferFrom(address(this), msg.sender, tokenId);
        
        // Mise à jour
        listing.isActive = false;
        
        emit Purchased(
            tokenId,
            listing.seller,
            msg.sender,
            price,
            fee,
            block.timestamp
        );
    }
    
    // Placer une enchère
    function placeBid(uint256 tokenId, uint256 amount) external nonReentrant {
        Listing storage listing = listings[tokenId];
        
        require(listing.isActive, "Not active");
        require(listing.isAuction, "Not auction");
        require(block.timestamp <= listing.endTime, "Auction ended");
        require(amount > listing.highestBid, "Bid too low");
        require(amount >= listing.reservePrice, "Below reserve");
        
        // Rembourser l'ancien encherisseur
        if (listing.highestBidder != address(0)) {
            paymentToken.transfer(listing.highestBidder, listing.highestBid);
        }
        
        // Recevoir la nouvelle enchère
        require(
            paymentToken.transferFrom(msg.sender, address(this), amount),
            "Transfer failed"
        );
        
        // Mise à jour
        listing.highestBidder = msg.sender;
        listing.highestBid = amount;
        
        // Enregistrer l'enchère
        listingBids[tokenId].push(Bid({
            bidder: msg.sender,
            amount: amount,
            timestamp: block.timestamp
        }));
        
        emit BidPlaced(tokenId, msg.sender, amount, block.timestamp);
    }
    
    // Finaliser une enchère
    function finalizeAuction(uint256 tokenId) external nonReentrant {
        Listing storage listing = listings[tokenId];
        
        require(listing.isActive, "Not active");
        require(listing.isAuction, "Not auction");
        require(block.timestamp > listing.endTime, "Auction not ended");
        require(listing.highestBidder != address(0), "No bids");
        
        uint256 winningBid = listing.highestBid;
        uint256 fee = (winningBid * platformFee) / 10000;
        uint256 sellerProceeds = winningBid - fee;
        
        // Distribution
        paymentToken.transfer(listing.seller, sellerProceeds);
        paymentToken.transfer(feeRecipient, fee);
        
        // Transfert du NFT
        loanNFT.transferFrom(address(this), listing.highestBidder, tokenId);
        
        // Mise à jour
        listing.isActive = false;
        
        emit AuctionEnded(
            tokenId,
            listing.highestBidder,
            winningBid,
            block.timestamp
        );
    }
    
    // Retirer une liste
    function cancelListing(uint256 tokenId) external nonReentrant {
        Listing storage listing = listings[tokenId];
        
        require(listing.seller == msg.sender, "Not seller");
        require(listing.isActive, "Not active");
        
        // Pour les enchères, vérifier qu'il n'y a pas d'enchères
        if (listing.isAuction) {
            require(listing.highestBidder == address(0), "Bids exist");
        }
        
        // Rembourser le NFT
        loanNFT.transferFrom(address(this), msg.sender, tokenId);
        
        listing.isActive = false;
    }
    
    // Vérifier l'éligibilité d'un prêt
    function _isLoanEligible(uint256 tokenId) private view returns (bool) {
        // Récupérer les détails du prêt
        (,, uint256 loanAmount, uint256 interestRate, uint256 duration,,,) = 
            loanNFT.getLoanDetails(tokenId);
        
        // Vérifications de base
        if (loanAmount == 0) return false;
        if (duration < 30 days) return false;
        
        // Vérifier le statut (doit être actif)
        // À implémenter: intégration avec LoanPool
        
        return true;
    }
    
    // Getters
    function getListingBids(uint256 tokenId) external view returns (Bid[] memory) {
        return listingBids[tokenId];
    }
    
    function getUserListings(address user) external view returns (uint256[] memory) {
        return userListings[user];
    }
    
    function getMarketStats() external view returns (
        uint256 totalListings,
        uint256 activeListings,
        uint256 totalVolume,
        uint256 averagePrice
    ) {
        // À implémenter: statistiques du marché
        return (0, 0, 0, 0);
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\security\AccessController.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

contract AccessController is AccessControl {
    using EnumerableSet for EnumerableSet.AddressSet;
    
    // Structures de données améliorées
    struct RoleConfig {
        bytes32 role;
        string name;
        string description;
        uint256 maxMembers;
        uint256 minMembers;
        bool isSensitive;
        uint256 approvalThreshold; // Pourcentage requis pour les changements
    }
    
    struct PermissionLog {
        address user;
        bytes32 role;
        bool granted;
        address executor;
        uint256 timestamp;
        string reason;
    }
    
    struct ContractRegistration {
        address contractAddress;
        string name;
        string version;
        uint256 registeredAt;
        address registeredBy;
        bool isActive;
        string ipfsConfig;
    }
    
    // Variables d'état
    mapping(bytes32 => RoleConfig) public roleConfigs;
    mapping(bytes32 => EnumerableSet.AddressSet) private roleMembers;
    mapping(address => bytes32[]) public userRoles;
    mapping(address => PermissionLog[]) public permissionLogs;
    mapping(address => ContractRegistration) public registeredContracts;
    
    EnumerableSet.AddressSet private registeredContractsSet;
    
    uint256 public logRetentionPeriod = 365 days;
    uint256 public maxRolesPerUser = 10;
    uint256 public roleChangeCooldown = 24 hours;
    
    mapping(address => mapping(bytes32 => uint256)) public lastRoleChange;
    
    // Rôles système
    bytes32 public constant SUPER_ADMIN = keccak256("SUPER_ADMIN");
    bytes32 public constant SECURITY_ADMIN = keccak256("SECURITY_ADMIN");
    bytes32 public constant AUDITOR = keccak256("AUDITOR");
    bytes32 public constant UPGRADE_MANAGER = keccak256("UPGRADE_MANAGER");
    
    // Événements
    event RoleConfigured(
        bytes32 indexed role,
        string name,
        string description,
        uint256 maxMembers,
        uint256 minMembers,
        bool isSensitive
    );
    
    event RoleGrantedWithApproval(
        bytes32 indexed role,
        address indexed account,
        address indexed granter,
        uint256 approvalCount,
        uint256 timestamp
    );
    
    event RoleRevokedWithReason(
        bytes32 indexed role,
        address indexed account,
        address indexed revoker,
        string reason,
        uint256 timestamp
    );
    
    event ContractRegistered(
        address indexed contractAddress,
        string name,
        string version,
        address indexed registrant,
        uint256 timestamp
    );
    
    event ContractDeregistered(
        address indexed contractAddress,
        address indexed deregistrant,
        string reason,
        uint256 timestamp
    );
    
    event EmergencyAccessActivated(
        address indexed executor,
        uint256 duration,
        string emergencyReason,
        uint256 timestamp
    );
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(SUPER_ADMIN, msg.sender);
        _grantRole(SECURITY_ADMIN, msg.sender);
        
        // Initialisation des rôles système
        _initializeSystemRoles();
    }
    
    // Initialisation des rôles système
    function _initializeSystemRoles() private {
        // Configuration du rôle SUPER_ADMIN
        roleConfigs[SUPER_ADMIN] = RoleConfig({
            role: SUPER_ADMIN,
            name: "Super Administrator",
            description: "Full system access, can configure all roles",
            maxMembers: 3,
            minMembers: 1,
            isSensitive: true,
            approvalThreshold: 7500 // 75% d'approbation nécessaire
        });
        
        // Configuration du rôle SECURITY_ADMIN
        roleConfigs[SECURITY_ADMIN] = RoleConfig({
            role: SECURITY_ADMIN,
            name: "Security Administrator",
            description: "Manages security settings and emergency procedures",
            maxMembers: 5,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 6600 // 66% d'approbation
        });
        
        // Configuration du rôle AUDITOR
        roleConfigs[AUDITOR] = RoleConfig({
            role: AUDITOR,
            name: "System Auditor",
            description: "Read-only access to all system logs and configurations",
            maxMembers: 10,
            minMembers: 1,
            isSensitive: false,
            approvalThreshold: 5000 // 50% d'approbation
        });
        
        // Configuration du rôle UPGRADE_MANAGER
        roleConfigs[UPGRADE_MANAGER] = RoleConfig({
            role: UPGRADE_MANAGER,
            name: "Upgrade Manager",
            description: "Manages contract upgrades and deployments",
            maxMembers: 5,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 7500 // 75% d'approbation
        });
        
        // Rôles standards du système de prêt
        _configureStandardRoles();
    }
    
    function _configureStandardRoles() private {
        // Rôle LOAN_MANAGER
        bytes32 LOAN_MANAGER = keccak256("LOAN_MANAGER");
        roleConfigs[LOAN_MANAGER] = RoleConfig({
            role: LOAN_MANAGER,
            name: "Loan Manager",
            description: "Manages loan creation, approval, and lifecycle",
            maxMembers: 10,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 6600
        });
        
        // Rôle RISK_MANAGER
        bytes32 RISK_MANAGER = keccak256("RISK_MANAGER");
        roleConfigs[RISK_MANAGER] = RoleConfig({
            role: RISK_MANAGER,
            name: "Risk Manager",
            description: "Manages risk parameters and default processing",
            maxMembers: 8,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 6600
        });
        
        // Rôle INSURANCE_MANAGER
        bytes32 INSURANCE_MANAGER = keccak256("INSURANCE_MANAGER");
        roleConfigs[INSURANCE_MANAGER] = RoleConfig({
            role: INSURANCE_MANAGER,
            name: "Insurance Manager",
            description: "Manages insurance policies and claims",
            maxMembers: 8,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 6600
        });
        
        // Rôle FUND_MANAGER
        bytes32 FUND_MANAGER = keccak256("FUND_MANAGER");
        roleConfigs[FUND_MANAGER] = RoleConfig({
            role: FUND_MANAGER,
            name: "Fund Manager",
            description: "Manages guarantee fund and treasury",
            maxMembers: 5,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 7500
        });
        
        // Rôle GOVERNANCE_MANAGER
        bytes32 GOVERNANCE_MANAGER = keccak256("GOVERNANCE_MANAGER");
        roleConfigs[GOVERNANCE_MANAGER] = RoleConfig({
            role: GOVERNANCE_MANAGER,
            name: "Governance Manager",
            description: "Manages governance proposals and voting",
            maxMembers: 10,
            minMembers: 3,
            isSensitive: false,
            approvalThreshold: 5000
        });
        
        // Rôle NOTIFICATION_SENDER
        bytes32 NOTIFICATION_SENDER = keccak256("NOTIFICATION_SENDER");
        roleConfigs[NOTIFICATION_SENDER] = RoleConfig({
            role: NOTIFICATION_SENDER,
            name: "Notification Sender",
            description: "Can send system notifications to users",
            maxMembers: 15,
            minMembers: 1,
            isSensitive: false,
            approvalThreshold: 5000
        });
        
        // Rôle FEE_COLLECTOR
        bytes32 FEE_COLLECTOR = keccak256("FEE_COLLECTOR");
        roleConfigs[FEE_COLLECTOR] = RoleConfig({
            role: FEE_COLLECTOR,
            name: "Fee Collector",
            description: "Can collect and distribute system fees",
            maxMembers: 5,
            minMembers: 2,
            isSensitive: true,
            approvalThreshold: 6600
        });
    }
    
    // Configuration d'un nouveau rôle
    function configureRole(
        bytes32 role,
        string memory name,
        string memory description,
        uint256 maxMembers,
        uint256 minMembers,
        bool isSensitive,
        uint256 approvalThreshold
    ) external onlyRole(SUPER_ADMIN) {
        require(maxMembers >= minMembers, "Invalid member limits");
        require(approvalThreshold <= 10000, "Invalid threshold");
        
        roleConfigs[role] = RoleConfig({
            role: role,
            name: name,
            description: description,
            maxMembers: maxMembers,
            minMembers: minMembers,
            isSensitive: isSensitive,
            approvalThreshold: approvalThreshold
        });
        
        emit RoleConfigured(role, name, description, maxMembers, minMembers, isSensitive);
    }
    
    // Attribution de rôle avec approbation multi-sig
    function grantRoleWithApproval(
        bytes32 role,
        address account,
        bytes[] memory signatures
    ) external {
        RoleConfig memory config = roleConfigs[role];
        require(config.role != bytes32(0), "Role not configured");
        
        // Vérifier le cooldown
        require(
            block.timestamp >= lastRoleChange[account][role] + roleChangeCooldown,
            "Cooldown period active"
        );
        
        // Vérifier la limite de membres
        require(
            roleMembers[role].length() < config.maxMembers,
            "Role member limit reached"
        );
        
        // Vérifier la limite de rôles par utilisateur
        require(
            userRoles[account].length < maxRolesPerUser,
            "User role limit reached"
        );
        
        // Pour les rôles sensibles, vérifier les signatures
        if (config.isSensitive) {
            uint256 approvalCount = _validateSignatures(role, account, true, signatures);
            require(
                approvalCount * 10000 >= config.approvalThreshold * roleMembers[role].length(),
                "Insufficient approvals"
            );
        }
        
        // Attribution du rôle
        _grantRole(role, account);
		roleMembers[role].push(account);
        
        // Mettre à jour les rôles de l'utilisateur
        userRoles[account].push(role);
        
        // Enregistrer le log
        permissionLogs[account].push(PermissionLog({
            user: account,
            role: role,
            granted: true,
            executor: msg.sender,
            timestamp: block.timestamp,
            reason: "Multi-sig approval"
        }));
        
        lastRoleChange[account][role] = block.timestamp;
        
        emit RoleGrantedWithApproval(
            role,
            account,
            msg.sender,
            config.isSensitive ? signatures.length : 1,
            block.timestamp
        );
    }
    
    // Révocation de rôle avec raison
    function revokeRoleWithReason(
        bytes32 role,
        address account,
        string memory reason
    ) external onlyRole(getRoleAdmin(role)) {
        require(hasRole(role, account), "Address does not have role");
        
        // Vérifier le minimum de membres
        RoleConfig memory config = roleConfigs[role];
        if (config.minMembers > 0) {
            require(
                roleMembers[role].length() > config.minMembers,
                "Cannot go below minimum members"
            );
        }
        
        _revokeRole(role, account);
        roleMembers[role].remove(account);
        
        // Retirer le rôle de la liste de l'utilisateur
        _removeUserRole(account, role);
        
        // Enregistrer le log
        permissionLogs[account].push(PermissionLog({
            user: account,
            role: role,
            granted: false,
            executor: msg.sender,
            timestamp: block.timestamp,
            reason: reason
        }));
        
        emit RoleRevokedWithReason(role, account, msg.sender, reason, block.timestamp);
    }
    
    // Enregistrement d'un contrat
    function registerContract(
        address contractAddress,
        string memory name,
        string memory version,
        string memory ipfsConfig
    ) external onlyRole(UPGRADE_MANAGER) {
        require(contractAddress != address(0), "Invalid contract address");
        require(!registeredContractsSet.contains(contractAddress), "Contract already registered");
        
        registeredContracts[contractAddress] = ContractRegistration({
            contractAddress: contractAddress,
            name: name,
            version: version,
            registeredAt: block.timestamp,
            registeredBy: msg.sender,
            isActive: true,
            ipfsConfig: ipfsConfig
        });
        
        registeredContractsSet.push(contractAddress);
        
        emit ContractRegistered(contractAddress, name, version, msg.sender, block.timestamp);
    }
    
    // Désactivation d'un contrat
    function deregisterContract(
        address contractAddress,
        string memory reason
    ) external onlyRole(SECURITY_ADMIN) {
        require(registeredContractsSet.contains(contractAddress), "Contract not registered");
        
        registeredContracts[contractAddress].isActive = false;
        
        emit ContractDeregistered(contractAddress, msg.sender, reason, block.timestamp);
    }
    
    // Vérification d'accès avec contexte
    function checkAccess(
        address user,
        bytes32 role,
        bytes memory context
    ) external view returns (bool hasAccess, string memory reason) {
        if (!hasRole(role, user)) {
            return (false, "User does not have required role");
        }
        
        ContractRegistration memory contractInfo = registeredContracts[msg.sender];
        if (!contractInfo.isActive) {
            return (false, "Calling contract is not active");
        }
        
        // Vérifications supplémentaires selon le contexte
        if (context.length > 0) {
            // Exemple: vérification de limites de temps pour certains rôles
            // À étendre selon les besoins spécifiques
        }
        
        return (true, "Access granted");
    }
    
    // Activation d'accès d'urgence
    function activateEmergencyAccess(
        uint256 duration,
        string memory emergencyReason
    ) external onlyRole(SECURITY_ADMIN) {
        // Créer un rôle d'urgence temporaire
        bytes32 emergencyRole = keccak256(abi.encodePacked(
            "EMERGENCY_ACCESS_",
            block.timestamp
        ));
        
        // Configuration temporaire
        roleConfigs[emergencyRole] = RoleConfig({
            role: emergencyRole,
            name: "Emergency Access",
            description: string(abi.encodePacked("Emergency access for: ", emergencyReason)),
            maxMembers: 3,
            minMembers: 1,
            isSensitive: true,
            approvalThreshold: 10000
        });
        
        // Attribution à l'exécuteur
        _grantRole(emergencyRole, msg.sender);
        roleMembers[emergencyRole].push(msg.sender);
        
        // Programmer la révocation automatique
        _scheduleRoleRevocation(emergencyRole, msg.sender, block.timestamp + duration);
        
        emit EmergencyAccessActivated(
            msg.sender,
            duration,
            emergencyReason,
            block.timestamp
        );
    }
    
    // Vérification KYC
    function isKYCCertified(address user) external view returns (bool) {
        // À intégrer avec KYCRegistry
        // Pour l'instant, retourne true pour les tests
        return true;
    }
    
    // Fonctions internes
    function _validateSignatures(
        bytes32 role,
        address account,
        bool grant,
        bytes[] memory signatures
    ) private view returns (uint256) {
        uint256 validSignatures = 0;
        bytes32 messageHash = keccak256(abi.encodePacked(
            role,
            account,
            grant,
            block.chainid,
            address(this)
        ));
        
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        
        for (uint256 i = 0; i < signatures.length; i++) {
            address signer = _recoverSigner(ethSignedMessageHash, signatures[i]);
            if (hasRole(getRoleAdmin(role), signer)) {
                validSignatures++;
            }
        }
        
        return validSignatures;
    }
    
    function _recoverSigner(
        bytes32 ethSignedMessageHash,
        bytes memory signature
    ) private pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature);
        return ecrecover(ethSignedMessageHash, v, r, s);
    }
    
    function _splitSignature(bytes memory signature) private pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(signature.length == 65, "Invalid signature length");
        
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        
        if (v < 27) {
            v += 27;
        }
    }
    
    function _removeUserRole(address user, bytes32 role) private {
        bytes32[] storage roles = userRoles[user];
        for (uint256 i = 0; i < roles.length; i++) {
            if (roles[i] == role) {
                roles[i] = roles[roles.length - 1];
                roles.pop();
                break;
            }
        }
    }
    
    function _scheduleRoleRevocation(
        bytes32 role,
        address account,
        uint256 revocationTime
    ) private {
        // À implémenter: scheduler pour révocation automatique
        // Pourrait utiliser un contrat de timelock ou un scheduler externe
    }
    
    // Getters
    function getRoleMembers(bytes32 role) external view returns (address[] memory) {
        return roleMembers[role].values();
    }
    
    function getRoleMemberCount(bytes32 role) external view returns (uint256) {
        return roleMembers[role].length();
    }
    
    function getUserRoles(address user) external view returns (bytes32[] memory) {
        return userRoles[user];
    }
    
    function getPermissionLogs(
        address user,
        uint256 limit
    ) external view returns (PermissionLog[] memory) {
        PermissionLog[] storage logs = permissionLogs[user];
        
        if (limit == 0 || limit > logs.length) {
            limit = logs.length;
        }
        
        PermissionLog[] memory result = new PermissionLog[](limit);
        
        for (uint256 i = 0; i < limit; i++) {
            result[i] = logs[logs.length - 1 - i];
        }
        
        return result;
    }
    
    function getRegisteredContracts() external view returns (address[] memory) {
        return registeredContractsSet.values();
    }
    
    function getContractInfo(
        address contractAddress
    ) external view returns (ContractRegistration memory) {
        return registeredContracts[contractAddress];
    }
    
    function hasRoleWithContext(
        bytes32 role,
        address account,
        bytes memory context
    ) external view returns (bool) {
        // Vérification de base
        if (!hasRole(role, account)) {
            return false;
        }
        
        // Vérifications contextuelles supplémentaires
        // À implémenter selon les besoins
        return true;
    }
    
    // Override de la fonction standard pour utiliser notre logique
    function grantRole(bytes32 role, address account) public override onlyRole(getRoleAdmin(role)) {
        // Utiliser la fonction avec approbation pour les rôles sensibles
        RoleConfig memory config = roleConfigs[role];
        
        if (config.isSensitive) {
            revert("Use grantRoleWithApproval for sensitive roles");
        }
        
        super.grantRole(role, account);
        roleMembers[role].push(account);
        
        if (!_hasRoleInArray(userRoles[account], role)) {
            userRoles[account].push(role);
        }
    }
    
    function _hasRoleInArray(
        bytes32[] memory roles,
        bytes32 role
    ) private pure returns (bool) {
        for (uint256 i = 0; i < roles.length; i++) {
            if (roles[i] == role) {
                return true;
            }
        }
        return false;
    }
    
    // Fonction pour initialiser tous les rôles standards (appelée une fois)
    function initializeRoles() external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Cette fonction est déjà appelée dans le constructeur
        // Existe pour compatibilité avec les scripts de déploiement
        emit RoleConfigured(SUPER_ADMIN, "Super Administrator", 
            "Full system access", 3, 1, true);
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\security\EmergencyExecutor.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./AccessController.sol";

contract EmergencyExecutor is AccessControl, Pausable {
    
    
    // Structures de données
    struct EmergencyAction {
        uint256 actionId;
        string actionType;
        address targetContract;
        bytes data;
        address proposedBy;
        uint256 proposedAt;
        uint256 approvedAt;
        uint256 executedAt;
        address executedBy;
        EmergencyStatus status;
        string description;
        string emergencyReason;
        uint256 requiredApprovals;
        uint256 currentApprovals;
        address[] approvers;
        bytes[] signatures;
    }
    
    struct EmergencyConfig {
        string actionType;
        uint256 requiredApprovals;
        uint256 executionDelay;
        uint256 validityPeriod;
        bool requiresMultisig;
        uint256 maxUsagePerPeriod;
        uint256 usedInPeriod;
        uint256 periodStart;
    }
    
    // Statuts
    enum EmergencyStatus {
        PROPOSED,
        APPROVED,
        EXECUTED,
        REJECTED,
        EXPIRED,
        CANCELLED
    }
    
    // Types d'actions d'urgence
    enum EmergencyActionType {
        PAUSE_SYSTEM,
        UNPAUSE_SYSTEM,
        WITHDRAW_FUNDS,
        FREEZE_USER,
        UNFREEZE_USER,
        ADJUST_PARAMETERS,
        UPGRADE_CONTRACT,
        MIGRATE_DATA,
        ACTIVATE_BACKUP,
        DECLARE_DISASTER
    }
    
    // Variables d'état
    mapping(uint256 => EmergencyAction) public emergencyActions;
    mapping(string => EmergencyConfig) public emergencyConfigs;
    mapping(address => uint256) public lastEmergencyAction;
    mapping(address => bool) public frozenAccounts;
    mapping(address => uint256) public freezeExpiry;
    
    AccessController public accessController;
    
    uint256 public actionCounter;
    uint256 public emergencyCooldown = 1 hours;
    uint256 public maxActionsPerDay = 10;
    uint256 public actionsToday;
    uint256 public dayStart;
    
    // Garde-fous
    uint256 public maxWithdrawalPercentage = 10; // 10% maximum par action
    uint256 public minApprovalDelay = 15 minutes;
    uint256 public maxFreezeDuration = 30 days;
    
    // Rôles
    bytes32 public constant EMERGENCY_PROPOSER = keccak256("EMERGENCY_PROPOSER");
    bytes32 public constant EMERGENCY_APPROVER = keccak256("EMERGENCY_APPROVER");
    bytes32 public constant EMERGENCY_EXECUTOR = keccak256("EMERGENCY_EXECUTOR");
    
    // Événements
    event EmergencyActionProposed(
        uint256 indexed actionId,
        string actionType,
        address indexed targetContract,
        address indexed proposer,
        string emergencyReason,
        uint256 timestamp
    );
    
    event EmergencyActionApproved(
        uint256 indexed actionId,
        address indexed approver,
        uint256 approvalCount,
        uint256 timestamp
    );
    
    event EmergencyActionExecuted(
        uint256 indexed actionId,
        address indexed executor,
        bytes result,
        uint256 timestamp
    );
    
    event EmergencyActionRejected(
        uint256 indexed actionId,
        address indexed rejector,
        string reason,
        uint256 timestamp
    );
    
    event SystemPaused(
        address indexed pauser,
        string reason,
        uint256 duration,
        uint256 timestamp
    );
    
    event SystemUnpaused(
        address indexed unpauser,
        uint256 timestamp
    );
    
    event AccountFrozen(
        address indexed account,
        address indexed freezer,
        uint256 duration,
        string reason,
        uint256 timestamp
    );
    
    event AccountUnfrozen(
        address indexed account,
        address indexed unfreezer,
        uint256 timestamp
    );
    
    constructor(address _accessController) {
        accessController = AccessController(_accessController);
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(EMERGENCY_PROPOSER, msg.sender);
        _grantRole(EMERGENCY_APPROVER, msg.sender);
        _grantRole(EMERGENCY_EXECUTOR, msg.sender);
        
        // Initialisation des configurations
        _initializeEmergencyConfigs();
        
        dayStart = block.timestamp;
    }
    
    // Initialisation des configurations d'urgence
    function _initializeEmergencyConfigs() private {
        // Configuration PAUSE_SYSTEM
        emergencyConfigs["PAUSE_SYSTEM"] = EmergencyConfig({
            actionType: "PAUSE_SYSTEM",
            requiredApprovals: 2,
            executionDelay: 5 minutes,
            validityPeriod: 24 hours,
            requiresMultisig: true,
            maxUsagePerPeriod: 3,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration UNPAUSE_SYSTEM
        emergencyConfigs["UNPAUSE_SYSTEM"] = EmergencyConfig({
            actionType: "UNPAUSE_SYSTEM",
            requiredApprovals: 2,
            executionDelay: 0,
            validityPeriod: 24 hours,
            requiresMultisig: true,
            maxUsagePerPeriod: 3,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration WITHDRAW_FUNDS
        emergencyConfigs["WITHDRAW_FUNDS"] = EmergencyConfig({
            actionType: "WITHDRAW_FUNDS",
            requiredApprovals: 3,
            executionDelay: 30 minutes,
            validityPeriod: 48 hours,
            requiresMultisig: true,
            maxUsagePerPeriod: 1,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration FREEZE_USER
        emergencyConfigs["FREEZE_USER"] = EmergencyConfig({
            actionType: "FREEZE_USER",
            requiredApprovals: 2,
            executionDelay: 10 minutes,
            validityPeriod: 12 hours,
            requiresMultisig: true,
            maxUsagePerPeriod: 10,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration UNFREEZE_USER
        emergencyConfigs["UNFREEZE_USER"] = EmergencyConfig({
            actionType: "UNFREEZE_USER",
            requiredApprovals: 1,
            executionDelay: 0,
            validityPeriod: 12 hours,
            requiresMultisig: false,
            maxUsagePerPeriod: 20,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration ADJUST_PARAMETERS
        emergencyConfigs["ADJUST_PARAMETERS"] = EmergencyConfig({
            actionType: "ADJUST_PARAMETERS",
            requiredApprovals: 2,
            executionDelay: 15 minutes,
            validityPeriod: 24 hours,
            requiresMultisig: true,
            maxUsagePerPeriod: 5,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration UPGRADE_CONTRACT
        emergencyConfigs["UPGRADE_CONTRACT"] = EmergencyConfig({
            actionType: "UPGRADE_CONTRACT",
            requiredApprovals: 3,
            executionDelay: 1 hours,
            validityPeriod: 72 hours,
            requiresMultisig: true,
            maxUsagePerPeriod: 1,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
        
        // Configuration DECLARE_DISASTER
        emergencyConfigs["DECLARE_DISASTER"] = EmergencyConfig({
            actionType: "DECLARE_DISASTER",
            requiredApprovals: 4,
            executionDelay: 0,
            validityPeriod: 168 hours, // 7 jours
            requiresMultisig: true,
            maxUsagePerPeriod: 1,
            usedInPeriod: 0,
            periodStart: block.timestamp
        });
    }
    
    // Proposition d'une action d'urgence
    function proposeEmergencyAction(
        string memory actionType,
        address targetContract,
        bytes memory calldataPayload,
        string memory description,
        string memory emergencyReason,
        bytes memory signature
    ) external onlyRole(EMERGENCY_PROPOSER) returns (uint256) {
        // Vérifier le cooldown
        require(
            block.timestamp >= lastEmergencyAction[msg.sender] + emergencyCooldown,
            "Emergency action cooldown active"
        );
        
        // Vérifier la limite quotidienne
        _checkDailyLimit();
        
        // Vérifier la configuration
        EmergencyConfig memory config = emergencyConfigs[actionType];
        require(bytes(config.actionType).length > 0, "Invalid action type");
        
        // Vérifier la limite d'utilisation
        require(
            config.usedInPeriod < config.maxUsagePerPeriod,
            "Max usage for this action type reached"
        );
        
        // Vérifier la signature pour les actions sensibles
        if (config.requiresMultisig) {
            _validateProposalSignature(
                actionType,
                targetContract,
                calldataPayload,
                emergencyReason,
                signature
            );
        }
        
        // Créer l'action
        uint256 actionId = ++actionCounter;
        
        emergencyActions[actionId] = EmergencyAction({
            actionId: actionId,
            actionType: actionType,
            targetContract: targetContract,
            payload: calldataPayload,
            proposedBy: msg.sender,
            proposedAt: block.timestamp,
            approvedAt: 0,
            executedAt: 0,
            executedBy: address(0),
            status: EmergencyStatus.PROPOSED,
            description: description,
            emergencyReason: emergencyReason,
            requiredApprovals: config.requiredApprovals,
            currentApprovals: 0,
            approvers: new address[](0),
            signatures: new bytes[](0)
        });
        
        // Mettre à jour l'utilisation
        config.usedInPeriod++;
        emergencyConfigs[actionType] = config;
        
        // Mettre à jour le timestamp de dernière action
        lastEmergencyAction[msg.sender] = block.timestamp;
        actionsToday++;
        
        emit EmergencyActionProposed(
            actionId,
            actionType,
            targetContract,
            msg.sender,
            emergencyReason,
            block.timestamp
        );
        
        return actionId;
    }
    
    // Approbation d'une action d'urgence
    function approveEmergencyAction(
        uint256 actionId,
        bytes memory signature
    ) external onlyRole(EMERGENCY_APPROVER) {
        EmergencyAction storage action = emergencyActions[actionId];
        
        require(action.status == EmergencyStatus.PROPOSED, "Action not in proposed state");
        require(action.currentApprovals < action.requiredApprovals, "Already approved");
        
        // Vérifier que l'approbateur n'a pas déjà approuvé
        for (uint256 i = 0; i < action.approvers.length; i++) {
            require(action.approvers[i] != msg.sender, "Already approved this action");
        }
        
        // Vérifier la signature
        _validateApprovalSignature(actionId, signature);
        
        // Vérifier la validité
        EmergencyConfig memory config = emergencyConfigs[action.actionType];
        require(
            block.timestamp <= action.proposedAt + config.validityPeriod,
            "Action proposal expired"
        );
        
        // Ajouter l'approbation
        action.currentApprovals++;
        action.approvers.push(msg.sender);
        action.signatures.push(signature);
        
        // Si les approbations requises sont atteintes
        if (action.currentApprovals >= action.requiredApprovals) {
            action.status = EmergencyStatus.APPROVED;
            action.approvedAt = block.timestamp;
        }
        
        emit EmergencyActionApproved(
            actionId,
            msg.sender,
            action.currentApprovals,
            block.timestamp
        );
    }
    
    // Exécution d'une action d'urgence
    function executeEmergencyAction(
        uint256 actionId
    ) external onlyRole(EMERGENCY_EXECUTOR) returns (bytes memory) {
        EmergencyAction storage action = emergencyActions[actionId];
        
        require(action.status == EmergencyStatus.APPROVED, "Action not approved");
        
        EmergencyConfig memory config = emergencyConfigs[action.actionType];
        
        // Vérifier le délai d'exécution
        require(
            block.timestamp >= action.approvedAt + config.executionDelay,
            "Execution delay not passed"
        );
        
        // Vérifier que l'action n'a pas expiré
        require(
            block.timestamp <= action.proposedAt + config.validityPeriod,
            "Action expired"
        );
        
        // Exécuter l'action
        bytes memory result;
        bool success;
        
        if (keccak256(bytes(action.actionType)) == keccak256(bytes("PAUSE_SYSTEM"))) {
            _pauseSystem(action.emergencyReason);
            result = abi.encode("System paused");
        } else if (keccak256(bytes(action.actionType)) == keccak256(bytes("UNPAUSE_SYSTEM"))) {
            _unpauseSystem();
            result = abi.encode("System unpaused");
        } else if (keccak256(bytes(action.actionType)) == keccak256(bytes("FREEZE_USER"))) {
            (address user, uint256 duration, string memory reason) = 
                abi.decode(action.data, (address, uint256, string));
            _freezeAccount(user, duration, reason);
            result = abi.encode("Account frozen");
        } else if (keccak256(bytes(action.actionType)) == keccak256(bytes("UNFREEZE_USER"))) {
            address user = abi.decode(action.data, (address));
            _unfreezeAccount(user);
            result = abi.encode("Account unfrozen");
        } else {
            // Action contractuelle générique
            (success, result) = action.targetContract.call(action.data);
            require(success, "Emergency action execution failed");
        }
        
        // Mettre à jour l'action
        action.status = EmergencyStatus.EXECUTED;
        action.executedAt = block.timestamp;
        action.executedBy = msg.sender;
        
        emit EmergencyActionExecuted(actionId, msg.sender, result, block.timestamp);
        
        return result;
    }
    
    // Rejet d'une action d'urgence
    function rejectEmergencyAction(
        uint256 actionId,
        string memory reason
    ) external onlyRole(EMERGENCY_APPROVER) {
        EmergencyAction storage action = emergencyActions[actionId];
        
        require(
            action.status == EmergencyStatus.PROPOSED || 
            action.status == EmergencyStatus.APPROVED,
            "Cannot reject in current state"
        );
        
        action.status = EmergencyStatus.REJECTED;
        
        // Libérer l'utilisation dans la configuration
        EmergencyConfig storage config = emergencyConfigs[action.actionType];
        if (config.usedInPeriod > 0) {
            config.usedInPeriod--;
        }
        
        emit EmergencyActionRejected(actionId, msg.sender, reason, block.timestamp);
    }
    
    // Annulation d'une action d'urgence par le proposant
    function cancelEmergencyAction(uint256 actionId) external {
        EmergencyAction storage action = emergencyActions[actionId];
        
        require(
            action.proposedBy == msg.sender ||
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Not authorized to cancel"
        );
        
        require(
            action.status == EmergencyStatus.PROPOSED,
            "Cannot cancel in current state"
        );
        
        action.status = EmergencyStatus.CANCELLED;
        
        // Libérer l'utilisation
        EmergencyConfig storage config = emergencyConfigs[action.actionType];
        if (config.usedInPeriod > 0) {
            config.usedInPeriod--;
        }
    }
    
    // Fonction de secours pour geler un compte immédiatement (sans approbation)
    function emergencyFreezeAccount(
        address account,
        uint256 duration,
        string memory reason,
        bytes[] memory signatures
    ) external onlyRole(EMERGENCY_EXECUTOR) {
        require(duration <= maxFreezeDuration, "Freeze duration too long");
        
        // Vérifier les signatures d'urgence
        require(
            _validateEmergencyFreezeSignatures(account, duration, reason, signatures) >= 2,
            "Insufficient emergency signatures"
        );
        
        _freezeAccount(account, duration, reason);
    }
    
    // Fonction de secours pour retirer des fonds immédiatement
    function emergencyWithdraw(
        address token,
        address recipient,
        uint256 amount,
        string memory reason,
        bytes[] memory signatures
    ) external onlyRole(EMERGENCY_EXECUTOR) returns (bool) {
        // Vérifier les signatures
        require(
            _validateEmergencyWithdrawSignatures(token, recipient, amount, reason, signatures) >= 3,
            "Insufficient emergency signatures"
        );
        
        // Limiter le pourcentage de retrait
        // À implémenter: vérification du solde total
        
        // Exécuter le retrait
        (bool success, ) = token.call(
            abi.encodeWithSignature(
                "transfer(address,uint256)",
                recipient,
                amount
            )
        );
        
        require(success, "Emergency withdrawal failed");
        
        return true;
    }
    
    // Fonctions internes
    function _checkDailyLimit() private {
        // Réinitialiser le compteur quotidien si nécessaire
        if (block.timestamp >= dayStart + 1 days) {
            actionsToday = 0;
            dayStart = block.timestamp;
        }
        
        require(actionsToday < maxActionsPerDay, "Daily emergency action limit reached");
    }
    
    function _validateProposalSignature(
        string memory actionType,
        address targetContract,
        bytes memory calldataPayload,
        string memory emergencyReason,
        bytes memory signature
    ) private view {
        bytes32 messageHash = keccak256(abi.encodePacked(
            actionType,
            targetContract,
            calldataPayload,
            emergencyReason,
            block.chainid,
            address(this),
            "EMERGENCY_PROPOSAL"
        ));
        
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        
        address recovered = _recoverSigner(ethSignedMessageHash, signature);
        
        require(
            hasRole(EMERGENCY_PROPOSER, recovered) ||
            hasRole(DEFAULT_ADMIN_ROLE, recovered),
            "Invalid proposal signature"
        );
    }
    
    function _validateApprovalSignature(
        uint256 actionId,
        bytes memory signature
    ) private view {
        bytes32 messageHash = keccak256(abi.encodePacked(
            actionId,
            block.chainid,
            address(this),
            "EMERGENCY_APPROVAL"
        ));
        
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        
        address recovered = _recoverSigner(ethSignedMessageHash, signature);
        
        require(
            hasRole(EMERGENCY_APPROVER, recovered) ||
            hasRole(DEFAULT_ADMIN_ROLE, recovered),
            "Invalid approval signature"
        );
    }
    
    function _validateEmergencyFreezeSignatures(
        address account,
        uint256 duration,
        string memory reason,
        bytes[] memory signatures
    ) private view returns (uint256) {
        uint256 validSignatures = 0;
        bytes32 messageHash = keccak256(abi.encodePacked(
            account,
            duration,
            reason,
            block.chainid,
            address(this),
            "EMERGENCY_FREEZE"
        ));
        
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        
        for (uint256 i = 0; i < signatures.length; i++) {
            address signer = _recoverSigner(ethSignedMessageHash, signatures[i]);
            if (hasRole(EMERGENCY_EXECUTOR, signer) || hasRole(DEFAULT_ADMIN_ROLE, signer)) {
                validSignatures++;
            }
        }
        
        return validSignatures;
    }
    
    function _validateEmergencyWithdrawSignatures(
        address token,
        address recipient,
        uint256 amount,
        string memory reason,
        bytes[] memory signatures
    ) private view returns (uint256) {
        uint256 validSignatures = 0;
        bytes32 messageHash = keccak256(abi.encodePacked(
            token,
            recipient,
            amount,
            reason,
            block.chainid,
            address(this),
            "EMERGENCY_WITHDRAW"
        ));
        
        bytes32 ethSignedMessageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        
        for (uint256 i = 0; i < signatures.length; i++) {
            address signer = _recoverSigner(ethSignedMessageHash, signatures[i]);
            if (hasRole(EMERGENCY_EXECUTOR, signer) || hasRole(DEFAULT_ADMIN_ROLE, signer)) {
                validSignatures++;
            }
        }
        
        return validSignatures;
    }
    
    function _recoverSigner(
        bytes32 ethSignedMessageHash,
        bytes memory signature
    ) private pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature);
        return ecrecover(ethSignedMessageHash, v, r, s);
    }
    
    function _splitSignature(bytes memory signature) private pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(signature.length == 65, "Invalid signature length");
        
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        
        if (v < 27) {
            v += 27;
        }
    }
    
    function _pauseSystem(string memory reason) private whenNotPaused {
        _pause();
        
        emit SystemPaused(
            msg.sender,
            reason,
            emergencyConfigs["PAUSE_SYSTEM"].validityPeriod,
            block.timestamp
        );
    }
    
    function _unpauseSystem() private whenPaused {
        _unpause();
        
        emit SystemUnpaused(msg.sender, block.timestamp);
    }
    
    function _freezeAccount(
        address account,
        uint256 duration,
        string memory reason
    ) private {
        require(account != address(0), "Invalid account");
        require(duration <= maxFreezeDuration, "Duration too long");
        
        frozenAccounts[account] = true;
        freezeExpiry[account] = block.timestamp + duration;
        
        emit AccountFrozen(account, msg.sender, duration, reason, block.timestamp);
    }
    
    function _unfreezeAccount(address account) private {
        require(frozenAccounts[account], "Account not frozen");
        
        frozenAccounts[account] = false;
        freezeExpiry[account] = 0;
        
        emit AccountUnfrozen(account, msg.sender, block.timestamp);
    }
    
    // Getters
    function getEmergencyAction(uint256 actionId) external view returns (EmergencyAction memory) {
        return emergencyActions[actionId];
    }
    
    function getPendingActions() external view returns (uint256[] memory) {
        uint256 pendingCount = 0;
        
        // Compter les actions en attente
        for (uint256 i = 1; i <= actionCounter; i++) {
            if (emergencyActions[i].status == EmergencyStatus.PROPOSED ||
                emergencyActions[i].status == EmergencyStatus.APPROVED) {
                pendingCount++;
            }
        }
        
        // Collecter les IDs
        uint256[] memory pendingIds = new uint256[](pendingCount);
        uint256 index = 0;
        
        for (uint256 i = 1; i <= actionCounter; i++) {
            if (emergencyActions[i].status == EmergencyStatus.PROPOSED ||
                emergencyActions[i].status == EmergencyStatus.APPROVED) {
                pendingIds[index] = i;
                index++;
            }
        }
        
        return pendingIds;
    }
    
    function isAccountFrozen(address account) external view returns (bool) {
        if (!frozenAccounts[account]) {
            return false;
        }
        
        // Vérifier l'expiration
        if (block.timestamp > freezeExpiry[account]) {
            return false;
        }
        
        return true;
    }
    
    function getFreezeExpiry(address account) external view returns (uint256) {
        return freezeExpiry[account];
    }
    
    function getEmergencyConfig(string memory actionType) external view returns (EmergencyConfig memory) {
        return emergencyConfigs[actionType];
    }
    
    function getTodayStats() external view returns (uint256 actions, uint256 remaining) {
        uint256 today = block.timestamp / 1 days;
        uint256 startDay = dayStart / 1 days;
        
        if (today > startDay) {
            return (0, maxActionsPerDay);
        }
        
        return (actionsToday, maxActionsPerDay - actionsToday);
    }
    
    // Configuration
    function setEmergencyCooldown(uint256 newCooldown) external onlyRole(DEFAULT_ADMIN_ROLE) {
        emergencyCooldown = newCooldown;
    }
    
    function setMaxActionsPerDay(uint256 newMax) external onlyRole(DEFAULT_ADMIN_ROLE) {
        maxActionsPerDay = newMax;
    }
    
    function setMaxFreezeDuration(uint256 newDuration) external onlyRole(DEFAULT_ADMIN_ROLE) {
        maxFreezeDuration = newDuration;
    }
    
    function updateEmergencyConfig(
        string memory actionType,
        uint256 requiredApprovals,
        uint256 executionDelay,
        uint256 validityPeriod,
        bool requiresMultisig,
        uint256 maxUsagePerPeriod
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        EmergencyConfig storage config = emergencyConfigs[actionType];
        
        config.requiredApprovals = requiredApprovals;
        config.executionDelay = executionDelay;
        config.validityPeriod = validityPeriod;
        config.requiresMultisig = requiresMultisig;
        config.maxUsagePerPeriod = maxUsagePerPeriod;
        
        // Réinitialiser la période si nécessaire
        if (block.timestamp >= config.periodStart + 30 days) {
            config.usedInPeriod = 0;
            config.periodStart = block.timestamp;
        }
    }
    
    // Fonction pour dégeler les comptes expirés
    function cleanupExpiredFreezes() external {
        uint256 cleaned = 0;
        
        // Cette fonction peut être appelée par n'importe qui pour nettoyer les freezes expirés
        for (uint256 i = 0; i < 100; i++) { // Limiter à 100 itérations par transaction
            // Note: Dans une implémentation réelle, nous aurions besoin d'une liste des comptes gelés
            // Pour cette démo, nous utilisons une approche simplifiée
            break;
        }
    }
    
    // Override de la fonction pause pour utiliser notre logique
    function pause() public override onlyRole(EMERGENCY_EXECUTOR) {
        super.pause();
    }
    
    function unpause() public override onlyRole(EMERGENCY_EXECUTOR) {
        super.unpause();
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\security\KYCRegistry.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./AccessController.sol";

contract KYCRegistry is AccessControl {
    using ECDSA for bytes32;
    
    // Structures de données
    struct KYCData {
        address user;
        string userId; // ID unique du système KYC
        uint256 level; // Niveau de vérification: 1=Basic, 2=Advanced, 3=Enhanced
        uint256 verifiedAt;
        uint256 expiresAt;
        address verifiedBy;
        string ipfsHash; // Hash des documents KYC sur IPFS
        bool isActive;
        uint256 lastUpdate;
        string countryCode;
        uint256 riskScore; // Score de risque AML (0-1000)
    }
    
    struct KYCAuditLog {
        address user;
        string action;
        address performedBy;
        uint256 timestamp;
        bytes data;
    }
    
    struct SanctionCheck {
        address user;
        string sanctionList;
        bool isSanctioned;
        uint256 checkedAt;
        string details;
    }
    
    // Niveaux de vérification
    enum VerificationLevel {
        UNVERIFIED,
        BASIC,      // Email + Phone
        ADVANCED,   // Identity document
        ENHANCED,   // Face recognition + source of funds
        INSTITUTIONAL // Corporate verification
    }
    
    // Variables d'état
    mapping(address => KYCData) public kycData;
    mapping(string => address) public userIdToAddress;
    mapping(address => KYCAuditLog[]) public auditLogs;
    mapping(address => SanctionCheck[]) public sanctionChecks;
    
    mapping(string => bool) public blacklistedCountries;
    mapping(address => bool) public pepDatabase; // Politically Exposed Persons
    
    AccessController public accessController;
    
    uint256 public kycExpiryPeriod = 365 days;
    uint256 public pepCheckThreshold = 10000 * 1e18; // 10,000 tokens
    uint256 public sanctionCheckInterval = 30 days;
    
    // Rôles
    bytes32 public constant KYC_VERIFIER = keccak256("KYC_VERIFIER");
    bytes32 public constant KYC_AUDITOR = keccak256("KYC_AUDITOR");
    bytes32 public constant SANCTION_MANAGER = keccak256("SANCTION_MANAGER");
    
    // Événements
    event KYCVerified(
        address indexed user,
        uint256 level,
        string userId,
        address indexed verifier,
        uint256 expiresAt
    );
    
    event KYCRevoked(
        address indexed user,
        address indexed revoker,
        string reason,
        uint256 timestamp
    );
    
    event KYCUpdated(
        address indexed user,
        uint256 newLevel,
        uint256 newExpiry,
        address indexed updater
    );
    
    event SanctionChecked(
        address indexed user,
        string sanctionList,
        bool isSanctioned,
        uint256 timestamp
    );
    
    event PEPFlagged(
        address indexed user,
        bool isPEP,
        string details,
        uint256 timestamp
    );
    
    constructor(address _accessController) {
        accessController = AccessController(_accessController);
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(KYC_VERIFIER, msg.sender);
        _grantRole(KYC_AUDITOR, msg.sender);
        _grantRole(SANCTION_MANAGER, msg.sender);
        
        // Initialisation des pays blacklistés
        _initializeBlacklistedCountries();
    }
    
    // Vérification KYC de base
    function verifyBasicKYC(
        address user,
        string memory userId,
        string memory ipfsHash,
        string memory countryCode,
        bytes memory signature
    ) external onlyRole(KYC_VERIFIER) {
        require(user != address(0), "Invalid user address");
        require(bytes(userId).length > 0, "User ID required");
        require(!_isBlacklistedCountry(countryCode), "Country blacklisted");
        
        // Vérifier la signature pour l'authentification
        _validateSignature(user, userId, ipfsHash, countryCode, signature);
        
        // Vérifier que l'ID n'est pas déjà utilisé
        require(userIdToAddress[userId] == address(0), "User ID already exists");
        
        // Vérifications PEP pour les montants élevés
        bool isPEP = _checkPEPDatabase(user, countryCode);
        uint256 riskScore = _calculateRiskScore(user, countryCode, isPEP);
        
        // Créer l'enregistrement KYC
        kycData[user] = KYCData({
            user: user,
            userId: userId,
            level: uint256(VerificationLevel.BASIC),
            verifiedAt: block.timestamp,
            expiresAt: block.timestamp + kycExpiryPeriod,
            verifiedBy: msg.sender,
            ipfsHash: ipfsHash,
            isActive: true,
            lastUpdate: block.timestamp,
            countryCode: countryCode,
            riskScore: riskScore
        });
        
        userIdToAddress[userId] = user;
        
        // Vérification des sanctions
        _performSanctionCheck(user, countryCode);
        
        // Journal d'audit
        _logAudit(user, "BASIC_KYC_VERIFICATION", abi.encode(ipfsHash, countryCode));
        
        emit KYCVerified(
            user,
            uint256(VerificationLevel.BASIC),
            userId,
            msg.sender,
            block.timestamp + kycExpiryPeriod
        );
        
        if (isPEP) {
            emit PEPFlagged(user, true, "PEP detected during KYC", block.timestamp);
        }
    }
    
    // Mise à niveau de la vérification
    function upgradeVerificationLevel(
        address user,
        uint256 newLevel,
        string memory additionalDataIpfs,
        bytes memory signature
    ) external onlyRole(KYC_VERIFIER) {
        require(kycData[user].isActive, "User not KYC verified");
        require(newLevel > kycData[user].level, "New level must be higher");
        require(newLevel <= uint256(VerificationLevel.INSTITUTIONAL), "Invalid level");
        
        // Vérifier la signature
        _validateUpgradeSignature(user, newLevel, additionalDataIpfs, signature);
        
        // Mise à jour des données
        kycData[user].level = newLevel;
        kycData[user].ipfsHash = string(abi.encodePacked(
            kycData[user].ipfsHash,
            ";",
            additionalDataIpfs
        ));
        kycData[user].lastUpdate = block.timestamp;
        kycData[user].expiresAt = block.timestamp + kycExpiryPeriod;
        
        // Recalcul du score de risque
        kycData[user].riskScore = _calculateRiskScore(
            user,
            kycData[user].countryCode,
            pepDatabase[user]
        );
        
        // Journal d'audit
        _logAudit(user, "KYC_UPGRADE", abi.encode(newLevel, additionalDataIpfs));
        
        emit KYCUpdated(
            user,
            newLevel,
            block.timestamp + kycExpiryPeriod,
            msg.sender
        );
    }
    
    // Vérification périodique (à appeler régulièrement)
    function performPeriodicCheck(address user) external onlyRole(KYC_AUDITOR) {
        require(kycData[user].isActive, "User not KYC verified");
        
        // Vérifier l'expiration
        if (block.timestamp > kycData[user].expiresAt) {
            _revokeKYC(user, "KYC expired");
            return;
        }
        
        // Vérification des sanctions mise à jour
        if (block.timestamp > _lastSanctionCheck(user) + sanctionCheckInterval) {
            _performSanctionCheck(user, kycData[user].countryCode);
        }
        
        // Vérification PEP mise à jour
        _updatePEPStatus(user, kycData[user].countryCode);
        
        // Recalcul du score de risque
        kycData[user].riskScore = _calculateRiskScore(
            user,
            kycData[user].countryCode,
            pepDatabase[user]
        );
        
        kycData[user].lastUpdate = block.timestamp;
        
        _logAudit(user, "PERIODIC_CHECK", "");
    }
    
    // Vérification de l'éligibilité pour une action
    function checkEligibility(
        address user,
        uint256 amount,
        string memory actionType
    ) external view returns (bool eligible, string memory reason) {
        if (!kycData[user].isActive) {
            return (false, "KYC not verified");
        }
        
        if (block.timestamp > kycData[user].expiresAt) {
            return (false, "KYC expired");
        }
        
        // Vérification des sanctions
        if (_isCurrentlySanctioned(user)) {
            return (false, "User is sanctioned");
        }
        
        // Vérification PEP pour les montants élevés
        if (pepDatabase[user] && amount > pepCheckThreshold) {
            return (false, "PEP requires enhanced due diligence");
        }
        
        // Vérification du niveau KYC requis
        uint256 requiredLevel = _getRequiredKYCLevel(amount, actionType);
        if (kycData[user].level < requiredLevel) {
            return (false, "Insufficient KYC level");
        }
        
        // Vérification du score de risque
        if (kycData[user].riskScore > 800) { // Haut risque
            return (false, "High risk profile");
        }
        
        return (true, "Eligible");
    }
    
    // Ajout manuel d'un PEP
    function flagAsPEP(
        address user,
        string memory details,
        bytes memory evidenceIpfs
    ) external onlyRole(SANCTION_MANAGER) {
        pepDatabase[user] = true;
        
        // Mise à jour du score de risque
        if (kycData[user].isActive) {
            kycData[user].riskScore = _calculateRiskScore(
                user,
                kycData[user].countryCode,
                true
            );
        }
        
        _logAudit(user, "PEP_FLAGGED", abi.encode(details, evidenceIpfs));
        
        emit PEPFlagged(user, true, details, block.timestamp);
    }
    
    // Ajout d'une sanction
    function addSanction(
        address user,
        string memory sanctionList,
        string memory details,
        bytes memory evidence
    ) external onlyRole(SANCTION_MANAGER) {
        sanctionChecks[user].push(SanctionCheck({
            user: user,
            sanctionList: sanctionList,
            isSanctioned: true,
            checkedAt: block.timestamp,
            details: details
        }));
        
        // Si KYC actif, le révoquer
        if (kycData[user].isActive) {
            _revokeKYC(user, string(abi.encodePacked("Sanctioned: ", sanctionList)));
        }
        
        _logAudit(user, "SANCTION_ADDED", abi.encode(sanctionList, details, evidence));
        
        emit SanctionChecked(user, sanctionList, true, block.timestamp);
    }
    
    // Révocation de KYC
    function revokeKYC(
        address user,
        string memory reason
    ) external onlyRole(KYC_VERIFIER) {
        _revokeKYC(user, reason);
    }
    
    // Fonctions internes
    function _validateSignature(
        address user,
        string memory userId,
        string memory ipfsHash,
        string memory countryCode,
        bytes memory signature
    ) private pure {
        bytes32 messageHash = keccak256(abi.encodePacked(
            user,
            userId,
            ipfsHash,
            countryCode,
            "KYC_VERIFICATION"
        ));
        
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address recovered = ethSignedMessageHash.recover(signature);
        
        require(recovered == user, "Invalid signature");
    }
    
    function _validateUpgradeSignature(
        address user,
        uint256 newLevel,
        string memory ipfsHash,
        bytes memory signature
    ) private pure {
        bytes32 messageHash = keccak256(abi.encodePacked(
            user,
            newLevel,
            ipfsHash,
            "KYC_UPGRADE"
        ));
        
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address recovered = ethSignedMessageHash.recover(signature);
        
        require(recovered == user, "Invalid upgrade signature");
    }
    
    function _initializeBlacklistedCountries() private {
        // Liste des pays à haut risque (exemples)
        blacklistedCountries["KP"] = true; // Corée du Nord
        blacklistedCountries["IR"] = true; // Iran
        blacklistedCountries["SY"] = true; // Syrie
        blacklistedCountries["CU"] = true; // Cuba
        // À compléter selon les régulations
    }
    
    function _isBlacklistedCountry(string memory countryCode) private view returns (bool) {
        return blacklistedCountries[countryCode];
    }
    
    function _checkPEPDatabase(address user, string memory countryCode) private returns (bool) {
        // En production, intégrer avec une base de données PEP externe
        // Pour l'instant, simulation basée sur des règles simples
        
        // Règle: certains pays ont plus de risques PEP
        bool highRiskCountry = keccak256(bytes(countryCode)) == keccak256(bytes("RU")) ||
                              keccak256(bytes(countryCode)) == keccak256(bytes("CN")) ||
                              keccak256(bytes(countryCode)) == keccak256(bytes("AE"));
        
        // Simulation: 5% de chance d'être PEP dans les pays à risque
        if (highRiskCountry) {
            uint256 random = uint256(keccak256(abi.encodePacked(
                block.timestamp,
                user
            ))) % 100;
            
            if (random < 5) { // 5%
                pepDatabase[user] = true;
                return true;
            }
        }
        
        return false;
    }
    
    function _updatePEPStatus(address user, string memory countryCode) private {
        // Mise à jour périodique du statut PEP
        // À intégrer avec un service externe en production
    }
    
    function _calculateRiskScore(
        address user,
        string memory countryCode,
        bool isPEP
    ) private pure returns (uint256) {
        uint256 score = 0;
        
        // Facteur pays
        if (keccak256(bytes(countryCode)) == keccak256(bytes("US")) ||
            keccak256(bytes(countryCode)) == keccak256(bytes("UK")) ||
            keccak256(bytes(countryCode)) == keccak256(bytes("DE"))) {
            score += 100; // Pays à faible risque
        } else if (keccak256(bytes(countryCode)) == keccak256(bytes("RU")) ||
                  keccak256(bytes(countryCode)) == keccak256(bytes("CN"))) {
            score += 400; // Pays à risque moyen
        } else {
            score += 200; // Autres pays
        }
        
        // Facteur PEP
        if (isPEP) {
            score += 300;
        }
        
        // Facteur adresse (nouveau vs ancien)
        uint256 addressAge = (block.timestamp - 1609459200) / 1 days; // Depuis 2021
        if (addressAge < 365) {
            score += 100; // Adresse récente
        }
        
        return score > 1000 ? 1000 : score;
    }
    
    function _performSanctionCheck(address user, string memory countryCode) private {
        // En production, intégrer avec des APIs de sanctions
        // Pour l'instant, simulation
        
        bool isSanctioned = false;
        string memory sanctionList = "INTERNAL";
        
        // Simulation: vérification basée sur le pays
        if (keccak256(bytes(countryCode)) == keccak256(bytes("KP")) ||
            keccak256(bytes(countryCode)) == keccak256(bytes("IR"))) {
            isSanctioned = true;
            sanctionList = "OFAC";
        }
        
        sanctionChecks[user].push(SanctionCheck({
            user: user,
            sanctionList: sanctionList,
            isSanctioned: isSanctioned,
            checkedAt: block.timestamp,
            details: isSanctioned ? "Country-based sanction" : "Clear"
        }));
        
        emit SanctionChecked(user, sanctionList, isSanctioned, block.timestamp);
        
        if (isSanctioned && kycData[user].isActive) {
            _revokeKYC(user, "Sanctioned country");
        }
    }
    
    function _lastSanctionCheck(address user) private view returns (uint256) {
        SanctionCheck[] storage checks = sanctionChecks[user];
        if (checks.length == 0) {
            return 0;
        }
        return checks[checks.length - 1].checkedAt;
    }
    
    function _isCurrentlySanctioned(address user) private view returns (bool) {
        SanctionCheck[] storage checks = sanctionChecks[user];
        if (checks.length == 0) {
            return false;
        }
        
        // Vérifier la dernière entrée
        SanctionCheck memory lastCheck = checks[checks.length - 1];
        return lastCheck.isSanctioned;
    }
    
    function _getRequiredKYCLevel(
        uint256 amount,
        string memory actionType
    ) private pure returns (uint256) {
        if (amount == 0) {
            return uint256(VerificationLevel.BASIC);
        }
        
        if (amount <= 1000 * 1e18) {
            return uint256(VerificationLevel.BASIC);
        } else if (amount <= 10000 * 1e18) {
            return uint256(VerificationLevel.ADVANCED);
        } else if (amount <= 100000 * 1e18) {
            return uint256(VerificationLevel.ENHANCED);
        } else {
            return uint256(VerificationLevel.INSTITUTIONAL);
        }
    }
    
    function _revokeKYC(address user, string memory reason) private {
        require(kycData[user].isActive, "KYC already inactive");
        
        kycData[user].isActive = false;
        kycData[user].lastUpdate = block.timestamp;
        
        _logAudit(user, "KYC_REVOKED", abi.encode(reason));
        
        emit KYCRevoked(user, msg.sender, reason, block.timestamp);
    }
    
    function _logAudit(
        address user,
        string memory action,
        bytes memory data
    ) private {
        auditLogs[user].push(KYCAuditLog({
            user: user,
            action: action,
            performedBy: msg.sender,
            timestamp: block.timestamp,
            data: data
        }));
    }
    
    // Getters
    function isVerified(address user) external view returns (bool) {
        return kycData[user].isActive && block.timestamp <= kycData[user].expiresAt;
    }
    
    function getVerificationLevel(address user) external view returns (uint256) {
        if (!kycData[user].isActive || block.timestamp > kycData[user].expiresAt) {
            return uint256(VerificationLevel.UNVERIFIED);
        }
        return kycData[user].level;
    }
    
    function getKYCData(address user) external view returns (KYCData memory) {
        return kycData[user];
    }
    
    function getAuditLogs(
        address user,
        uint256 limit
    ) external view onlyRole(KYC_AUDITOR) returns (KYCAuditLog[] memory) {
        KYCAuditLog[] storage logs = auditLogs[user];
        
        if (limit == 0 || limit > logs.length) {
            limit = logs.length;
        }
        
        KYCAuditLog[] memory result = new KYCAuditLog[](limit);
        
        for (uint256 i = 0; i < limit; i++) {
            result[i] = logs[logs.length - 1 - i];
        }
        
        return result;
    }
    
    function getSanctionHistory(
        address user
    ) external view onlyRole(SANCTION_MANAGER) returns (SanctionCheck[] memory) {
        return sanctionChecks[user];
    }
    
    function calculateComplianceScore(address user) external view returns (uint256 score) {
        if (!kycData[user].isActive) {
            return 0;
        }
        
        // Score basé sur le niveau KYC, l'âge, et les vérifications
        score = kycData[user].level * 250; // 250 points par niveau
        
        // Bonus pour ancienneté
        uint256 ageDays = (block.timestamp - kycData[user].verifiedAt) / 1 days;
        if (ageDays > 180) {
            score += 100;
        }
        
        // Malus pour risque
        score = score > kycData[user].riskScore ? score - kycData[user].riskScore : 0;
        
        return score > 1000 ? 1000 : score;
    }
    
    // Configuration
    function setKYCExpiryPeriod(uint256 newPeriod) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newPeriod >= 90 days && newPeriod <= 730 days, "Invalid expiry period");
        kycExpiryPeriod = newPeriod;
    }
    
    function setPEPCheckThreshold(uint256 newThreshold) external onlyRole(DEFAULT_ADMIN_ROLE) {
        pepCheckThreshold = newThreshold;
    }
    
    function addBlacklistedCountry(string memory countryCode) external onlyRole(SANCTION_MANAGER) {
        blacklistedCountries[countryCode] = true;
    }
    
    function removeBlacklistedCountry(string memory countryCode) external onlyRole(SANCTION_MANAGER) {
        blacklistedCountries[countryCode] = false;
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\security\RegulatoryReporting.sol 
Size: %~z bytes 
--- CONTENT START --- 
// RegulatoryReporting.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract RegulatoryReporting is AccessControl {
    using ECDSA for bytes32;
    
    // Standards réglementaires
    enum ReportType {
        TRANSACTION_REPORT,    // Rapport de transaction
        SUSPICIOUS_ACTIVITY,   // Activité suspecte
        TAX_REPORT,           // Rapport fiscal
        SANCTIONS_SCREENING,  // Vérification des sanctions
        PEP_SCREENING,        // Vérification des PEP
        RISK_ASSESSMENT,      // Évaluation des risques
        ANNUAL_COMPLIANCE,    // Conformité annuelle
        AUDIT_TRAIL          // Piste d'audit
    }
    
    enum Jurisdiction {
        EU_MICA,              // UE - MiCA
        US_SEC,               // USA - SEC
        US_CFTC,              // USA - CFTC
        UK_FCA,               // UK - FCA
        SG_MAS,               // Singapore - MAS
        CH_HKMA,              // Hong Kong - HKMA
        JP_FSA,               // Japan - FSA
        AU_ASIC,              // Australia - ASIC
        CH_FINMA              // Switzerland - FINMA
    }
    
    // Structure de rapport
    struct RegulatoryReport {
        uint256 reportId;
        ReportType reportType;
        Jurisdiction jurisdiction;
        string referenceNumber;
        uint256 periodStart;
        uint256 periodEnd;
        bytes32 dataHash;     // Hash des données sur IPFS/Arweave
        address generatedBy;
        uint256 generatedAt;
        address submittedBy;
        uint256 submittedAt;
        string submissionId;  // ID de soumission externe
        bool isVerified;
        bytes auditorSignature;
        ReportStatus status;
    }
    
    // Structure de donnée réglementaire
    struct RegulatoryData {
        address entity;
        string entityType;    // "BORROWER", "LENDER", "INSURER", etc.
        string countryCode;
        uint256 riskScore;
        uint256 totalVolume;
        uint256 transactionCount;
        uint256 suspiciousCount;
        uint256 lastUpdated;
    }
    
    // Variables
    mapping(uint256 => RegulatoryReport) public reports;
    mapping(address => RegulatoryData) public entityData;
    mapping(Jurisdiction => uint256) public jurisdictionRequirements;
    mapping(string => bool) public submittedReports; // referenceNumber => submitted
    
    uint256 public reportCounter;
    uint256 public reportingInterval = 90 days;
    uint256 public thresholdAmount = 10000 * 1e18; // Seuil de reporting
    
    // Adresses autorisées
    address public auditorAddress;
    address public regulatorAddress;
    
    // Rôles
    bytes32 public constant COMPLIANCE_OFFICER = keccak256("COMPLIANCE_OFFICER");
    bytes32 public constant AUDITOR = keccak256("AUDITOR");
    bytes32 public constant REGULATOR = keccak256("REGULATOR");
    
    // Événements
    event ReportGenerated(
        uint256 indexed reportId,
        ReportType reportType,
        Jurisdiction jurisdiction,
        address indexed generatedBy,
        uint256 timestamp
    );
    
    event ReportSubmitted(
        uint256 indexed reportId,
        string referenceNumber,
        address indexed submittedBy,
        uint256 timestamp
    );
    
    event ReportVerified(
        uint256 indexed reportId,
        address indexed auditor,
        uint256 timestamp
    );
    
    event SuspiciousActivityReported(
        address indexed entity,
        string activityType,
        uint256 amount,
        address indexed reporter,
        uint256 timestamp
    );
    
    event RegulatoryDataUpdated(
        address indexed entity,
        string entityType,
        uint256 riskScore,
        uint256 timestamp
    );
    
    constructor(address _auditor, address _regulator) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(COMPLIANCE_OFFICER, msg.sender);
        
        auditorAddress = _auditor;
        regulatorAddress = _regulator;
        
        _grantRole(AUDITOR, _auditor);
        _grantRole(REGULATOR, _regulator);
        
        // Initialiser les exigences par juridiction
        _initializeJurisdictionRequirements();
    }
    
    // Générer un rapport réglementaire
    function generateReport(
        ReportType reportType,
        Jurisdiction jurisdiction,
        uint256 periodStart,
        uint256 periodEnd,
        bytes32 dataHash,
        string memory referenceNumber
    ) public onlyRole(COMPLIANCE_OFFICER) returns (uint256) {
        require(periodStart < periodEnd, "Invalid period");
        require(!submittedReports[referenceNumber], "Reference number already used");
        
        uint256 reportId = ++reportCounter;
        
        reports[reportId] = RegulatoryReport({
            reportId: reportId,
            reportType: reportType,
            jurisdiction: jurisdiction,
            referenceNumber: referenceNumber,
            periodStart: periodStart,
            periodEnd: periodEnd,
            dataHash: dataHash,
            generatedBy: msg.sender,
            generatedAt: block.timestamp,
            submittedBy: address(0),
            submittedAt: 0,
            submissionId: "",
            isVerified: false,
            auditorSignature: "",
            status: ReportStatus.GENERATED
        });
        
        submittedReports[referenceNumber] = true;
        
        emit ReportGenerated(reportId, reportType, jurisdiction, msg.sender, block.timestamp);
        
        return reportId;
    }
    
    // Soumettre un rapport à un régulateur
    function submitReport(
        uint256 reportId,
        string memory submissionId,
        bytes memory regulatorSignature
    ) external onlyRole(COMPLIANCE_OFFICER) {
        RegulatoryReport storage report = reports[reportId];
        require(report.status == ReportStatus.GENERATED, "Report not in generated state");
        
        // Vérifier la signature du régulateur
        _validateRegulatorSignature(reportId, submissionId, regulatorSignature);
        
        report.submittedBy = msg.sender;
        report.submittedAt = block.timestamp;
        report.submissionId = submissionId;
        report.status = ReportStatus.SUBMITTED;
        
        emit ReportSubmitted(reportId, submissionId, msg.sender, block.timestamp);
    }
    
    // Rapporter une activité suspecte
    function reportSuspiciousActivity(
        address entity,
        string memory activityType,
        uint256 amount,
        string memory description,
        bytes memory evidenceHash
    ) external onlyRole(COMPLIANCE_OFFICER) {
        // Mettre à jour les données de l'entité
        RegulatoryData storage data = entityData[entity];
        data.suspiciousCount++;
        data.riskScore = _calculateRiskScore(data);
        data.lastUpdated = block.timestamp;
        
        // Générer un rapport automatique
        bytes32 dataHash = keccak256(abi.encodePacked(
            entity,
            activityType,
            amount,
            description,
            evidenceHash
        ));
        
        generateReport(
            ReportType.SUSPICIOUS_ACTIVITY,
            _getEntityJurisdiction(entity),
            block.timestamp - 1 days,
            block.timestamp,
            dataHash,
            string(abi.encodePacked("SAR-", _toString(block.timestamp)))
        );
        
        emit SuspiciousActivityReported(
            entity,
            activityType,
            amount,
            msg.sender,
            block.timestamp
        );
    }
    
    // Mettre à jour les données réglementaires d'une entité
    function updateEntityData(
        address entity,
        string memory entityType,
        string memory countryCode,
        uint256 totalVolume,
        uint256 transactionCount
    ) external onlyRole(COMPLIANCE_OFFICER) {
        RegulatoryData storage data = entityData[entity];
        
        data.entity = entity;
        data.entityType = entityType;
        data.countryCode = countryCode;
        data.totalVolume = totalVolume;
        data.transactionCount = transactionCount;
        data.riskScore = _calculateRiskScore(data);
        data.lastUpdated = block.timestamp;
        
        // Vérifier si un rapport est nécessaire
        _checkReportingRequirements(entity, totalVolume);
        
        emit RegulatoryDataUpdated(entity, entityType, data.riskScore, block.timestamp);
    }
    
    // Vérifier et générer des rapports automatiques
    function checkAndGenerateReports() external onlyRole(COMPLIANCE_OFFICER) {
        uint256 currentPeriod = block.timestamp / reportingInterval;
        uint256 lastReportedPeriod = _getLastReportedPeriod();
        
        if (currentPeriod > lastReportedPeriod) {
            // Générer les rapports périodiques
            _generatePeriodicReports(currentPeriod);
        }
    }
    
    // Fonctions internes
    function _initializeJurisdictionRequirements() private {
        jurisdictionRequirements[Jurisdiction.EU_MICA] = 30 days;
        jurisdictionRequirements[Jurisdiction.US_SEC] = 90 days;
        jurisdictionRequirements[Jurisdiction.UK_FCA] = 30 days;
        jurisdictionRequirements[Jurisdiction.SG_MAS] = 90 days;
        // ... autres juridictions
    }
    
    function _validateRegulatorSignature(
        uint256 reportId,
        string memory submissionId,
        bytes memory signature
    ) private view {
        bytes32 messageHash = keccak256(abi.encodePacked(
            reportId,
            submissionId,
            block.chainid,
            address(this),
            "REGULATOR_SUBMISSION"
        ));
        
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address recovered = ethSignedMessageHash.recover(signature);
        
        require(recovered == regulatorAddress, "Invalid regulator signature");
    }
    
    function _calculateRiskScore(RegulatoryData memory data) private pure returns (uint256) {
        uint256 score = 0;
        
        // Facteur volume
        if (data.totalVolume > 1000000 * 1e18) score += 300;
        else if (data.totalVolume > 100000 * 1e18) score += 200;
        else if (data.totalVolume > 10000 * 1e18) score += 100;
        
        // Facteur transactions suspectes
        score += data.suspiciousCount * 100;
        
        // Facteur pays (simplifié)
        if (keccak256(bytes(data.countryCode)) == keccak256(bytes("US"))) score += 50;
        else if (keccak256(bytes(data.countryCode)) == keccak256(bytes("UK"))) score += 50;
        else score += 100;
        
        return score > 1000 ? 1000 : score;
    }
    
    function _getEntityJurisdiction(address entity) private view returns (Jurisdiction) {
        RegulatoryData memory data = entityData[entity];
        
        // Logique simplifiée pour déterminer la juridiction
        if (keccak256(bytes(data.countryCode)) == keccak256(bytes("US"))) {
            return Jurisdiction.US_SEC;
        } else if (keccak256(bytes(data.countryCode)) == keccak256(bytes("UK"))) {
            return Jurisdiction.UK_FCA;
        } else if (keccak256(bytes(data.countryCode)) == keccak256(bytes("SG"))) {
            return Jurisdiction.SG_MAS;
        } else {
            return Jurisdiction.EU_MICA; // Par défaut
        }
    }
    
    function _checkReportingRequirements(address entity, uint256 volume) private {
        if (volume >= thresholdAmount) {
            // Générer un rapport de transaction important
            generateReport(
                ReportType.TRANSACTION_REPORT,
                _getEntityJurisdiction(entity),
                block.timestamp - 1 days,
                block.timestamp,
                keccak256(abi.encodePacked(entity, volume)),
                string(abi.encodePacked("LTR-", _toString(block.timestamp)))
            );
        }
    }
    
    function _generatePeriodicReports(uint256 period) private {
        // Générer les rapports pour toutes les juridictions
        for (uint8 i = 0; i <= uint8(type(Jurisdiction).max); i++) {
            Jurisdiction jurisdiction = Jurisdiction(i);
            
            generateReport(
                ReportType.ANNUAL_COMPLIANCE,
                jurisdiction,
                period * reportingInterval,
                (period + 1) * reportingInterval,
                keccak256(abi.encodePacked(period, jurisdiction)),
                string(abi.encodePacked("PERIODIC-", _toString(period), "-", _toString(i)))
            );
        }
    }
    
    function _getLastReportedPeriod() private view returns (uint256) {
        // À implémenter: récupérer la dernière période reportée
        return 0;
    }
    
    function _toString(uint256 value) private pure returns (string memory) {
        if (value == 0) return "0";
        
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        
        return string(buffer);
    }
    
    // Getters
    function getEntityRiskScore(address entity) external view returns (uint256) {
        return entityData[entity].riskScore;
    }
    
    function getPendingReports() external view returns (uint256[] memory) {
        uint256 count = 0;
        
        // Compter les rapports en attente
        for (uint256 i = 1; i <= reportCounter; i++) {
            if (reports[i].status == ReportStatus.GENERATED) {
                count++;
            }
        }
        
        // Collecter les IDs
        uint256[] memory pending = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 1; i <= reportCounter; i++) {
            if (reports[i].status == ReportStatus.GENERATED) {
                pending[index] = i;
                index++;
            }
        }
        
        return pending;
    }
    
    function getJurisdictionReportCount(Jurisdiction jurisdiction) 
        external 
        view 
        returns (uint256) 
    {
        uint256 count = 0;
        
        for (uint256 i = 1; i <= reportCounter; i++) {
            if (reports[i].jurisdiction == jurisdiction) {
                count++;
            }
        }
        
        return count;
    }
    
    // Enums et statuts
    enum ReportStatus {
        GENERATED,
        SUBMITTED,
        VERIFIED,
        REJECTED,
        ARCHIVED
    }
}--- CONTENT END --- 
 
[FILE !filecount!] D:\structured-lending-protocol-clean\contracts\utils\CriteriaFilter.sol 
Size: %~z bytes 
--- CONTENT START --- 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "../interfaces/ILoanPool.sol";

/**
 * @title CriteriaFilter - Filtre dynamique pour les pools de prêt
 * @notice Permet aux prêteurs de filtrer les pools selon leurs préférences
 */
contract CriteriaFilter is Ownable {
    
    struct LenderPreferences {
        string[] preferredRegions;
        bool ecologicalOnly;
        string[] activityDomains;
        uint256 minInterestRate;     // en points de base
        uint256 maxRiskScore;        // 1-10
        uint256 minInvestmentAmount;
        uint256 maxInvestmentAmount;
        uint256 preferredDurationMin;
        uint256 preferredDurationMax;
        uint256 createdAt;
        uint256 lastUpdated;
    }
    
    // Référence au contrat principal
    ILoanPool public loanPool;
    
    // Stockage des préférences
    mapping(address => LenderPreferences) public preferences;
    
    // Mappings pour l'indexation
    mapping(string => bool) public validRegions;
    mapping(string => bool) public validDomains;
    
    // Événements
    event PreferencesUpdated(address indexed lender);
    event PoolsFiltered(address indexed lender, uint256[] poolIds);
    
    constructor(address _loanPool) Ownable(msg.sender) {
        loanPool = ILoanPool(_loanPool);
        
        // Initialisation des régions valides
        validRegions["Europe"] = true;
        validRegions["North America"] = true;
        validRegions["Asia"] = true;
        validRegions["Africa"] = true;
        validRegions["South America"] = true;
        
        // Initialisation des domaines valides
        validDomains["Renewable Energy"] = true;
        validDomains["Technology"] = true;
        validDomains["Agriculture"] = true;
        validDomains["Real Estate"] = true;
        validDomains["Manufacturing"] = true;
        validDomains["Education"] = true;
        validDomains["Healthcare"] = true;
    }
    
    /**
     * @notice Met à jour les préférences d'un prêteur
     */
    function updatePreferences(
        string[] memory regions,
        bool ecologicalOnly,
        string[] memory domains,
        uint256 minRate,
        uint256 maxRisk,
        uint256 minInvestment,
        uint256 maxInvestment,
        uint256 durationMin,
        uint256 durationMax
    ) external {
        // Validation des régions
        for (uint256 i = 0; i < regions.length; i++) {
            require(validRegions[regions[i]], "Invalid region");
        }
        
        // Validation des domaines
        for (uint256 i = 0; i < domains.length; i++) {
            require(validDomains[domains[i]], "Invalid domain");
        }
        
        // Validation des paramètres
        require(minRate <= 5000, "Min rate too high"); // Max 50%
        require(maxRisk <= 10, "Max risk invalid");
        require(minInvestment <= maxInvestment, "Invalid investment range");
        require(durationMin <= durationMax, "Invalid duration range");
        
        // Mise à jour des préférences
        preferences[msg.sender] = LenderPreferences({
            preferredRegions: regions,
            ecologicalOnly: ecologicalOnly,
            activityDomains: domains,
            minInterestRate: minRate,
            maxRiskScore: maxRisk,
            minInvestmentAmount: minInvestment,
            maxInvestmentAmount: maxInvestment,
            preferredDurationMin: durationMin,
            preferredDurationMax: durationMax,
            createdAt: block.timestamp,
            lastUpdated: block.timestamp
        });
        
        emit PreferencesUpdated(msg.sender);
    }
    
    /**
     * @notice Filtre les pools selon les préférences
     */
    function filterPools(
        string[] memory regions,
        bool ecologicalOnly,
        string[] memory domains,
        uint256 minRate,
        uint256 maxRisk
    ) external view returns (uint256[] memory) {
        // Cette fonction est appelée par LoanPool
        // Dans une implémentation réelle, on parcourrait tous les pools
        
        // Pour l'instant, retourne un tableau vide
        // L'implémentation complète nécessite l'accès à tous les pools
        uint256[] memory filtered = new uint256[](0);
        return filtered;
    }
    
    /**
     * @notice Filtre les pools pour un prêteur spécifique
     */
    function filterPoolsForLender(address lender) external view returns (uint256[] memory) {
        LenderPreferences memory prefs = preferences[lender];
        
        // Logique de filtrage simplifiée
        // Dans la vraie implémentation, il faudrait:
        // 1. Récupérer tous les pools actifs
        // 2. Appliquer chaque critère
        // 3. Trier par score de pertinence
        
        uint256[] memory result = new uint256[](0);
        emit PoolsFiltered(lender, result);
        
        return result;
    }
    
    /**
     * @notice Calcule un score de pertinence pour un pool
     */
    function calculateMatchScore(
        uint256 poolId,
        LenderPreferences memory prefs
    ) public view returns (uint256 score) {
        score = 0;
        
        // Récupération des données du pool
        ILoanPool.PoolData memory pool = loanPool.getPoolDetails(poolId);
        
        // 1. Critère Région (30 points max)
        for (uint256 i = 0; i < prefs.preferredRegions.length; i++) {
            if (keccak256(bytes(pool.region)) == keccak256(bytes(prefs.preferredRegions[i]))) {
                score += 30;
                break;
            }
        }
        
        // 2. Critère Écologique (20 points)
        if (!prefs.ecologicalOnly || pool.isEcological) {
            score += 20;
        }
        
        // 3. Critère Domaine (25 points max)
        for (uint256 i = 0; i < prefs.activityDomains.length; i++) {
            if (keccak256(bytes(pool.activityDomain)) == keccak256(bytes(prefs.activityDomains[i]))) {
                score += 25;
                break;
            }
        }
        
        // 4. Critère Taux d'intérêt (15 points)
        if (pool.dynamicInterestRate >= prefs.minInterestRate) {
            score += 15;
        }
        
        // 5. Critère Risque (10 points)
        if (pool.riskScore <= prefs.maxRiskScore) {
            score += 10;
        }
        
        return score;
    }
    
    // ============ FONCTIONS ADMIN ============
    
    function addValidRegion(string memory region) external onlyOwner {
        validRegions[region] = true;
    }
    
    function removeValidRegion(string memory region) external onlyOwner {
        validRegions[region] = false;
    }
    
    function addValidDomain(string memory domain) external onlyOwner {
        validDomains[domain] = true;
    }
    
    function removeValidDomain(string memory domain) external onlyOwner {
        validDomains[domain] = false;
    }
    
    function setLoanPool(address _loanPool) external onlyOwner {
        loanPool = ILoanPool(_loanPool);
    }
}--- CONTENT END --- 
 
=== SCRIPT FILES === 
D:\structured-lending-protocol-clean\scripts\seed-testnet.js 
--- CONTENT START --- 
// scripts/seed-testnet.js
const hre = require("hardhat");
const { ethers } = hre;

async function main() {
  console.log("🌱 Peuplement du protocole avec des données de test...\n");
  
  const [deployer] = await ethers.getSigners();
  console.log(`Utilisateur: ${deployer.address}`);
  
  // Adresses des contrats (à remplacer après déploiement)
  const LOAN_POOL_ADDRESS = "0x...";
  const STABLECOIN_ADDRESS = "0x...";
  
  const LoanPool = await ethers.getContractFactory("LoanPool");
  const loanPool = LoanPool.attach(LOAN_POOL_ADDRESS);
  
  const Stablecoin = await ethers.getContractFactory("MockERC20");
  const stablecoin = Stablecoin.attach(STABLECOIN_ADDRESS);
  
  // Données de test
  const testPools = [
    {
      name: "Ferme Solaire Normandie",
      description: "Installation de panneaux solaires sur 5 hectares",
      amount: ethers.parseEther("50000"),
      duration: 180 * 24 * 60 * 60, // 180 jours
      region: "Europe",
      ecological: true,
      domain: "Renewable Energy",
      ipfs: "QmVFqK123..."
    },
    {
      name: "Startup AgriTech Bretagne",
      description: "Développement de serres connectées",
      amount: ethers.parseEther("25000"),
      duration: 120 * 24 * 60 * 60,
      region: "Europe",
      ecological: true,
      domain: "Agriculture",
      ipfs: "QmVFqK456..."
    },
    {
      name: "Rénovation Immeuble Lyon",
      description: "Rénovation énergétique d'un immeuble de 20 appartements",
      amount: ethers.parseEther("150000"),
      duration: 240 * 24 * 60 * 60,
      region: "Europe",
      ecological: true,
      domain: "Real Estate",
      ipfs: "QmVFqK789..."
    },
    {
      name: "Atelier Vélo Électrique Paris",
      description: "Création d'un atelier de réparation et vente de vélos électriques",
      amount: ethers.parseEther("15000"),
      duration: 90 * 24 * 60 * 60,
      region: "Europe",
      ecological: true,
      domain: "Manufacturing",
      ipfs: "QmVFqK012..."
    }
  ];
  
  const testInvestments = [
    { poolIndex: 0, amount: ethers.parseEther("10000") },
    { poolIndex: 0, amount: ethers.parseEther("15000") },
    { poolIndex: 1, amount: ethers.parseEther("5000") },
    { poolIndex: 1, amount: ethers.parseEther("7000") },
    { poolIndex: 2, amount: ethers.parseEther("30000") },
    { poolIndex: 3, amount: ethers.parseEther("5000") }
  ];
  
  // 1. Créer les pools
  console.log("1. Création des pools de test...");
  for (let i = 0; i < testPools.length; i++) {
    const pool = testPools[i];
    
    console.log(`   Pool ${i}: ${pool.name}`);
    console.log(`   Montant: ${ethers.formatEther(pool.amount)} tokens`);
    
    try {
      const tx = await loanPool.createPool(
        pool.name,
        pool.description,
        pool.amount,
        pool.duration,
        pool.region,
        pool.ecological,
        pool.domain,
        pool.ipfs
      );
      await tx.wait();
      
      // Activer le pool
      await loanPool.activatePool(i);
      console.log(`   ✅ Pool ${i} créé et activé\n`);
    } catch (error) {
      console.log(`   ❌ Erreur sur pool ${i}:`, error.message);
    }
    
    // Petite pause entre les transactions
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  // 2. Simuler des investissements
  console.log("\n2. Simulation d'investissements...");
  
  // Créer des investisseurs test
  const testInvestors = [];
  for (let i = 0; i < 5; i++) {
    const investor = ethers.Wallet.createRandom().connect(ethers.provider);
    testInvestors.push(investor);
    
    // Funding avec stablecoin test
    await stablecoin.mint(investor.address, ethers.parseEther("50000"));
    await stablecoin.connect(investor).approve(LOAN_POOL_ADDRESS, ethers.parseEther("50000"));
    
    console.log(`   Investisseur ${i}: ${investor.address.slice(0, 10)}...`);
  }
  
  // Répartir les investissements
  let investmentCount = 0;
  for (const investment of testInvestments) {
    const investor = testInvestors[investmentCount % testInvestors.length];
    
    console.log(`   Investissement ${investmentCount}: ${ethers.formatEther(investment.amount)} dans pool ${investment.poolIndex}`);
    
    try {
      const tx = await loanPool.connect(investor).invest(
        investment.poolIndex,
        investment.amount
      );
      await tx.wait();
      console.log(`   ✅ Investissement ${investmentCount} réussi`);
    } catch (error) {
      console.log(`   ❌ Erreur:`, error.message);
    }
    
    investmentCount++;
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  // 3. Vérifier l'état final
  console.log("\n3. État final des pools:");
  
  for (let i = 0; i < testPools.length; i++) {
    const pool = await loanPool.getPoolDetails(i);
    const percentage = (Number(pool.collectedAmount) / Number(pool.targetAmount) * 100).toFixed(1);
    
    console.log(`   Pool ${i} - ${pool.projectName}:`);
    console.log(`     Collecté: ${ethers.formatEther(pool.collectedAmount)} / ${ethers.formatEther(pool.targetAmount)} (${percentage}%)`);
    console.log(`     Taux dynamique: ${pool.dynamicInterestRate / 100}%`);
    console.log(`     Statut: ${getStatusName(pool.status)}\n`);
  }
  
  // 4. Créer une offre spéciale
  console.log("\n4. Création d'une offre spéciale...");
  
  const SpecialOfferManager = await ethers.getContractFactory("SpecialOfferManager");
  const specialOfferManager = SpecialOfferManager.attach("0x..."); // Adresse du manager
  
  try {
    const tx = await specialOfferManager.createOffer(
      1, // SEASONAL
      "Offre Printemps Écologique",
      "Bonus pour tous les projets écologiques ce printemps",
      150, // 1.5% bonus
      30 * 24 * 60 * 60, // 30 jours
      ethers.parseEther("50000"), // 50,000 max bonus
      [0, 1, 2, 3] // Tous les pools
    );
    await tx.wait();
    console.log("   ✅ Offre spéciale créée");
  } catch (error) {
    console.log("   ❌ Erreur création offre:", error.message);
  }
  
  console.log("\n" + "=".repeat(60));
  console.log("✅ PEUPLEMENT TERMINÉ !");
  console.log("=".repeat(60));
  console.log("\n📊 Résumé:");
  console.log(`• ${testPools.length} pools créés`);
  console.log(`• ${testInvestments.length} investissements simulés`);
  console.log(`• ${testInvestors.length} investisseurs test`);
  console.log("\n🌐 Pour tester:");
  console.log(`1. Accéder à LoanPool: ${LOAN_POOL_ADDRESS}`);
  console.log(`2. Vérifier sur Etherscan`);
  console.log(`3. Tester avec le frontend`);
}

function getStatusName(statusCode) {
  const statuses = [
    "CREATION", "ACTIVE", "FUNDED", "ONGOING", 
    "COMPLETED", "DEFAULTED", "LIQUIDATED", "CANCELLED"
  ];
  return statuses[statusCode] || "INCONNU";
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});--- CONTENT END --- 
 
D:\structured-lending-protocol-clean\scripts\Phase 1 - Environnement de Développement.bat 
--- CONTENT START --- 
# 1. Configuration initiale
npm init -y
npm install --save-dev hardhat @nomiclabs/hardhat-ethers ethers
npm install @openzeppelin/contracts @chainlink/contracts

# 2. Structure de projet
contracts/
├── core/
│   ├── LoanPool.sol
│   └── LoanNFT.sol
├── risk/
│   ├── RiskEngine.sol
│   └── DynamicTranche.sol
├── insurance/
│   ├── InsuranceModule.sol
│   └── DecentralizedGuaranteeFund.sol
└── governance/
    ├── GovernanceDAO.sol
    └── AccessController.sol

# 3. Tests unitaires
test/
├── unit/
│   ├── LoanPool.test.js
│   └── RiskEngine.test.js
└── integration/
    └── FullWorkflow.test.js--- CONTENT END --- 
 
D:\structured-lending-protocol-clean\scripts\Commandes d'Exécution.sh 
--- CONTENT START --- 
# 1. Installation des dépendances
npm install

# 2. Compilation des contrats
npx hardhat compile

# 3. Tests
npx hardhat test
npx hardhat coverage

# 4. Déploiement Testnet
npx hardhat run scripts/deploy-testnet.js --network polygonMumbai

# 5. Déploiement Phase 1 Mainnet
npx hardhat run scripts/deploy-mainnet-phase1.js --network polygon

# 6. Déploiement Complet Mainnet (après Phase 1)
npx hardhat run scripts/deploy-mainnet-full.js --network polygon

# 7. Vérification sur Polygonscan
npx hardhat verify --network polygon 0xCONTRACT_ADDRESS "Constructor Arg 1" "Arg 2"--- CONTENT END --- 
 
D:\structured-lending-protocol-clean\scripts\Sortie attendue du script _seed-testnet.js_.txt 
--- CONTENT START --- 
🌱 Peuplement du protocole avec des données de test...

1. Création des pools de test...
   Pool 0: Ferme Solaire Normandie
   Montant: 50000.0 tokens
   ✅ Pool 0 créé et activé
   ...

2. Simulation d'investissements...
   Investisseur 0: 0x7a3f8b...
   ...

3. État final des pools:
   Pool 0 - Ferme Solaire Normandie:
     Collecté: 25000.0 / 50000.0 (50.0%)
     Taux dynamique: 5.2%
     Statut: ACTIVE
   ...

✅ PEUPLEMENT TERMINÉ !--- CONTENT END --- 
 
= SHARE FILE CREATED = 
Total contract files: 27 
